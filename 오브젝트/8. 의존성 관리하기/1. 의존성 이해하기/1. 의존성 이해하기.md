# 협력과 의존성

- 잘 설계된 객체지향 앱은 작고 응집도 높은 객체들로 구성되는데, 이는 책임의 초점이 명확하고 한 가지 일만 잘 하는 객체를 의미함
- 협력을 위해서는 의존성이 필요한데 과도한 의존성은 앱을 수정하기 어렵게 만듬

<br>

# 변경과 의존성

- 어떤 객체가 협력하기 위해서 다른 객체를 필요로 할 떄 두 객체 사이에 의존성이 존재하게됨
- 의존성은 `실행 시점`과 `구현 시점` 두 가지로 구분되는데 서로 다른 의미를 갖는다
  - 실행 시점 : 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야한다
  - 구현 시점 : 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다
- 의존성은 방향성을 가지며 항상 단방향으로 존재한다
- 서로 의존하는 다 요소 사이의 의존서은 의존되는 요소가 변경될 때 의존하는 요소도 함께 변경될 수 있다
- 따라서 의존성은 변경에 의한 영향의 전파 가능성을 암시한다

<br>

# 의존성 전이

- `의존성 전이`가 의미하는 것은 `A -> B`인 경우 A는 B가 의존하는 대상에 대해서도 자동적으로 의존하게 된다는 것이다
- 하지만 모든 경우 의존성이 전이되는것은 아니고, 의존성이 실제로 정의될지 여부는 변경의 방향과 캡술화의 정도에 따라 달라진다

<br>

### 직접 의존성(Direct Dependency)

- 한 요소가 다른 요소에 직접 의존하는 경우를 가르킨다
- 이런 경우는 `A -> B`인 경우 A의 코드에 B가 명시적으로 드러난다

<br>

### 간접 의존성(Indirect Dependency)

- 직접적인 관계는 존재하지 않지만, 의존성 전이에 의해서 영향이 전파되는 경우를 가르킨다
- 이런 경우는 코드에 명시적으로 의존성이 드러나지 않는다

<br>

# 런타임 의존성과 컴파일타임 의존성

- 런타임 의존성과 컴파일타임 의존성을 다를 수 있다. 유연하고 재사용이 가능한 코드를 위해서는 두 종류의 의존성을 서로 다르게 만들어야한다

### 런타임 의존성(Run-time Dependency)

- 말 그대로 앱이 실행되는 시점을 가르킨다
- 객체지향 앱에서 런타임의 주인공은 객체다. 즉 런타임 의존성이 다루는 주제는 객체 사이의 의존성이다
  <br>

### 컴파일타임 의존성(Compile-time Dependency)

- 일반적으로 작성된 코드를 컴파일하는 시점을 가리키지만 문맥에 따라서는 코드 그 자체를 가르키기도 한다
- 코드 관점에서의 주인공은 `클래스`다. 즉 컴파일타임 의존성이 다루는 주제는 클래스 사이의 의존성이다

<br>

### 예제: 영화와 할인정책

- 영화의 경우는 컴파일 시점에는 실제로 `DiscountPolicy`와 의존성을 가진다
- 하지만 런타임에서는 `AmountDiscountPolicy`, `NoneDiscountPolicy`등 과 의존성을 갖게된다
- 영화에서 위 2개의 대해서 직접적인 의존성을 가질수도 있지만, 그런 경우는 전체적인 결합도를 높이고 새로운 할인정책 추가가 어려워진다
- 결국 클래스의 인스턴스가 다양한 인스턴스와 협력하기 위해서는 협력할 인스턴스의 구체적인 클래스를 알아서는 안된다
- 컴파일 타임의 의존성과 런타임 구조 사이의 거리가 멀면 멀수록 설계가 유연해지고 재사용이 가능해진다

```ts
export default class Movie {
  private discountPolicy: DiscountPolicy;
}

export default abstract class DefaultDiscountPolicy implements DiscountPolicy {}

export default class AmountDiscountPolicy extends DefaultDiscountPolicy {}
```

<br>

# 컨텍스트 독립성

- 클래스가 특정한 문맥에 강하게 결합될수록 다른 문맥에서 사용하기는 더 어려워진다
- 클래스가 사용될 특정한 문맥에 대해서 최소한의 가정만으로 이줘져 있다면 다른 문맥에서 재사용하기 더 쉬운데 이를 `컨텍스트 독립성`이라 한다
- 설계가 유연해지기 위해서는 가능한 한 자신이 실행될 컨텍스트에 대한 구체적인 정보를 최대한 적게 알고있어야 한다

<br>

# 의존성 해결하기

- 컴파일타임 의존성은 구체적인 런타임 의존성으로 대체되어야 한다
- 이는 컴파일 타임에는 `Movie` -> `DiscountPolicy`를 가지고, 런타임에는 `Movie` -> `AmountDiscountPolicy` 의존성을 가진다는 뜻이다
- 컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는걸 `의존성 해결`이라고 부른다

<br>

### `setter` 메소드를 통한 의존성 해결

- 대표적으로 `setter` 메소드를 통해서 가능한데, 이는 객체를 생성한 이후에도 의존하고 있는 대상을 변경할 수 있는 가능성을 열고싶을때 유용하다
- 단점은 객체가 생성된 이후에 협력에 필요한 의존 대상을 설정하기 때문에 객체를 생성하고 의존 대상을 설정하기 전까지는 객체가 불안정할수도 있다

<br>

### 생성자 + `setter` 메소드를 통한 의존성 해결

- 단순히 setter만 공개하는게 아닌 기존에 생성자에 setter에서 변경하고자 하는 의존성을 먼저 전달한다
- 그 이후에 변경이 필요한 경우 setter를 통해서 변경을 진행하는 방식이다
- 이러한 방식은 시스템의 상태를 안정적이게 만들고 유연성을 향상시킬수 있기때문에 의존성 해결을 위해 가장 선호되는 방법이다
