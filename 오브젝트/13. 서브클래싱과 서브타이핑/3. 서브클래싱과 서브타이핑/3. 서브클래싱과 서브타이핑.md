# 언제 상속을 사용해야 될까?

- 상속의 올바른 용도는 코드의 재사용이 아닌 타입 계층을 구현하는 것이다
- 아래 조건을 만족하는 경우만 상속을 사용할것을 권장한다

<br>

### 상속 관계가 `is-a` 관계를 요구하는가?

- 앱을 구성하는 어휘에 대한 우리의 관점에 기반한다
- 일반적으로 `자식 클래스`는 `부모 클래스`다 라고 말해도 이상하지 않다면 상속을 사용할 후보로 간주가 가능하다

<br>

### 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가

- 상속 계층을 사용하는 클라이언트 입장에서는 부모/자식간 상속계층을 몰라야된다
- 이를 자식과 부모 클래스 사이의 `행동 호환성` 이라고 부른다
- 하지만 두 클래스에 대해서 기대하는 행동이 다르다면 그것이 어휘적으로 `is-a` 관계에 포함하더라도 상속을 사용하면 안된다

<br>

# is-a 관계

- 부모/자식 2개의 클래스가 is-a 관계를 모델링하는 경우에만 상속을 사용하는게 좋다
- 어떤 타입 S가 다른 타입 T의 일종이라면 당연히 `타입 S === 타입 T`라고 말할 수 있어야한다

<br>

### 예시

- 펭귄은 새다
- 새는 날 수 있다

```ts
class Bird {
  fly() {}
}

class Penguin extends Bird {}
```

<br>

### 예시의 문제점

- 펭귄은 새가 맞지만 날수는 없다. 즉 어휘적인 정의가 아닌 기대되는 행동에 따라서 타입 계층을 구성해야 한다
- 타입 계층의 의미는 행동에 따라서 달라질 수 있다. 그에 따라서 올바른 타입 계층이라는 의미 역시 문맥에 따라 달라질 수 있다
- 슈퍼타입과 서브타입의 관계에서는 `is-a` 보다는 `행동 호환성`이 더 중요하다

<br>

# 행동 호환성

- 위 내용에서 나온 결론은 결국 행동이 호환될 겨웅에만 타입 계층으로 묶어야 한다는 점이다
- 행동의 호환 여부를 판단하는 기준은 `클라이언트의 관점`이다
- 클라이언트에서 두 타입이 행동할 것이라고 기대하면 두 타입을 타입 계층으로 묶을 수 있다

<br>

# 클라이언트의 기대에 따라서 계층 분리하기

- 결국 `행동 호환성`을 만족시키지 않는 상속 계층을 그대로 유지한 채 클라이언트의 기대를 충족시킬 수 있는 방법을 찾는건 쉽지않다
- 이러한 문제를 해결할 수 있는 방법은 클라이언트의 기대에 맞게 상속 계층을 분리하는 것 뿐이다

<br>

### 올바른 타입 계층의 펭귄

- 더 이상 펭귄은 날 수 없는 새가 된다
- 따라서 잘못된 객체와 협력해서 기대하던 행동이 수행되지 않거나 예외가 던져지는 일은 발생하지 않는다

```ts
class Bird {}

class FlyingBird extends Bird {
  fly() {}
}

class Penguin extends Bird {}
```

<br>

### 또 다른 해결방법

- 또 다른 방법으로는 클라이언트에 따라서 인터페이스를 분리하는 방법이 존재한다
- 인터페이스는 클라이언트가 기대하는 바에 따라서 분리돼야 한다는것을 기억해야한다
- 인터페이스를 클라이언트의 기대에 따라서 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙인 `인터페이스 분리 원칙`을 만족할 수 있다
- 설계는 꼭 현실 세계를 반영할 필요는 없으며, 현실을 정확하게 묘사하는 것이 아니라 요구사항을 실용적으로 수용하는걸 목표로 해야한다
- 요점은 자연어에 현혹되는게 아닌 요구사항 속에서 클라이언트가 기대하는 행동에 집중하는 것이다

<br>

# 서브클래싱과 서브타이핑

- 상속을 사용하는 목적에 대해서 두가지 이름이 존재하는데 `서브클래싱`과 `서브타이핑`이다
- 2개의 타입에서 가장 중요한 것은 퍼블릭 인터페이스이다

<br>

### 서브클래싱

- 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우다
- 자식 클래스와 부모 클래스의 행동이 호환되지 않기 때문에 자식 클래스가 부모 클래스 인스턴스 대체가 불가능하다
- 이를 `구현 상속` 또는 `클래스 상속` 이라고 부른다

<br>

### 서브타이핑

- 타입 계층을 구성하기 위해서 상속을 사용하는 경우다
- 자식 클래스와 부모 클래스의 행동이 호환되기 때문에 서로 대체가 가능하다
- 이를 `인터페이스 상속` 이라고 부른다
- 서브타이핑을 만족하기 위해서는 `행동 호환성`을 만족시켜야 하는데 이는 `대체 가능성`을 포함한다
