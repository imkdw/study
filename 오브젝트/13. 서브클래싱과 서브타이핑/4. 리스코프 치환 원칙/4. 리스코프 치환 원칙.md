# 리스코프 치환원칙

- 서브입은 그것의 기반 타입에 대해서 대체가 가능해야 한다는 의미다
- 클라이언트가 차이점을 인식하지 못한 채 기반 클래스의 인터페이스를 통해서 서브 클래스 사용이 가능해야한다
- 즉 행동 호환성을 유지함으로써 자식 클래스가 부모 클래스를 대체할 수 있도록 구현된 상속 관계만이 `서브타이핑`이라고 불러야한다

<br>

# 클라이언트와 대체 가능성

- 자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트의 가정을 준수해야한다
- 클라이언트와 격리한 채로 본 모델은 의미 있게 검증하는 것이 불가능하다
- 상속관계에 있는 두 클래스 사이의 관계를 클라이언트와 떨어트려 놓고 판단하는건 안된다
- 클라이언트 관점에서 자식 클래스가 부모 클래스를 대체할 수 있을때만 유효하다

<br>

# is-a 관계 다시 살펴보기

- is-a 관계는 객체지향에서 중요한 것은 객체의 속성이 아니라 객체의 행동이라는 점을 강조한다
- 클라이언트를 고려하지 않은 채 개념과 속성의 측면에서 상속관계를 정할 경우는 `리스코프 치환 원칙`을 위반하는 서브클래싱이 될 확률이 높다
- 결론은 이름이 아니라 행동이 먼저다. 상속이 서브타이핑을 위해서 사용되는 경우에만 is-a 관계다

<br>

# 타입 계층과 리스코프 치환 원칙

- 클래스 상속은 타입 계층을 구현할 수 있는 다양한 방법중 하나일 뿐이다
- 언어별로 존재하는 특성(interface, trait 등)을 통해서 상속을 사용하지 않고도 타입 계층 구현이 가능하다
- 핵심은 구현 방법과 무관하게 클라이언트의 관점에서 슈퍼타입에 대해 기대하는 모든것이 서브타입에게도 적용돼야 한다는것이다
