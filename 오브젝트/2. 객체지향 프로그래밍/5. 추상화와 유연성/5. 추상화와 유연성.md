# 추상화의 힘

### 요구사항의 정책을 높은 수준에서 서술이 가능하다

- 추상화를 이용해서 상위 정책을 기술한다는 것은 기본적인 앱의 협력 흐름을 기술한다는것을 의미함
- 예를 들면 `영화 예매 요금은 최대 하나의 "할인정책"과 다수의 "할인조건"을 이용해 계산이 가능하다`라는걸 표현함
- 이러한 개념은 재사용 가능한 설계의 기본을 이루는 `디자인 패턴`, `프레임워크` 모두 추상화를 이용해서 상위 정책을 정의하는 객체지향의 매커니즘을 활용하고있음
- 이처럼 추상화를 통해서 상위 정책을 표현하면 기존 구조를 수정하지 않고도 새로운 기능을 쉽게 추가하고 확장이 가능함

<br>

# 유연한 설계

- 객체의 책임의 위치를 결정하기 위해서 조건문을 사용하는건 협력의 설계 측면에서 대부분의 경우 좋지 않은 선택임
- 가능하면 추상화를 중심으로 코드의 구조를 설계하면 유연하고 확장 가능한 설계를 만들 수 있음
- 이처럼 유연한 설게를 가능하게 하는 이유는 설계가 구체적인 상황에 결합되는것을 방지해주기 때문임
- 결론은 `유연성이 필요한곳에 추상화를 사용`하면 된다

<br>

### 예시: 조건물을 사용해서 책임의 위치 결정사례

```tscalculateMoviePrice(screening: Screening): Money {
    // 영화 금액을 계산하는 책임이 Movie에 할당됨
    if (!this.discountPolicy) {
      return Money.ZERO;
    }

    return this.fee.minus(this.discountPolicy.calculateDiscountAmount(screening));
  }
```

<br>

### 예시: 추상화를 중심으로 코드의 구조 설계하기

```ts
import DiscountCondition from "../conditions/discount-condition";
import Money from "../money";
import Screening from "../screening";
import DiscountPolicy from "./discount-policy";

export default class NoneDiscountPolicy extends DiscountPolicy {
  protected getDiscountAmount(screening: Screening): Money {
    return Money.ZERO;
  }
}
```

```ts
// Movie {
//   title: '스타워즈',
//   runningTime: Duration { milliseconds: 12600000 },
//   fee: Money { amount: 10000 },
//   discountPolicy: NoneDiscountPolicy { conditions: [] }
// }
const starwars = new Movie("스타워즈", Duration.ofMinutes(210), Money.wons(10000), new NoneDiscountPolicy([]));
```

<br>

# 추상 클래스와 인터페이스 트레이드오프

- 기존 구조에서는
