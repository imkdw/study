# 컴파일 시간 의존성과 실행 시간 의존성

- 코드의 의존성과 실행 시점의 의존성은 서로 다를수도 있음
- 클래스 사이의 의존성과 객체 사이의 의존성을 동일하지 않을수도 있음
- 확장 가능한 객체지향 설계가 가지는 특징은 코드의 의존성과 실행 시점의 의존성이 다름
- 하지만 반대로 생각하면 코드 의존성과 실행시점 의존성이 다르면 코드를 이해하기 더 힘들수도 있음
- 의존성의 양면성은 설계가 트레이드오프의 산물이라는 사실을 보여줌
- 설계가 유연해질수록 코드를 이해하고 디버깅하기는 더 어려워진다. 여기서 유연성과 가독성 사이에서 고민해야한다

<br>

# 차이에 의한 프로그래밍

- 상속이라는 개념은 객체지향에서 코드를 재사용하기 위해서 가장 널리 사용되는 방법임
- 상속은 기존 클래스를 기반으로 새로운 클래스를 쉽고 빠르게 추가할 수 있는 간편한 방법을 제공함
- 이 처럼 부모클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법을 `차이에 의한 프로그래밍`이라고 부름

<br>

# 상속과 인터페이스

- 상속이 가치있는 이유는 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을수 있기때문임
- 인터페이스는 객체가 이해할 수 있는 메시지의 목록을 정의하는 역할을 해줌
- 상속을 통해 자식 클래스는 자신의 인터페이스에 부모 클래스의 인터페이스를 포함함
- 결과적으로 자식 클래스는 부모 클래스가 수신할 수 있는 모든 메세지 수신이 가능해서 외부 객체는 자식 클래스를 부모 클래스와 동일한 타입으로 간주할 수 있음
- 자식 클래스는 상속을 통해 부모 클래스의 인터페이스를 물려받기 때문에 부모 클래스를 대신해서 사용이 가능한데, 이 처럼 자식 클래스가 부모 클래스를 대신하는 것을 `업캐스팅(Upcasting)`이라고 부름

<br>

# 다형성

- `A 객체`가 `B 객체`로 동일한 메세지를 전송하지만 실제로 어떤 메소드가 실행될 것인지는 메세지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라지는데, 이를 `다형성`이라고 부름
- 다형성은 OOP의 컴파일 시간 의존성과 런타임 시간 의존성이 다를 수 있다는 사실을 기반으로 함
- 동일한 메세지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 말함

<br>

### 지연(lazy), 동적(dynamic) 바인딩

- 위처럼 메세지에 응답하기 위해서 실행될 메소드를 컴파일 시점이 아닌 런타임 시점에 결정하는걸 의미함

<br>

### 초기(early), 정적(static) 바인딩

- 컴파일 시점에 실행될 함수나 프로시저를 결정하는것을 의미함

<br>

### 구현 상속(implementation inheritance)

- 구현 상속은 흔히 `서브클래싱(subclassing)` 이라고 표현함
- 이는 순하하게 코드를 재사용하기 위한 목적으로 상속을 사용하는걸 뜻함
- 하지만 상속은 코드 재사용을 위한 목적으로 사용하면 안됨
  - 이는 변경에 취약한 코드를 낳을수도 있음

<br>

### 인터페이스 상속(interface inheritance)

- 다형적인 협력을 위해서 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있고록 상속을 이용하는 것
- 상속을 사용할때는 구현 상속이 아닌 인터페이스 상속을 위해서 사용해야함

<br>

# 인터페이스와 다형성

- 구현은 필요하지 않고 순수하게 인터페이스만 공유를 하고싶을때가 존재함
- C#, Java, Typescript 등의 언어들은 `interface` 키워드를 제공함
- C++의 경우는 `추상 기반 클래스(abstract base class)`를 사용함
