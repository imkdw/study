# 디미터 법칙

- 이전에 데이터 주도 설계로 만든 `ReservationAgency`의 경우는 `Screening`과 강결합된다
- 어느 한쪽이 변경되면 그것들과 결합되있는 모든게 변경된다
- 이 처럼 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계문제를 해결하기 위해서 제안된 원칙이 바로 `디미터 법칙`이다
- 디미터 법칙을 간단하게 요약하면 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로는 제한하라는 것이다
- 이러한 법칙을 따르기 위해서는 클래스가 특정한 조건을 만족하는 대상에게만 메세지를 전송하도록 프로그래밍 해야한다

<br>

### 부끄럼타는 코드

- 디미터 법칙을 적용하게되면 `부끄럼타는 코드`를 작성할 수 있다
- 이는 필요한 어떤 것도 다른 객체에 보여주지 않으며, 다른 객체의 구현에 의존하지 않는 코드를 뜻한다

<br>

### 디미터 법칙과 캡슐화

- 디미터 법칙이 가치 있는 이유는 클래스를 캡슐화하기 위해 따라야하는 구체적인 지침을 제공해준다
- 디미터 법칙은 협력과 구현이라는 사뭇 달라 보이는 두 가지 문맥을 하나의 유기적인 개념으로 통합해준다

<br>

### 디미터 법칙을 위반하는 사례

- 아래 코드를 `기차 충돌`이라고 부르는데 클래스의 내부 구현이 외부로 노출됬을때 나타나는 전형적인 형태다
- 메세지 전송사는 수신자의 내부 정보를 자세히 알게되며 자연스럽게 캡슐화가 깨지고 강하게 결합된다

```ts
screening.getMovie().getDiscountConditions();
```

<br>

# 묻지 말고 시켜라

- 객체지향의 기본은 함께 변경될 확률이 높은 정보와 행동을 하나의 단위로 통합하는 것이다
- `묻지 말고 시켜라 원칙`은 객체의 정보를 이용하는 행동을 객체의 외부가 아닌 내부에 위치시킨다
- 자연스럽게 `정보 전문가`에게 책임을 할당하게 되고 높은 응집도를 가진 클래스를 얻을 확률이 높아진다
- 이처럼 인터페이스는 객체가 어떻게 하는지가 아니라 `무엇`을 하는지를 서술해야한다

<br>

# 의도를 드러내는 인터페이스

- `어떻게`가 아닌 `무엇`을 하느냐에 따라 메소드의 이름을 정하는 패턴을 `의도를 드러내는 선택자`라고 부른다
- 의도를 드러내는 인터페이스를 요약하면 구현과 관련된 모든 정보를 캡슐화하고, 협력과 관련된 의도만을 표현해야한다
- 객체에게 묻지 말고 시키되, 구현 방법이 아닌 클라이언트의 의도를 드러내야한다

### 안좋은 케이스

- 아래 메소드는 동일한 책임을 가지지만 클라이언트 관점에서는 세부 구현을 정확하게 이해하지 못하면 동일한 책임을 가진다는 사실을 알지 못한다
- 또한 메소드 수준에서 캡슐화를 위반하게 되는데, 메소드 이름을 변경하면 이를 호출하는 클라이언트도 변경한다는걸 의미한다

```ts
class PeriodCondition {
  isStatisfiedByPeriod(screening: Screening): boolean;
}

class SequenceCondition {
  isStatisfiedBySequence(screening: Screening): boolean;
}
```

<br>

### 좋은 케이스

- 좋은 메소드 이름을 짓는 방법은 `어떻게`가 아닌 `무엇`을 하는지 드러내는 것이다
- 코드를 읽고 이해하기 쉽게 만들뿐만 이니라 유연한 코드를 낳는 지름길이다
- `어떻게`를 수행하는지를 드러내는 이름은 메소드의 내부 구현을 설명하는 이름이다

```ts
class PeriodCondition {
  isStatisfiedBy(screening: Screening): boolean;
}

class SequenceCondition {
  isStatisfiedBy(screening: Screening): boolean;
}
```

<br>

#### 좀 더 고도화된 버전

- 정적 타이핑 언어에서는 단순히 메소드의 이름이 같다고 해서 동일한 메세지를 처리할 수는 없다
- 아래 예시처럼 클라이언트가 두 ㅁ제소드를 가진 객체를 동일한 타입으로 간주할 수 있도록 동일한 타입 계층으로 묶어야한다

```ts
interface DiscountCondition {
  isSatisfiedBy(screening: Screening): boolean;
}

class PeriodCondition implements DiscountCondition {
  isSatisfiedBy(screening: Screening): boolean;
}

class SequenceCondition implements DiscountCondition {
  isSatisfiedBy(screening: Screening): boolean;
}
```

<br>

# 함께 모으기

- 근본적으로 `디미터 법칙`을 위반하는 설계는 `ISP(인터페이스 구현의 분리 원칙)`을 위반한다
- 디미터 법칙을 위반한다는 것은 클라이언트에게 구현을 노출한다는 것을 의미하고, 작은 요구사항 변경에도 쉽게 무너지는 불안정한 코드가 나온다
