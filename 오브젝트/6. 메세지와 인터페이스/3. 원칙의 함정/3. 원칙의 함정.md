# 원칙의 함정

- 다양한 원칙이 존재하지만 절대적인 법칙은 아니다
- 소프트웨어 설계에 법칙이란 존재하지 않고, 법칙에는 예외가 없지만 원칙에는 예외가 넘쳐난다
- 설계는 트레이드오프의 산물이며, 원칙이 현재 상황에 부적합하다고 판단되면 과감하게 `원칙을 무시하자`

<br>

# 디미터 법칙은 하나의 도트를 강제하는 규칙이 아니다

- 디미터 법칙은 `오직 하나의 도트만을 사용하라`라는 말로 요약되기도 한다
- 하지만 아래 예시처럼 하나 이상의 도트를 사용하는 케이스가 모두 디미터 법칙을 위반하는건 아니다
- 기차 충돌처럼 보이지만 객체 내부의 구현에 대한 어떤 정보도 외부로 노출하지 않는다면 그것은 디미터 법칙을 준수한것이다

```ts
const numbers = [1, 2, 3, 4, 5];

const result = numbers
  .map((num) => num * 2) // 모든 숫자를 2배로
  .map((num) => num + 10) // 10을 더함
  .map((num) => num.toString()) // 문자열로 변환
  .map((str) => `number: ${str}`) // 문자열 포맷팅
  .map((str) => str.toUpperCase()); // 대문자로 변환

console.log(result);
// 출력: ['NUMBER: 12', 'NUMBER: 14', 'NUMBER: 16', 'NUMBER: 18', 'NUMBER: 20']
```

<br>

# 결합도와 응집도 충돌

- 객체에게 상태를 물어보고 그에 따라서 동작이 변한다면 그 코드는 `묻지말고 시켜라` 스타일로 변경해야한다
- 하지만 안타깝게도 `묻지 말고 시켜라`와 `디미터 법칙`을 준수하는 것이 항상 긍정적인 결과로만 귀결되는건 아니다
- 객체는 내부 구조를 숨겨야 하므로 디미터 법칙을 따른는 것이 좋지만, 자료구조라면 당연히 냅주를 노출해야 하므로 적용할 필요가 없다
- 항상 `원칙을 맹신하지 말라`라는 말을 기억하고, 소프트웨어 설계에 존재하는 법칙중 하나는 `경우에 따라 다르다`라는걸 명시해야한다
