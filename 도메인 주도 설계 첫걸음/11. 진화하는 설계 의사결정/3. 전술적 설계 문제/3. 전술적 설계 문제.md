# 전술적 설계 문제

- 지원이 핵심으로 변경된다고 가정한다
- 지원은 비교적 간단한 아키텍쳐로 구축되기 때문에 시간이 지남에 따라서 복잡한 규칙과 불변성이 비즈니스 로직에 추가된다
- 코드베이스는 점점 복잡해지고 기존 설계가 이렇게 복잡한 로직을 지원하지 않아서 고통스러운데, 이 `고통`은 중요한 신호다
- 변화가 필요한건 두려운게 아니며 자연스럽다. 비즈니스가 어떻게 변할지 예측할 수 없다

<br>

# 트랜잭션 스크립트 -> 액티브 레코드 전환

- 모두 절차지향 스크립트를 사용해서 비즈니스 로직을 구현하게된다
- 자료구조를 다르는거에 따라서 구분되ㅑㄴ다
- 만약 트랜잭션 스크립트에서 데이터 작업이 어려워지면 액티브 레코드 패턴으로 리팩토링하자

<br>

# 액티브 레코드 -> 도메인 모델 전환

- 액티브 레코드를 조작하는 비는니스 로직이 점점 더 복잡해지고 불일치 및 중복 사례가 많아지만 도메인 패턴으로 리팩토링하자
- 밸류 오브젝트를 식별하는 것으로 시작하는데, 관련된 비즈니스 로직을 찾아서 밸류 오브젝트의 일부로 만든다
- 이후에는 자료구조 분석 및 트랜잭션 경계를 찾아야한다. 또한 모든 상태 로직을 명시적임을 확인하기 위해서 `setter`를 `private`로 전환한다
- 에러가 많이 발생하는데 이러한 에러는 상태 수정 로직이 있는 위치를 명확하게 해준다

<br>

### 기존 액티브 레코드

```ts
export class Player {
  private id: string;
  private points: number;

  constructor() {}
}

export class ApplyBonus {
  private playerRepository: PlayerRepository;

  execute(playerId: string, percentage: number) {
    const player = this.playerRepository.load(playerId);
    player.points += player.points * (percentage / 100);
    this.playerRepository.commitChanges(player);
  }
}
```

<br>

### 도메인 모델 패턴로 리팩토링한 코드

```ts
export class Player {
  private id: string;
  private points: number;

  applyBonus(percentage: number) {
    this.points += this.points * (percentage / 100);
  }
}
```

<br>

# 도메인 모델 -> 이벤트 소싱 도메인 모델 전환

- 애그리게이트 경계가 적절하게 설계된 도메인 모델이 있다면 이벤트 소싱 모델로 전환이 가능하다
- 가장 어려운 점은 기존 애그리게이트의 이력인데, 이력이 없는 상태를 이벤트 기반 모델로 마이그레이션 하는것이다
- 모든 과거 상태 변경을 나타내는 세분화된 데이터가 없기때문에 최선의 방법으로 과거 이벤트를 생성하거나 마이그레이션 이벤트를 모델링 해야한다

<br>

# 전환에 필요한 과거 이력 생성하기

- 단순 상태 기반 표현 방식에서 프로젝션을 적용해서 히스토리를 남긴다
- ㅎ하지만 이 접근 방식도 단점이 존재하는데 상태 전환의 전체 히스토리 복구는 불가능하다
- 이벤트 소싱을 사용하는 목표는 애그리게이트의 도메인 이벤트에 대해서 안정적이고 강한 일관성을 가진 이력을 보유하는 것이다

<br>

# 마이그레이션 이벤트 모델링

- 위 방법의 대안으로는 과거 이벤트에 대한 지식 부족을 인정하고, 명시적으로 이벤트를 모델링 하는 방법이다
- 모든 이벤트를 복구하는 대신, 마이그레이션 이벤트를 정의하고 기존 애그리게이트 인스턴스의 이벤트 스트림을 초기화한다
- 만약 CQRS를 사용한다면 항상 마이그레이션 이벤트를 고려해서 프로젝션을 해야한다
