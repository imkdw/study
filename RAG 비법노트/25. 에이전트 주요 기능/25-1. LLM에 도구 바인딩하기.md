# LLM에 도구 바인딩하기
- LLM이 생각을 담당하는 뇌라면 도구는 실제 행동을 수행하는 손발과 같은 역할을 담당함
- 상황에 따라 LLM이 적절한 도구를 선택하고 실행할 수 있도록 만드는 것이 바로 `도구 바인딩`임
- LLM이 도구를 활용하려면 그 사용법이 사전 학습되어 있어야함
- 최근 나오는 모델들은 대부분 이러한 기능을 지원함

<br>

# 어떤 도구를 사용할지 확인하기
```python
import re
import requests
from bs4 import BeautifulSoup
from langchain.agents import tool
from langchain_openai import ChatOpenAI
from langchain_core.output_parsers.openai_tools import JsonOutputToolsParser


@tool
def get_word_length(word: str) -> int:
    """Returns the length of a word."""
    return len(word)


@tool
def add_function(a: float, b: float) -> float:
    """Adds two numbers together."""
    return a + b


# 네이버 뉴스 크롤러 도구
@tool
def naver_news_crawl(news_url: str) -> str:
    """Crawls a 네이버 (naver.com) news article and returns the body content."""
    response = requests.get(news_url)

    if response.status_code == 200:
        soup = BeautifulSoup(response.text, "html.parser")

        title = soup.find("h2", id="title_area").get_text()
        content = soup.find("div", id="contents").get_text()
        cleaned_title = re.sub(r"\n{2,}", "\n", title)
        cleaned_content = re.sub(r"\n{2,}", "\n", content)
    else:
        print(f"HTTP 요청 실패. 응답 코드: {response.status_code}")

    return f"{cleaned_title}\n{cleaned_content}"


def execute_tool_calls(tool_call_results):
    """
    도구 호출 결과를 실행하는 함수

    :param tool_call_results: 도구 호출 결과 리스트
    :param tools: 사용 가능한 도구 리스트
    """
    # 도구 호출 결과 리스트를 순회합니다.
    for tool_call_result in tool_call_results:
        # 도구의 이름과 인자를 추출합니다.
        tool_name = tool_call_result["type"]  # 도구의 이름(함수명)
        tool_args = tool_call_result["args"]  # 도구에 전달되는 인자

        # 도구 이름과 일치하는 도구를 찾아 실행합니다.
        # next() 함수를 사용하여 일치하는 첫 번째 도구를 찾습니다.
        matching_tool = next((tool for tool in tools if tool.name == tool_name), None)

        if matching_tool:
            # 일치하는 도구를 찾았다면 해당 도구를 실행합니다.
            result = matching_tool.invoke(tool_args)
            # 실행 결과를 출력합니다.
            print(f"[실행도구] {tool_name} [Argument] {tool_args}\n[실행결과] {result}")
        else:
            # 일치하는 도구를 찾지 못했다면 경고 메시지를 출력합니다.
            print(f"경고: {tool_name}에 해당하는 도구를 찾을 수 없습니다.")


tools = [get_word_length, add_function, naver_news_crawl]


llm = ChatOpenAI(model="gpt-4o-mini", temperature=0)

llm_with_tools = llm.bind_tools(tools)

# LLM이 어떤 도구를 사용할지 판단한 상태
# [
#     {
#         "name": "get_word_length",
#         "args": {"word": "teddynote"},
#         "id": "call_MaIAPgUbG4a2Q2u3zw5ox5DT",
#         "type": "tool_call",
#     }
# ]
print(llm_with_tools.invoke("What is the length of the word 'teddynote'?").tool_calls)


chain = llm_with_tools | JsonOutputToolsParser(tools=tools)

tool_call_results = chain.invoke("What is the length of the word 'teddynote'?")

# 출력 파서의 파싱 결과
# [{"args": {"word": "teddynote"}, "type": "get_word_length"}]
print(tool_call_results)

# [실행도구] get_word_length [Argument] {'word': 'teddynote'}
# [실행결과] 9
execute_tool_calls(tool_call_results)
```

<br>

# LCEL 체인으로 연동하기
```python
import re
import requests
from bs4 import BeautifulSoup
from langchain.agents import tool
from langchain_openai import ChatOpenAI
from langchain_core.output_parsers.openai_tools import JsonOutputToolsParser


@tool
def get_word_length(word: str) -> int:
    """Returns the length of a word."""
    return len(word)


@tool
def add_function(a: float, b: float) -> float:
    """Adds two numbers together."""
    return a + b


# 네이버 뉴스 크롤러 도구
@tool
def naver_news_crawl(news_url: str) -> str:
    """Crawls a 네이버 (naver.com) news article and returns the body content."""
    response = requests.get(news_url)

    if response.status_code == 200:
        soup = BeautifulSoup(response.text, "html.parser")

        title = soup.find("h2", id="title_area").get_text()
        content = soup.find("div", id="contents").get_text()
        cleaned_title = re.sub(r"\n{2,}", "\n", title)
        cleaned_content = re.sub(r"\n{2,}", "\n", content)
    else:
        print(f"HTTP 요청 실패. 응답 코드: {response.status_code}")

    return f"{cleaned_title}\n{cleaned_content}"


def execute_tool_calls(tool_call_results):
    """
    도구 호출 결과를 실행하는 함수

    :param tool_call_results: 도구 호출 결과 리스트
    :param tools: 사용 가능한 도구 리스트
    """
    # 도구 호출 결과 리스트를 순회합니다.
    for tool_call_result in tool_call_results:
        # 도구의 이름과 인자를 추출합니다.
        tool_name = tool_call_result["type"]  # 도구의 이름(함수명)
        tool_args = tool_call_result["args"]  # 도구에 전달되는 인자

        # 도구 이름과 일치하는 도구를 찾아 실행합니다.
        # next() 함수를 사용하여 일치하는 첫 번째 도구를 찾습니다.
        matching_tool = next((tool for tool in tools if tool.name == tool_name), None)

        if matching_tool:
            # 일치하는 도구를 찾았다면 해당 도구를 실행합니다.
            result = matching_tool.invoke(tool_args)
            # 실행 결과를 출력합니다.
            print(f"[실행도구] {tool_name} [Argument] {tool_args}\n[실행결과] {result}")
        else:
            # 일치하는 도구를 찾지 못했다면 경고 메시지를 출력합니다.
            print(f"경고: {tool_name}에 해당하는 도구를 찾을 수 없습니다.")


tools = [get_word_length, add_function, naver_news_crawl]


llm = ChatOpenAI(model="gpt-4o-mini", temperature=0)

llm_with_tools = llm.bind_tools(tools)

chain = llm_with_tools | JsonOutputToolsParser(tools=tools) | execute_tool_calls

# [실행도구] get_word_length [Argument] {'word': 'teddynote'}
# [실행결과] 9
chain.invoke("What is the length of the word 'teddynote'?")

# [실행도구] add_function [Argument] {'a': 114.5, 'b': 121.2}
# [실행결과] 235.7
chain.invoke("114.5 + 121.2")

# [실행도구] naver_news_crawl [Argument] {'news_url': 'https://n.news.naver.com/mnews/hotissue/article/092/0002347672?type=series&cid=2000065'}
# [실행결과] [미장브리핑] 9월 미국 CPI 주목…3분기 S&P500 실적 발표 /
# ▲10일(현지시간) 미국 9월 소비자물가지수(CPI) 발표 예정. 고용 지표가 양호하게 나온 가운데 물가 지표 주목. 9월 미국 비농업고용 25만4천명 증가해 시장 예상치 14만명 크게 상회. 이는 6개월 래 최대 규모로 지난 12개월 평균값 20만3천명 증가한 것보다도 높은 수치. 9월 실업률은 4.1%로 2개월 연
chain.invoke(
    "뉴스 기사 내용을 크롤링해줘: https://n.news.naver.com/mnews/hotissue/article/092/0002347672?type=series&cid=2000065"
)
```