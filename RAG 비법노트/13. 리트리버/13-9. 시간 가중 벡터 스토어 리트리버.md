# 시간 가중 벡터 스토어 리트리버
- 시간이 지날수록 중요성을 잃는 데이터는 하위로 밀려나고 신선함과 관련성을 동시에 고려하는 리트리버
- 검색 결과는 의미 유사도와 시간에 따른 감쇠를 결합한 점수를 기반으로 정렬함
- 시간 감쇠는 `감쇠율`로 설정되는데 이는 시간이 지남에 따라 점수가 얼마나 줄어드는지 결정하는 비율임
- 자주 접근되는 문서는 시간이 지나도 신선함을 유지해 높은 점수를 받아서 자주 사용되거나 중요한 정보가 검색 결과 상위에 위치함
- 감쇠율이 낮은 경우 시간이 지나도 문서의 점수가 크게 감소하지 않아서 최신, 오래된 문서의 시간 가중치 차이가 거의 없음
  - 이런 경우는 문서 간 의미 유사도가 검색 결과에 더 큰 영향을 미침

<br>

# 낮은 감쇠율
- 감쇠율이 낮다는건 기억이 더 오래 유지된다는 의미임
- 0이면 기억이 절대 잊혀지지 않는다느뜻이고 이 경우 리트리버가 검색 수행시 의미 유사도만 고려하게됨

```python
from datetime import datetime, timedelta

import faiss
from langchain.docstore import InMemoryDocstore
from langchain.retrievers import TimeWeightedVectorStoreRetriever
from langchain_community.vectorstores import FAISS
from langchain_core.documents import Document
from langchain_openai import OpenAIEmbeddings

embeddings_model = OpenAIEmbeddings(model="text-embedding-3-small")

embedding_size = 1536
index = faiss.IndexFlatL2(embedding_size)
vectorstore = FAISS(embeddings_model, index, InMemoryDocstore({}), {})

# 시간 가중치가 매우 낮은 값으로 설정되어서 시간이 지나도 문서의 신선함이 유지되게 만듦
retriever = TimeWeightedVectorStoreRetriever(
    vectorstore=vectorstore, decay_rate=0.0000000000000000000000001, k=1
)

yesterday = datetime.now() - timedelta(days=1)

# 메타데이터를 포함시켜서 문서 저장
retriever.add_documents(
    [
        Document(
            page_content="메이플스토리 하실분",
            metadata={"last_accessed_at": yesterday},
        )
    ]
)

# 메타데이터 없이 문서 저장
retriever.add_documents([Document(page_content="메이플스토리 같이 하실꺼죠?? Please!")])

# 메이플스토리 하실분이 가장 먼저 반환되는 이유는 가장 두드러지기 때문이며
# 감쇠율이 0에 가깝기 때문에 여전히 최신 상태를 유지하고 있음을 의미함
# [
#     Document(
#         metadata={
#             "last_accessed_at": datetime.datetime(2025, 8, 10, 15, 55, 22, 986341),
#             "created_at": datetime.datetime(2025, 8, 10, 15, 55, 21, 611245),
#             "buffer_idx": 0,
#         },
#         page_content="메이플스토리 하실분",
#     )
# ]
print(retriever.invoke("메이플스토리"))
```

<br>

# 높은 감쇠율
- 감쇠율이 높다는건 기억이 빠르게 사라진다는 뜻임
- 리트리버가 검색을 수행하면 과거의 정보를 거의 참조하지 않고 최신 정보에 더 의존함

```python
from datetime import datetime, timedelta

import faiss
from langchain.docstore import InMemoryDocstore
from langchain.retrievers import TimeWeightedVectorStoreRetriever
from langchain_community.vectorstores import FAISS
from langchain_core.documents import Document
from langchain_openai import OpenAIEmbeddings

embeddings_model = OpenAIEmbeddings(model="text-embedding-3-small")

embedding_size = 1536
index = faiss.IndexFlatL2(embedding_size)
vectorstore = FAISS(embeddings_model, index, InMemoryDocstore({}), {})

# 시간 가중치를 매우 높은 값으로 설정되어서 시간이 지난 문서는 거의 참조하지 않게됨
retriever = TimeWeightedVectorStoreRetriever(
    vectorstore=vectorstore, decay_rate=0.999, k=1
)

yesterday = datetime.now() - timedelta(days=1)

# 메타데이터를 포함시켜서 문서 저장
retriever.add_documents(
    [
        Document(
            page_content="메이플스토리 하실분",
            metadata={"last_accessed_at": yesterday},
        )
    ]
)

# 메타데이터 없이 문서 저장
retriever.add_documents([Document(page_content="메이플스토리 같이 하실꺼죠?? Please!")])

# [
#     Document(
#         metadata={
#             "last_accessed_at": datetime.datetime(2025, 8, 10, 15, 57, 16, 355325),
#             "created_at": datetime.datetime(2025, 8, 10, 15, 57, 15, 536100),
#             "buffer_idx": 1,
#         },
#         page_content="메이플스토리 같이 하실꺼죠?? Please!",
#     )
# ]
print(retriever.invoke("메이플스토리"))
```

<br>

# 가상의 시간으로 감쇠율 조정
- 유틸리티 함수인 `mock_now()`를 통해서 현재 시간 조작이 가능함
- 검색 시점의 시간 감쇠 효과를 테스트하거나 적절한 `감쇠율(decay_rate)`을 결정하는데 유용함

```python
import datetime

from langchain.utils import mock_now

mock_now(datetime.datetime(2024, 8, 30, 00, 00))

# 2025-08-10 16:06:40.728644
print(datetime.datetime.now())

# with mock_now(datetime.datetime(2024, 8, 29, 00, 00)):
#     # retriever.invoke("테디노트")
```