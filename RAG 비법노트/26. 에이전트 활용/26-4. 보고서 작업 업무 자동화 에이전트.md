# 보고서 작업 업무 자동화 에이전트
- 에이전트를 활용할 때는 결과물을 보면서 다양한 시험을 하고 프롬프트를 개선하는 과정이 필요함
- 먼저 프롬프트에서 개요를 작성하게 한 뒤 핵심 내용을 구체적으로 작성하게함
- 마지막에 최종 결론을 내도록 과정을 분리하면 더욱 완성도가 높은 결과물을 얻을 수 있음

```python
from langchain_community.tools.tavily_search import TavilySearchResults
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain_community.vectorstores import FAISS
from langchain_openai import OpenAIEmbeddings
from langchain.document_loaders import PyMuPDFLoader
from langchain.tools.retriever import create_retriever_tool
from langchain_core.prompts import PromptTemplate
from langchain_community.utilities.dalle_image_generator import DallEAPIWrapper
from langchain.tools import tool
from langchain_community.agent_toolkits import FileManagementToolkit
import os
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables.history import RunnableWithMessageHistory
from langchain.agents import create_tool_calling_agent, AgentExecutor
from langchain_community.chat_message_histories import ChatMessageHistory
from langchain_openai import ChatOpenAI
from langchain_teddynote.messages import AgentStreamParser


# 웹 기반 검색 도구 정의
def get_web_search_tool():
    return TavilySearchResults(k=3)


# PDF 기반 검색도구 정의
def get_pdf_search_tool(pdf_path: str):
    loader = PyMuPDFLoader(pdf_path)
    text_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=100)
    split_docs = loader.load_and_split(text_splitter)
    vector = FAISS.from_documents(split_docs, OpenAIEmbeddings())
    retriever = vector.as_retriever()
    document_prompt = PromptTemplate.from_template(
        "<document><content>{page_content}</content><page>{page}</page><filename>{source}</filename></document>"
    )

    retriever_tool = create_retriever_tool(
        retriever,
        name="pdf_search",
        description="use this tool to search for information in the PDF file",
        document_prompt=document_prompt,
    )

    return retriever_tool


# 이미지 생성 도구 정의
@tool
def dalle_tool(query):
    """use this tool to generate image from text"""
    dalle = DallEAPIWrapper(model="dall-e-3", size="1024x1024", quality="standard", n=1)
    return dalle.run(query)


@tool
def write_file_tool(file_path: str, content: str) -> str:
    """파일에 내용을 작성합니다. file_path는 파일 경로이고, content는 저장할 내용입니다."""
    try:
        # tmp 디렉토리가 없으면 생성
        os.makedirs("tmp", exist_ok=True)

        # tmp 디렉토리 내의 파일 경로로 변경
        if not file_path.startswith("tmp/"):
            file_path = f"tmp/{file_path}"

        with open(file_path, "w", encoding="utf-8") as f:
            f.write(content)
        return f"파일 '{file_path}'에 성공적으로 내용을 저장했습니다."
    except Exception as e:
        return f"파일 저장 중 오류가 발생했습니다: {str(e)}"


@tool
def read_file_tool(file_path: str) -> str:
    """파일의 내용을 읽습니다."""
    try:
        # tmp 디렉토리 내의 파일 경로로 변경
        if not file_path.startswith("tmp/"):
            file_path = f"tmp/{file_path}"

        with open(file_path, "r", encoding="utf-8") as f:
            content = f.read()
        return content
    except Exception as e:
        return f"파일 읽기 중 오류가 발생했습니다: {str(e)}"


@tool
def list_directory_tool(directory_path: str = "tmp") -> str:
    """디렉토리의 파일 목록을 조회합니다."""
    try:
        if not os.path.exists(directory_path):
            return f"디렉토리 '{directory_path}'가 존재하지 않습니다."

        files = os.listdir(directory_path)
        if not files:
            return f"디렉토리 '{directory_path}'가 비어있습니다."

        return f"디렉토리 '{directory_path}' 내용:\n" + "\n".join(files)
    except Exception as e:
        return f"디렉토리 조회 중 오류가 발생했습니다: {str(e)}"


def get_file_management_tool():
    return [write_file_tool, read_file_tool, list_directory_tool]


tools = get_file_management_tool() + [
    get_pdf_search_tool(
        "/Users/imkdw/study/RAG 비법노트/22. RAGAS로 답변 평가하기/SPRI_AI_Brief_2023년12월호_F.pdf"
    ),
    get_web_search_tool(),
    dalle_tool,
]


# session_id 를 저장할 딕셔너리 생성
store = {}

# 프롬프트 생성
# 프롬프트는 에이전트에게 모델이 수행할 작업을 설명하는 텍스트를 제공합니다. (도구의 이름과 역할을 입력)
prompt = ChatPromptTemplate.from_messages(
    [
        (
            "system",
            "You are a helpful assistant. "
            "You are a professional researcher. "
            "You can use the pdf_search tool to search for information in the PDF file. "
            "You can find further information by using tavily_search_results_json tool. "
            "You can use dalle_tool to generate image from text. "
            "Finally, you can use write_file_tool to save your research result into files, read_file_tool to read files, and list_directory_tool to list directory contents.",
        ),
        ("placeholder", "{chat_history}"),
        ("human", "{input}"),
        ("placeholder", "{agent_scratchpad}"),
    ]
)


llm = ChatOpenAI(model="gpt-4o-mini")

agent = create_tool_calling_agent(llm, tools, prompt)

agent_executor = AgentExecutor(
    agent=agent,
    tools=tools,
    verbose=False,
    handle_parsing_errors=True,
)


def get_session_history(session_ids):
    if session_ids not in store:
        store[session_ids] = ChatMessageHistory()
    return store[session_ids]


agent_with_chat_history = RunnableWithMessageHistory(
    agent_executor,
    get_session_history,
    input_messages_key="input",
    history_messages_key="chat_history",
)

agent_stream_parser = AgentStreamParser()

session_id = "dongwoo"

result = agent_with_chat_history.stream(
    {
        "input": "삼성전자가 개발한 `생성형 AI` 와 관련된 유용한 정보들을 PDF 문서에서 찾아서 bullet point로 정리해 주세요. "
        "한글로 작성해주세요."
        "다음으로는 `report.md` 파일을 새롭게 생성하여 정리한 내용을 저장해주세요. \n\n"
        "#작성방법: \n"
        "1. markdown header 2 크기로 적절한 제목을 작성하세요. \n"
        "2. 발췌한 PDF 문서의 페이지 번호, 파일명을 기입하세요(예시: page 10, filename.pdf). \n"
        "3. 정리된 bullet point를 작성하세요. \n"
        "4. 작성이 완료되면 파일을 `report.md` 에 저장하세요. \n"
        "5. 마지막으로 저장한 `report.md` 파일을 읽어서 출력해 주세요. \n"
    },
    config={"configurable": {"session_id": session_id}},
)

for step in result:
    agent_stream_parser.process_agent_steps(step)

result = agent_with_chat_history.stream(
    {
        "input": "이번에는 삼성전자가 개발한 `생성형 AI` 와 관련된 정보들을 웹 검색하고, 검색한 결과를 정리해 주세요. "
        "한글로 작성해주세요."
        "다음으로는 `report.md` 파일을 열어서 기존의 내용을 읽고, 웹 검색하여 찾은 정보를 이전에 작성한 형식에 맞춰 뒷 부분에 추가해 주세요. \n\n"
        "#작성방법: \n"
        "1. markdown header 2 크기로 적절한 제목을 작성하세요. \n"
        "2. 정보의 출처(url)를 기입하세요(예시: 출처: 네이버 지식백과). \n"
        "3. 정리된 웹검색 내용을 작성하세요. \n"
        "4. 작성이 완료되면 파일을 `report.md` 에 저장하세요. \n"
        "5. 마지막으로 저장한 `report.md` 파일을 읽어서 출력해 주세요. \n"
    },
    config={"configurable": {"session_id": session_id}},
)

for step in result:
    agent_stream_parser.process_agent_steps(step)

result = agent_with_chat_history.stream(
    {
        "input": "`report.md` 파일을 열어서 안의 내용을 출력하세요. "
        "출력된 내용을 바탕으로, 전문적인 수준의 보고서를 작성하세요. "
        "보고서는 총 3개의 섹션으로 구성되어야 합니다:\n"
        "1. 개요: 보고서 abstract 를 300자 내외로 작성하세요.\n"
        "2. 핵심내용: 보고서의 핵심 내용을 작성하세요. 정리된 표를 markdown 형식으로 작성하여 추가하세요. "
        "3. 최종결론: 보고서의 최종 결론을 작성하세요. 출처(파일명, url 등)을 표시하세요."
        "마지막으로 작성된 결과물을 `report-2.md` 파일에 저장하세요."
    },
    config={"configurable": {"session_id": session_id}},
)

for step in result:
    agent_stream_parser.process_agent_steps(step)

result = agent_with_chat_history.stream(
    {
        "input": "`report-2.md` 파일을 열어서 안의 내용을 출력하세요. "
        "출력된 내용에 어울리는 이미지를 생성하세요. "
        "생성한 이미지의 url 을 markdown 형식으로 보고서의 가장 상단에 추가하세요. "
        "마지막으로 작성된 결과물을 `report-3.md` 파일에 저장하세요."
    },
    config={"configurable": {"session_id": session_id}},
)

for step in result:
    agent_stream_parser.process_agent_steps(step)
```

<br>

# 완성본
![Generative AI Model](https://oaidalleapiprodscus.blob.core.windows.net/private/org-ZQxG3SGNWyLoXFM5b7W98N9Y/user-Pq3EUX1BjeDrBqHfUaoViAx6/img-0KeQP3LgKMcjSgwRtoS32Ldj.png?st=2025-08-17T05%3A44%3A41Z&se=2025-08-17T07%3A44%3A41Z&sp=r&sv=2024-08-04&sr=b&rscd=inline&rsct=image/png&skoid=b1a0ae1f-618f-4548-84fd-8b16cacd5485&sktid=a48cca56-e6da-484e-a814-9c849652bcb3&skt=2025-08-16T19%3A55%3A14Z&ske=2025-08-17T19%3A55%3A14Z&sks=b&skv=2024-08-04&sig=J5sSoT0HU1GuUWmF%2BFhJ6/9zYKvc1AH374ZSbeMaTDs%3D)

# 삼성전자 생성형 AI ‘삼성 가우스’ 보고서

## 1. 개요

이 보고서는 삼성전자가 개발한 생성형 AI 모델인 ‘삼성 가우스’에 대한 정보를 제공한다. 삼성 가우스는 언어, 코드, 이미지 모델을 포함하며, 온디바이스에서 작동하는 특징이 있어 보안을 강화하고 있다. 이 기술은 개인의 일상은 물론 기업의 업무 효율성을 높이는 데 기여하고 있으며, 2023년 11월 8일 최초 공개되었다.

## 2. 핵심내용

| 항목        | 설명                                                                       |
| ----------- | -------------------------------------------------------------------------- |
| 모델명      | 삼성 가우스 (Samsung Gauss)                                                |
| 구성 요소   | 언어 모델, 코드 모델, 이미지 모델                                          |
| 보안 특성   | 온디바이스 작동으로 사용자 정보 유출 위험 감소                             |
| 공개일      | 2023년 11월 8일, 삼성 AI 포럼 2023                                         |
| 데이터 활용 | 안전한 데이터 사용, 라이선스 및 개인정보 침해 없는 데이터 학습             |
| 기능        | 메일 작성, 문서 요약, 번역 지원, 이미지 생성 및 변환, 고해상도로 전환 가능 |
| 버전        | 삼성 가우스2 (멀티모달 모델로 성능 향상)                                   |
| 출시 예정   | 2024년 1월 17일, 갤럭시 S24 시리즈와 함께 공개 예정                        |

## 3. 최종결론

삼성전자의 생성형 AI 모델인 삼성 가우스는 개인과 기업 모두에서 폭넓은 활용 가능성을 지니고 있으며, 온디바이스 AI의 발전으로 사용자 정보 보호와 업무 효율성 향상에 기여할 것으로 기대된다. 특히, 다양한 제품군에 적용될 수 있어, 향후 삼성의 경쟁력을 높이는 중요한 요소가 될 것이다.

### 출처  
- 파일명: SPRI_AI_Brief_2023년12월호_F.pdf  
- [삼성 뉴스룸](https://news.samsung.com/kr/%EC%82%BC%EC%84%B1%EC%A0%84%EC%9E%90-ai-%EB%A6%AC%EB%8D%94%EC%8B%AD-%E2%91%A2-%EC%82%AC%EC%9A%A9%EC%9E%90-%EA%B2%BD%ED%97%98%EC%9D%84-%EC%B5%9C%EC%9A%B0%EC%84%A0%EC%9C%BC%EB%A1%9C-%ED%95%98%EB%8A%94)  
- [나무위키](https://namu.wiki/w/Galaxy%20AI)  
- [ZDNet](https://zdnet.co.kr/view/?no=20241121083205)  
- [삼성 반도체 블로그](https://semiconductor.samsung.com/kr/news-events/tech-blog/samsungs-pivotal-role-in-pioneering-on-device-generative-ai/)  
- [조선일보](https://biz.chosun.com/it-science/ict/2025/05/09/2J5R6DKYLBEGNFZ2QSGHUPGPR4/)  
