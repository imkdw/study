# LangChain에서 제공하는 도구
- LangChain의 Agent는 LLM이 주어진 과제에 따라 스스로 적절한 도구를 선택하고 순차적으로 실행해서 문제를 해결하는 구성 방식임
- 다양한 외부 기능을 자동으로 조합해 수행이 가능함
- 도구는 에이전트나 체인 혹은 LLM이 외부 세계와 상호작용할 수 있도록 해 주는 함수 기반 인터페이스임
- 여러 유용한 사전 정의 도구를 제공하고 피룡에 따라 원하는 기능을 직접 구현한 사용자 정의 도구도 쉽게 통합이 가능함

<br>

# 파이썬 REPL 도구
- Read-Eval-Print-Loop의 약자로 LLM이 생성한 코드 문자열을 곧바로 실행하고 결과까지 받아볼 수 있음
- 코드를 바로 실행하고 그 결과를 즉시 받아볼 수 있는 점에서 에이전트에게 매우 강력한 도구임

<br>

### 기본적인 도구 활용법
```python
from langchain_experimental.tools import PythonREPLTool

python_tool = PythonREPLTool()

# 300
print(python_tool.invoke("print(100 + 200)"))
```

<br>

### LLM으로 파이썬 코드를 작성하는 프롬프트 작성
```python
from langchain_experimental.tools import PythonREPLTool

python_tool = PythonREPLTool()

from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser
from langchain_core.runnables import RunnableLambda


def print_and_execute(code, debug=False):
    if debug:
        print("CODE:")
        print(code)
    return python_tool.invoke(code)


prompt = ChatPromptTemplate.from_messages(
    [
        (
            "system",
            "You are Raymond Hetting, an expert python programmer, well versed in meta-programming and elegant, concise and short but well documented code. You follow the PEP8 style guide. "
            "Return only the code, no intro, no explanation, no chatty, no markdown, no code block, no nothing. Just the code.",
        ),
        ("human", "{input}"),
    ]
)

llm = ChatOpenAI(model="gpt-4o", temperature=0)

chain = prompt | llm | StrOutputParser() | RunnableLambda(print_and_execute)

# [9, 10, 13, 15, 19, 22]
print(chain.invoke("로또 번호 생성기를 출력하는 코드를 작성하세요."))
```

<br>

# 검색 API 도구
- LLM이 내부 지식에만 의존하지 않고 최신 정보나 외부 데이터를 웹 검색을 통해 직접 가져올 수 있음
- 에이전트는 훨씬 더 유연하고 정확한 응답 생성이 가능하고 빠르게 변하는 데이터에도 효과적으로 대응이 가능함
```python
from langchain_community.tools.tavily_search import TavilySearchResults

tool = TavilySearchResults(
    # 최대 반환할 검색 결과의 개수
    max_results=2,
    # 원본 쿼리에 대한 짧은 답변 포함여부
    include_answer=True,
    # 각 사이트에 정제된 HTML 콘텐츠 포함여부
    include_raw_content=True,
    # 검색결과에 포함할 도메인 목록
    include_domains=["github.io", "wikidocs.net"],
)

print(tool.invoke({"query": "LangChain Tools 에 대해서 알려주세요"}))
```

<br>

# DALL-E 이미지 생성 도구
- LangChain에서는 DALL-E를 도구로 연동해서 에이전트가 자연어 설명을 바탕으로 이미지 자동생성이 가능함
- 이는 시각적 자료가 필요한 응답이나 창의적 콘텐츠 생성에 효과적으로 사용이 가능함

```python
from langchain_core.output_parsers import StrOutputParser
from langchain_core.prompts import PromptTemplate
from langchain_openai import ChatOpenAI
from langchain_community.utilities.dalle_image_generator import DallEAPIWrapper
from IPython.display import Image
import os
import requests
from datetime import datetime

llm = ChatOpenAI(model="gpt-4o-mini", temperature=0.9, max_tokens=1000)

prompt = PromptTemplate.from_template(
    "Generate a detailed IMAGE GENERATION prompt for DALL-E based on the following description. "
    "Return only the prompt, no intro, no explanation, no chatty, no markdown, no code block, no nothing. Just the prompt"
    "Output should be less than 1000 characters. Write in English only."
    "Image Description: \n{image_desc}",
)

chain = prompt | llm | StrOutputParser()

image_prompt = chain.invoke(
    {"image_desc": "스마트폰을 바라보는 사람들을 풍자한 neo-classicism painting"}
)

# A neo-classical painting depicting a group of people intently gazing at their smartphones, set in an elegant, classical environment reminiscent of ancient Greece or Rome. The figures are dressed in flowing togas and classical attire, embodying the style of renowned neo-classical artists. The setting features grand marble columns, intricate sculptures, and lush greenery, blending the old-world charm with modern technology. Each individual displays a range of emotions, from curiosity to distraction, while their smartphones glow in contrast to the muted colors of their surroundings. The composition should capture the irony of timeless human connection, now disrupted by modern distractions, with soft, natural lighting illuminating the scene.
print(image_prompt)

dalle = DallEAPIWrapper(
    # DALL-E 모델 버전
    model="dall-e-3",
    # 이미지 사이즈
    size="1024x1024",
    # 이미지 품질
    quality="standard",
    # 이미지 개수
    n=1,
)

query = "스마트폰을 바라보는 사람들을 풍자한 neo-classicism painting"

image_url = dalle.run(chain.invoke({"image_desc": query}))


def download_image(url, filename=None):
    try:
        response = requests.get(url)
        response.raise_for_status()

        if filename is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"dalle_image_{timestamp}.png"

        os.makedirs("images", exist_ok=True)

        file_path = os.path.join("images", filename)

        with open(file_path, "wb") as f:
            f.write(response.content)

        return file_path

    except requests.exceptions.RequestException as e:
        return None
    except Exception as e:
        return None


download_image(image_url)
```

![](2025-08-16-21-57-09.png)