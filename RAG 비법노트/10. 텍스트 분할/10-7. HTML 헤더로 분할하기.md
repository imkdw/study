# HTML 헤더로 분할하기
- `HTMLHeaderTextSplitter`는 `MarkdownHeaderTextSplitter`랑 개념적으로 유사함
- 마크다운은 # 을 기준으로 나누지만 HTML은 `<h1>` 등 태그를 기준으로 나눔

<br>

# 분할 예제

```python
from langchain_text_splitters import HTMLHeaderTextSplitter

html_string = """
<!DOCTYPE html>
<html>
<body>
    <div>
        <h1>헤더1</h1>
        <p>헤더1 에 포함된 본문</p>
        <div>
            <h2>헤더2-1 제목</h2>
            <p>헤더2-1 에 포함된 본문</p>
            <h3>헤더3-1 제목</h3>
            <p>헤더3-1 에 포함된 본문</p>
            <h3>헤더3-2 제목</h3>
            <p>헤더3-2 에 포함된 본문</p>
        </div>
        <div>
            <h2>헤더2-2 제목2</h2>
            <p>헤더2-2 에 포함된 본문</p>
        </div>
        <br>
        <p>마지막 내용</p>
    </div>
</body>
</html>
"""

# 분할할 태그를 지정
headers_to_split_on = [
    ("h1", "Header 1"),
    ("h2", "Header 2"),
    ("h3", "Header 3"),
]

html_splitter = HTMLHeaderTextSplitter(headers_to_split_on=headers_to_split_on)

html_header_splits = html_splitter.split_text(html_string)

"""
헤더1
{'Header 1': '헤더1'}
=====================
헤더1 에 포함된 본문
{'Header 1': '헤더1'}
=====================
헤더2-1 제목
{'Header 1': '헤더1', 'Header 2': '헤더2-1 제목'}
=====================
헤더2-1 에 포함된 본문
{'Header 1': '헤더1', 'Header 2': '헤더2-1 제목'}
=====================
헤더3-1 제목
{'Header 1': '헤더1', 'Header 2': '헤더2-1 제목', 'Header 3': '헤더3-1 제목'}
=====================
헤더3-1 에 포함된 본문
{'Header 1': '헤더1', 'Header 2': '헤더2-1 제목', 'Header 3': '헤더3-1 제목'}
=====================
헤더3-2 제목
{'Header 1': '헤더1', 'Header 2': '헤더2-1 제목', 'Header 3': '헤더3-2 제목'}
=====================
헤더3-2 에 포함된 본문
{'Header 1': '헤더1', 'Header 2': '헤더2-1 제목', 'Header 3': '헤더3-2 제목'}
=====================
헤더2-2 제목2
{'Header 1': '헤더1', 'Header 2': '헤더2-2 제목2'}
=====================
헤더2-2 에 포함된 본문  
마지막 내용
{'Header 1': '헤더1'}
=====================
"""
for header in html_header_splits:
    print(f"{header.page_content}")
    print(f"{header.metadata}", end="\n=====================\n")
```

<br>

# 별도의 분할기로 2차 분할 수행하기
- `HTMLTextSplitter`로 분할된 텍스트가 여전히 크다면 `RecursiveCharacterTextSplitter`로 2차 분할 수행이 가능함
- `HTMLTextSplitter`에서 생성된 메타데이터는 유지되고 청크가 길이 기준으로 나뉘어도 원래 문서의 구조를 잃지않음

```python
from langchain_text_splitters import (
    HTMLHeaderTextSplitter,
    RecursiveCharacterTextSplitter,
)

html_string = """
<!DOCTYPE html>
<html>
<body>
    <div>
        <h1>헤더1</h1>
        <p>헤더1 에 포함된 본문</p>
        <div>
            <h2>헤더2-1 제목</h2>
            <p>헤더2-1 에 포함된 본문</p>
            <h3>헤더3-1 제목</h3>
            <p>헤더3-1 에 포함된 본문</p>
            <h3>헤더3-2 제목</h3>
            <p>헤더3-2 에 포함된 본문</p>
        </div>
        <div>
            <h2>헤더2-2 제목2</h2>
            <p>헤더2-2 에 포함된 본문</p>
        </div>
        <br>
        <p>마지막 내용</p>
    </div>
</body>
</html>
"""


# 분할할 텍스트의 URL 지정
url = "https://plato.stanford.edu/entries/goedel/"

headers_to_split_on = [
    ("h1", "Header 1"),
    ("h2", "Header 2"),
    ("h3", "Header 3"),
    ("h4", "Header 4"),
]

html_splitter = HTMLHeaderTextSplitter(headers_to_split_on=headers_to_split_on)

html_header_splits = html_splitter.split_text_from_url(url)

# 텍스트를 분할할 청크의 크기 지정
chunk_size = 500

# 분할된 청크 간의 중복되는 문자 수 지정
chunk_overlap = 30

text_splitter = RecursiveCharacterTextSplitter(
    chunk_size=chunk_size, chunk_overlap=chunk_overlap
)

# HTML 헤더로 분할된 텍스트를 다시 청크 크기에 맞게 분할
splits = text_splitter.split_documents(html_header_splits)

"""
By Theorem 2 there is a sentence φ with the property  
y  
x  
x  
y  
[ ]  
12  
⊢ (φ ↔
¬Prov( )).  
P  
⌈  
φ  
⌉  
Thus φ says ‘I am not provable.’ We now observe, if ⊢ φ, then by (1) there is such that ⊢ Prf( , ), hence ⊢ Prov( ), hence,
by (3) ⊢ ¬φ, so is inconsistent.
Thus  
"""
for header in splits[80:85]:
    print(f"{header.page_content}")
    print(f"{header.metadata}", end="\n=====================\n")
```