## 멀티패러다임 언어와 메타프로그래밍 - LISP로 부터
- 메타프로그래밍은 프로그램이 자기 자신이나 다른 프로그램을 데이터처럼 바라보면서 분석, 번형, 생성하거나 실행하는 프로그래밍 기법을 뜻함
- 코드를 데이터로 다루면서 동적으로 조작하고 확장하는 이런 방식은 전통적인 LISP 계열 언어에서 극대화됨
- 이를 활용해서 코드 구조나 평가 과정을 직접 재정의하거나 매크로를 통한 언어 구문을 자유롭게 다룰 수 있음
- 타스나 현대 멀티패러다임 언어들은 LISP 계얼 언어만큼 메타프로그래밍을 직접 지원하진 않지만 여러 언어적 기능을 전략적으로 결합하면 이점을 실용적으로 구현이 가능함

<br>

## Pipe Operator
- 오른쪽 아래 -> 왼쪽 위 방향으로 읽는 코드는 익숙하지 않아서 가독성이 떨어질 수 있음
- LISP는 지연 평가와 메타프로그래밍 측면에서 탁월한 강점이 있어 개발자가 직접 pipe 함수를 만들어 이런 문제를 해결할 수 있음

```ts
function* naturals(end = Infinity): IterableIterator<number> {}
function forEach<A>(f: (a: A) => void, iterable: Iterable<A>): void {}
function* map<A, B>(f: (a: A) => B, iterable: Iterable<A>): IterableIterator<B> {}
function* filter<A>(f: (a: A) => boolean, iterable: Iterable<A>): IterableIterator<A> {}

forEach(
  console.log,
  map(
    (x) => x * 10,
    filter((n) => n % 2 === 1, naturals(5))
  )
);

// Pipe Operator, TS에서 직접 지원하진 않음
naturals(5)
 |> filter((n) => n % 2 === 1)
 |> map((x) => x * 10)
 |> forEach(console.log);
```

<br>

### 그동안 설계했던 고차 함수들의 인자가 `func(f, iterable)`인 이유
- 정통 함수형 언어들의 고차 함수 인자 순서를 따랏기 때문임
- 위 방식의 경우 함수들을 중첩해서 표현하거나, Pipe Operator로 표현하거나 커링 지원시에 가독성이 높아짐
- 만약 `func(iterable, f)` 순서라면 아래같은 코드가 발생함
- 파이프라이닝 자체는 괜찮은 편이지만 불필요한 `%`가 매번 들어가게됨

```ts
naturals(5)
  |> filter(%, n => n % 2 === 1)
  |> map(%, x => x * 10)
  |> forEach(%, console.log);
```

<br>

## 클래스와 고차 함수, 반복자, 타입 시스템을 조합하기
### 제네릭 클래스로 iterable 확장하기
```ts
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}
}
```

<br>

### map 메서드 구현하기
```ts
function* map<A, B>(f: (a: A) => B, iterable: Iterable<A>): IterableIterator<B> {}

class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}

  map<B>(f: (a: A) => B): FxIterable<B> {
    return new FxIterable(map(f, this.iterable));
  }
}

const mapped = new FxIterable(["a", "b"]).map((a) => a.toUpperCase()).map((b) => b + b);
```

<br>

### 헬퍼 함수로 간결하게 표현
```ts
function* map<A, B>(f: (a: A) => B, iterable: Iterable<A>): IterableIterator<B> {}

class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}

  map<B>(f: (a: A) => B): FxIterable<B> {
    return new FxIterable(map(f, this.iterable));
  }
}

function fx<A>(iterable: Iterable<A>): FxIterable<A> {
  return new FxIterable(iterable);
}

const mapped = fx(["a", "b"])
  .map((a) => a.toUpperCase())
  .map((b) => b + b);
```

<br>

### filter, forEach 만들기
- 체이닝 방식은 연속적인 메서드 호출을 통해서 데이터 변환 방식을 직관적으로 표현할 수 있음
- 각 단계가 명확하게 드러나서 코드의 흐름을 쉽게 파악이 가능함
- 또한 Array 메서드 체이닝이나 자바의 스트림 API 처럼 이미 친숙한 패턴이라 쉽게 이해하고 활용이 가능함

```ts
function* naturals(end = Infinity): IterableIterator<number> {
  let n = 1;
  while (n <= end) {
    yield n++;
  }
}

function* map<A, B>(f: (a: A) => B, iterable: Iterable<A>): IterableIterator<B> {
  for (const a of iterable) {
    yield f(a);
  }
}

function forEach<A>(f: (a: A) => void, iterable: Iterable<A>): void {
  for (const a of iterable) {
    f(a);
  }
}

function* filter<A>(f: (a: A) => boolean, iterable: Iterable<A>): IterableIterator<A> {
  for (const a of iterable) {
    if (f(a)) {
      yield a;
    }
  }
}

class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}

  map<B>(f: (a: A) => B): FxIterable<B> {
    return fx(map(f, this.iterable));
  }

  filter(f: (a: A) => boolean): FxIterable<A> {
    return fx(filter(f, this.iterable));
  }

  forEach(f: (a: A) => void): void {
    return forEach(f, this.iterable);
  }
}

function fx<A>(iterable: Iterable<A>): FxIterable<A> {
  return new FxIterable(iterable);
}

// AA, BB
const mapped = fx(["a", "b"])
  .map((a) => a.toUpperCase())
  .map((b) => b + b)
  .forEach(console.log);

// 10, 30, 50
fx(naturals(5))
  .filter((n) => n % 2 === 1)
  .map((n) => n * 10)
  .forEach(console.log);
```

<br>

### reduce 메서드 만들기
- 초기값이 있거나 없는 2가지 경우의 수를 모두 지원해야 하므로 메서드 오버로딩이 필요함

```ts
function* naturals(end = Infinity): IterableIterator<number> {
  let n = 1;
  while (n <= end) {
    yield n++;
  }
}

function* map<A, B>(f: (a: A) => B, iterable: Iterable<A>): IterableIterator<B> {
  for (const a of iterable) {
    yield f(a);
  }
}

function forEach<A>(f: (a: A) => void, iterable: Iterable<A>): void {
  for (const a of iterable) {
    f(a);
  }
}

function* filter<A>(f: (a: A) => boolean, iterable: Iterable<A>): IterableIterator<A> {
  for (const a of iterable) {
    if (f(a)) {
      yield a;
    }
  }
}

function baseReduce<A, Acc>(f: (acc: Acc, a: A) => Acc, acc: Acc, iterator: Iterator<A>): Acc {
  while (true) {
    const { done, value } = iterator.next();
    if (done) {
      break;
    }
    acc = f(acc, value);
  }

  return acc;
}

function reduce<A, Acc>(f: (acc: Acc, a: A) => Acc, acc: Acc, iterable: Iterable<A>): Acc;
function reduce<A, Acc>(f: (a: A, b: A) => Acc, iterable: Iterable<A>): Acc;
function reduce<A, Acc>(f: (a: Acc | A, b: A) => Acc, accOrIterable: Acc | Iterable<A>, iterable?: Iterable<A>): Acc {
  if (!iterable) {
    const iterator = (accOrIterable as Iterable<A>)[Symbol.iterator]();
    const { done, value: acc } = iterator.next();
    if (done) {
      throw new TypeError("'reduce' of empty iterable with no initial value");
    }

    return baseReduce(f, acc, iterator) as Acc;
  } else {
    return baseReduce(f, accOrIterable as Acc, iterable[Symbol.iterator]()) as Acc;
  }
}

class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}

  map<B>(f: (a: A) => B): FxIterable<B> {
    return fx(map(f, this.iterable));
  }

  filter(f: (a: A) => boolean): FxIterable<A> {
    return fx(filter(f, this.iterable));
  }

  forEach(f: (a: A) => void): void {
    return forEach(f, this.iterable);
  }

  reduce<Acc>(f: (acc: Acc, a: A) => Acc, acc: Acc): Acc;
  reduce<Acc>(f: (a: A, b: A) => Acc): Acc;
  reduce<Acc>(f: (a: Acc | A, b: A) => Acc, acc?: Acc): Acc {
    return !acc ? reduce(f, this.iterable) : reduce(f, acc, this.iterable);
  }
}

function fx<A>(iterable: Iterable<A>): FxIterable<A> {
  return new FxIterable(iterable);
}

// 초기값 없는 경우, 90
const num = fx(naturals(5))
  .filter((n) => n % 2 === 1)
  .map((n) => n * 10)
  .reduce((acc, n) => acc + n);
console.log(num);

// 초기값 있는 경우, 90
const num2 = fx(naturals(5))
  .filter((n) => n % 2 === 1)
  .map((n) => n * 10)
  .reduce((acc, n) => acc + n, 0);
console.log(num2);
```

<br>

## LISP에서 배우기 - 코드가 데이터, 데이터가 코드
- LISP는 독특한 문법과 철학을 바탕으로 프로그래밍 언어 역사에서 매우 중요한 위치를 차지하고 있음
- 가장 큰 특징은 코드 -> 데이터, 데이터 -> 코드라는 개념임
- 이를 통해서 프로그래밍 언어의 구문을 데이터 구조로 표현하고 조작이 가능해짐

<br>

### 클로저
- 2007년에 개발된 함수형 프로그래밍 언어로 LISP 계열에 속함
- 불변성과 일급 함수를 강조하고 동시성 프로그래밍과 관련된 강력한 기능을 지원하는 언어임

<br>

### 클로저 시작하기 - `S-표현식`
- `S-표현식`은 리스트 형태의 구문 표현을 의미하며 이를 통해서 코드와 데이터를 동일한 구조로 다룰 수 있음
- 코드 자체를 데이터로 조작할 수 있다는 뜻인데 `(+ 1 2 )`는 LISP에서 `1 + 2`를 의미하는 동시에 리스트 형태의 데이터임
- 함수 호출이 리스트 구조로 이루어지고 리스트의 첫 번째 요소가 함수, 나머지가 함수에 전달할 인자임

```clojure
(+ 1 2) -> 3
```

<br>

#### 타입스크립트로 리스트를 평가하는 함수 만들기
```ts
type Evaluatable<A, B> = [(...args: A[]) => B, ...A[]];

function evaluation<A, B>(expr: Evaluatable<A, B>) {
  const [fn, ...args] = expr;
  return fn(...args);
}

const add = (a: number, b: number) => a + b;
const result = evaluation([add, 1, 2]);
console.log(result); // 3
```

<br>

## 클로저에서 map이 실행될 때
- 함수는 `map`이라는 함수가 실행되며 익명 함수로 `#(+ % 10)`이 실행됨
- 마지막으로 `백터 [1 2 3 4]`가 전달되는데 클로저에선 `[] = 백터`, `() = 리스트`를 의미함
- `#(+ % 10)`은 리더 매크로에 의해서 `(fn [x] (+ x 10))` 형태의 익명 함수로 확장됨
  - `리더 매크로` : 클로저와 같은 언어가 소스 코드를 읽는 단계에서 특정 기호나 패턴을 미리 정해진 형태의 다른 코드로 치환하는 기능

```clojure
(map #(+ % 10) [1 2 3 4])
;; 11 12 13 14
```

<br>

### 앞에서 2개의 값 꺼내기
- let에서 `[first second]`로 구조를 분해하면 처음 두 요소인 11, 12가 추출됨
- 이처럼 LISP 계열의 언어는 코드가 리스트 형태로 표현되며 평가되기 전까지는 단순한 데이터 구조에 불과함

```clojure
(let [[first second] (map #(+ % 10) [1 2 3 4])] (println first second))
; 11, 12
```

<br>

## 멀티패러다임 언어에서 사용자가 만든 코드이자 클래스를 리스트로 만들기
### toArray()가 추가되며 길이가 4인 배열이 만들어지는 경우
```ts
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}
  // ...

  toArray(): A[] {
    return [...this.iterable];
  }
}

function fx<A>(iterable: Iterable<A>): FxIterable<A> {
  return new FxIterable(iterable);
}

const [first, second] = fx([1, 2, 3, 4])
  .map((a) => a + 10)
  .toArray(); // 해당 시점에서 length: 4인 배열이 만들어짐
console.log(first, second); // 11, 12
```

<br>

### LISP가 추구하는 리스트로 만들기
```ts
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}

  // ...

  [Symbol.iterator]() {
    return this.iterable[Symbol.iterator]();
  }
}

function fx<A>(iterable: Iterable<A>): FxIterable<A> {
  return new FxIterable(iterable);
}

// map에서 10을 더하기 위한 연산이 딱 2번만 발생함
const [first, second] = fx([1, 2, 3, 4]).map((a) => a + 10);

console.log(first, second); // 11, 12
```

<br>

## LISP의 확장성 - 매크로와 메타프로그래밍
- LISP로 생각할 때 아직 평가되지 않은 상태에서 10을 더할 리스트가 있다면 여기에 동적으로 코드 추가가 가능함
- 개발자가 특정 로직으로 요소를 제거하는 함수를 만들고 이를 리스트의 첫 번쨰 요소로 둔다면 그 리스트는 마치 새로운 연산자와 함수로 구성된 코드처럼 동작함
- 이런 과정을 통해서 개발자가 스스로 언어의 기능을 확장하고 let과 같은 기존 언어 기능과 자연스럽게 연계가 가능해짐

<br>

### 기존에 언어에 없던 연산을 클로저에 추가하기
- `reject` 함수는 pred 조건을 만족하지 않는 요소만 남기기 위해서 `filter`, `complement`를 사용함
- `map` 함수는 각 배열에 10을 더해서 11, 12, ... 을 만들게됨
- `reject odd`는 홀수인 요소를 제거해서 12, 14, 16을 반환함
- 이후에 let에 의해서 first, second에 12, 14가 할당되고 최종적으로 12, 14가 출력됨

```clojure
(defn reject [pred coll]
  (filter (complement pred) coll))

(let [[first second] (reject odd? (map #(+ % 10) [1 2 3 4 5 6]))]
  (println first second))

;; 12 14
```

<br>

### 매크로
- 단순한 텍스트 치환이 아닌 코드를 입력받아 코드를 반환하는 하나의 함수라고 할 수 있음
- 매크로는 컴파일 타임에 작동해서 코드가 아직 실행되ㅑ지 않은 구문 상태일 떄 원하는 형태로 재구성함
- 최종적으로 실행될 코드를 유연하게 동적으로 만들어내고 원하는 새로운 문법이나 기능을 언어에 쉽게 추가가 가능함

<br>

#### unless 매크로
- `test`, `body` 2개는 매크로에 전달된느 코드 형태의 인자임
- 함수 호출에서는 인자들이 먼저 평가된 뒤 함수에 전달되지만 매크로에서는 인자들이 평가되지 않고 원본 코드로 주어짐
- 이 뜻은 unless 매크로가 test, body를 마치 함수의 인자처럼 받지만 그 값을 실행하지 않고 코드 구조(리스트) 자체로 취급한다는 의미임

```clojure
(defmacro unless [test body]
  `(if (not ~test) ~body nil))
```

<br>

#### unless 매크로 사용하기
```clojure
(defmacro unless [test body]
  `(if (not ~test) ~body nil))

(unless false
        (println "조건이 거짓이라 이게 실행됨"))

;; 조건이 거짓이라 이게 실행됨
```

<br>

#### 매크로 변환 후 실제로 실행되는 코드
```clojure
(if (not false)
  (println "조건이 거짓이라 이게 실행됨")
  nil)

;; 조건이 거짓이라 이게 실행됨
```

<br>

### ->> 매크로
- 파이프라인 형태의 코드를 위해서 `->> 매크로`가 사용됨

```clojure
(defn reject [pred coll]
  (filter (complement pred) coll))

(let [[first second] (->> [1 2 3 4 5 6]
                          (map #(+ % 10))
                          (reject odd?))]
  (println first second))

;; 12 14
```

<br>

### reject 메서드를 FxIterable에 추가하기
```ts
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}

  // ...

  [Symbol.iterator]() {
    return this.iterable[Symbol.iterator]();
  }

  reject(f: (a: A) => boolean): FxIterable<A> {
    return this.filter((a) => !f(a));
  }
}

function fx<A>(iterable: Iterable<A>): FxIterable<A> {
  return new FxIterable(iterable);
}

const isOdd = (a: number) => a % 2 === 1;

const [first, second] = fx([1, 2, 3, 4, 5, 6])
  .map((a) => a + 10)
  .reject(isOdd);

console.log(first, second); // 12, 14
```

<br>

### 코드, 객체, 함수가 협력하여 구현한 언어의 확장
- 그동안 과정은 구조 분해 할당, 메서드 체이닝 패턴, 이터레이션 프로토콜을 매개로 긴밀하게 협력해서 언어를 확장한듯한 높은 수준의 추상화와 유연성을 확보하는 과정이였음
- 이러한 코드는 특정 도메인이나 문제를 해결하는 구현체가 아닌 어디에서나 사용이 가능한 범용적인 언어의 면모를 보여줌
- 이러한 코드는 `멀티패러다임`으로 구현되었으며 언어가 지원할 모든 기능과 상호작용이 가능한 범용적인 코드임

<br>

## 런타임에서 동적으로 기능 확장하기
### to로 확장하고 객체지향적인 객체와 호흡하기
- `FxIterable`의 경우 이러터블이기 때문에 배열로 변환이 가능함
- 하지만 항상 `toArray()`가 필요한건 아니지만 때론 필요할때도 있음

<br>

### FxIterable을 다른 타입으로 만드는 메서드를 동적으로 확장할 수 있도록하는 to 메서드
- to 메서드를 통해서 어떤 타입으로든 변환하는 기능을 런타임에 동적으로 추가할 수 있으며 타입 추론도 잘 지원함
- 이를 통해서 내장 객체뿐만 아니라 사용자 정의 객체와도 함께 동작이 가능함

```ts
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}

  // ...

  [Symbol.iterator]() {
    return this.iterable[Symbol.iterator]();
  }

  to<R>(converter: (iterable: Iterable<A>) => R): R {
    return converter(this.iterable);
  }
}

function fx<A>(iterable: Iterable<A>): FxIterable<A> {
  return new FxIterable(iterable);
}

const sorted = fx([5, 2, 3, 1, 4, 5, 3])
  .filter((n) => n % 2 === 1)
  .map((n) => n * 10)
  .to((iterable) => [...iterable])
  .sort((a, b) => a - b);

console.log(sorted); // [10, 30, 30, 50, 50]


const set = fx([5, 2, 3, 1, 4, 5, 3])
  .filter((n) => n % 2 === 1)
  .map((n) => n * 10)
  .to((iterable) => new Set(iterable))
  .add(40)
  .add(10);

// Set(4) { 50, 30, 10, 40 } 4
console.log(set, set.size);
```

<br>

### Set의 집합 메서드와 함께 사용하기
- to 메서드를 통해서 Set으로 변환하고 차집합을 구하는 과정임
```ts
const set = fx([5, 2, 3, 1, 4, 5, 3])
  .filter((n) => n % 2 === 1)
  .map((n) => n * 10)
  .to((iterable) => new Set(iterable))
  .difference(new Set([10, 20]));

console.log([...set]); // [50, 30]
```

<br>

### chain으로 확장하기
- to 메서드처럼 다시 이터러블로 변환하는 chain 메서드를 추가할 수 있음

```ts
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}

  // ...

  [Symbol.iterator]() {
    return this.iterable[Symbol.iterator]();
  }

  chain<B>(f: (iterable: Iterable<A>) => Iterable<B>): FxIterable<B> {
    return fx(f(this));
  }
}

function fx<A>(iterable: Iterable<A>): FxIterable<A> {
  return new FxIterable(iterable);
}

const result = fx([5, 2, 3, 1, 4, 5, 3])
  .filter((n) => n % 2 === 1)
  .map((n) => n * 10) // [10, 30, 30, 50, 50]
  .chain((iterable) => new Set(iterable)) // Set(3) { 10, 30, 50 }
  .reduce((acc, n) => acc + n); // 90

console.log(result); // 90
```