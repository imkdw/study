## 함수형 고차 함수와 타입 시스템
### forEach
- 
```ts
function forEach<A>(func: (a: A) => void, iterable: Iterable<A>): void {
  for (const a of iterable) {
    func(a);
  }
}

const array = [1, 2, 3];
forEach<number>((a) => console.log(a.toFixed(2)), array); // 1.00, 2.00, 3.00
```

<br>

### map 타입
```ts
function* map<A, B>(
  func: (a: A) => B,
  iterable: Iterable<A>
): IterableIterator<B> {
  for (const a of iterable) {
    yield func(a);
  }
}

const array = ["1", "2", "3"];
const mapped = map((a) => parseInt(a, 10), array);
console.log(mapped); // Object [Generator] {}

const array2 = [...mapped]; // number[]
console.log(array2); // [ 1, 2, 3 ]

const [head] = map((a) => a.toUpperCase(), ["a", "b", "c"]);
console.log(head); // A
```

<br>

### filter
```ts
function* filter<T>(
  func: (value: T) => boolean,
  iterable: Iterable<T>
): IterableIterator<T> {
  for (const value of iterable) {
    if (func(value)) {
      yield value;
    }
  }
}

const array = [1, 2, 3, 4];

// (parameter) value: number
const filtered = filter((value) => value % 2 === 0, array);

const array2 = [...filtered]; // number[]
console.log(array2); // [ 2, 4 ]
```

<br>

### reduce
```ts
function reduce<T, Acc>(
  func: (acc: Acc, t: T) => Acc,
  acc: Acc,
  iterable: Iterable<T>
): Acc {
  for (const a of iterable) {
    acc = func(acc, a);
  }

  return acc;
}

const array = [1, 2, 3];
const sum = reduce((acc, a) => acc + a, 0, array);
console.log(sum); // 6

const strings = ["a", "b", "c"];
const abc = reduce((acc, a) => `${acc}${a}`, "", strings);
console.log(abc); // "abc"
```

<br>

### reduce 함수 오버로드
- 자바스크립트의 `Array.prototype.reduce`는 초깃값 생략이 가능함
- 만약 초깃값 생략이 가능한 reduce를 만들기 위해서는 아래 조건이 필요함
  - 초깃값이 있을 때는 세 개의 인자를 받음
  - 생략하고자 할때는 f + iterable 2개를 받고 이터러블의 첫 번째 요소가 초깃값이 됨
  - 초깃값 없이 빈 배열이 전달된 경우는 누적이 불가능하며 타입이 올바르지 않으므로 에러를 반환해야함

```ts
function baseReduce<A, Acc>(
  f: (acc: Acc, a: A) => Acc,
  acc: Acc,
  iterator: Iterator<A>
): Acc {
  while (true) {
    const { done, value } = iterator.next();
    if (done) {
      break;
    }
    acc = f(acc, value);
  }

  return acc;
}

function reduce<A, Acc>(
  f: (acc: Acc, a: A) => Acc,
  acc: Acc,
  iterable: Iterable<A>
): Acc;
function reduce<A, Acc>(f: (a: A, b: A) => Acc, iterable: Iterable<A>): Acc;
function reduce<A, Acc>(
  f: (a: Acc | A, b: A) => Acc,
  accOrIterable: Acc | Iterable<A>,
  iterable?: Iterable<A>
): Acc {
  if (!iterable) {
    const iterator = (accOrIterable as Iterable<A>)[Symbol.iterator]();
    const { done, value: acc } = iterator.next();
    if (done) {
      throw new TypeError("'reduce' of empty iterable with no initial value");
    }

    return baseReduce(f, acc, iterator) as Acc;
  } else {
    return baseReduce(
      f,
      accOrIterable as Acc,
      iterable[Symbol.iterator]()
    ) as Acc;
  }
}

// 초깃값 넣어서 사용하기
const array = [1, 2, 3];
const sum = reduce((acc, a) => acc + a, 0, array);
console.log(sum); // 6

// 초깃값 넣어서 사용하기
const strings = ["a", "b", "c"];
const abc = reduce((acc, a) => `${acc}${a}`, "", strings);
console.log(abc); // "abc"

// 초깃값 생략하고 사용하기
const array2 = [1, 2, 3];
const sum2 = reduce((acc, a) => acc + a, array2);
console.log(sum2); // 6

// 초깃값 생략하고 사용하기
const strings2 = ["hello", "beautiful", "world"];
const abc2 = reduce((acc, a) => `${acc} ${a}`, strings2);
console.log(abc2); // "hello beautiful world"
```

<br>

### reduce의 에러 관리
- 자바스크립트의 reduce는 초기값이 없다면 배열의 첫 요소를 초기값으로 삼아서 순회를 시작함
- 만약 빈 배열이라서 초깃값으로 삼을만한게 없다면 TypeError를 발생시킴
  - `Uncaught TypeError: Reduce of empty array with no initial value`

<br>

#### 1. 초깃값을 명시적으로 넣기
- 빈 배열이여도 사용자가 직접 결정한 초깃값을 반환할 수 있음
- 이 방식은 빈 배열이면 어떤 값을 반환할지를 명확하게 정하고감
- 하지만 모든 상황을 해결할수는 없음. 복잡한 제어문이 들어감

<br>

#### 2. 빈 배열인 경우를 미리 체크해 기본값으로 반환하기
- Array, Set 처럼 길이를 미리 알 수 있는 자료구조인 경우 가능한 방법임
- `arr => arr.length > 0 ? '': arr.reduce((a, b) => a + ' ' + b)` 느낌임

<br>

#### 3. try~catch로 에러 처리하기
- 빈 배열이 정상 범위에 속하지 않고 초깃값 역시 사용할 이유가 없는 상황인 경우 처리가 가능함
- 또는 이 경우는 에러가 맞으니 해결이 필요하다는 명확한 의도 아래 에러를 그대로 전파시킬수도 있음

<br>

#### 4. 지연 이터레이터인 경우
- 지연 이터레이터를 reduce에 전달하기 전에 배열로 변환해서 길이 체크 or 끝까지 평가를 미루면서 reduce에 넘기고 에러를 처리하는 2개의 접근방식이 있음

<br>

## 함수 시그니처와 중첩된 함수들의 타입 추론
- 타입을 잘 정의한 함수는 함수들을 중첩해서 평가시에도 코드 전반에서 타입 추론을 원활하게 처리해줌
- 고차 함수에 인자로 전달된 모든 함수의 인자 타입이 추론되므로 직접 타입 정의를 안해도 안전한 코드 작성이 가능함

```ts
function* naturals(end = Infinity): IterableIterator<number> {}
function forEach<A>(f: (a: A) => void, iterable: Iterable<A>): void {}
function* map<A, B>(f: (a: A) => B, iterable: Iterable<A>): IterableIterator<B> {}
function* filter<A>(f: (a: A) => boolean, iterable: Iterable<A>): IterableIterator<A> {}

const printNumber = (n: number) => console.log(n);

forEach(
  printNumber,
  map(
    // (parameter) x: number
    (x) => x * 10,
    // (parameter) n: number
    filter((n) => n % 2 === 1, naturals(5))
  )
);

forEach(
  printNumber,
  filter(
    // (parameter) n: number
    (n) => n % 2 === 1,
    map(
      // (parameter) text: string
      (text) => parseInt(text, 10),
      // (parameter) el: HTMLDivElement
      map((el) => el.textContent!, document.querySelectorAll("div"))
    )
  )
);
```