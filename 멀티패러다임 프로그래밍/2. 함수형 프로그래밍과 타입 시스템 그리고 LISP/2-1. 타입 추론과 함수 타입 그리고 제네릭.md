## 타입 추론
- 타입 추론은 코드 작성시 타입을 명시적으로 선언하지 않아도 컴파일러가 자동으로 타입을 추론해주는 기능
- 코드의 간결성을 유지하면서도 타입 안정성 확보가 가능함

<br>

### 타입 추론의 기본 콘셉
- 아래 코드의 경우 명시적으로 타입을 선언하지 않아도 컴파일러가 자동으로 추론함

```ts
// let a: number
let a = 10;
```

<br>

### 변수와 상수의 타입 추론
- let은 변할수 있는 값으로 원시 타입으로 추론
- const는 변할수 없는 값으로 고정 타입으로 추론

```ts
// let message: string
let message = "Hello";

// const selected: true
const selected = true;

// let checked: boolean
let checked = false;
```

<br>

### 함수의 반환 타입 추론
```ts
// function add(a: number, b: number): number
function add1(a: number, b: number) {
  return a + b;
}

// function add(a: string, b: string): string
function add2(a: string, b: string) {
  return a + b;
}

// function add(a: string, b: string): number
function add3(a: string, b: string) {
  return parseInt(a, 10) + parseInt(b, 10);
}

// function add(a: number, b: number): number
// 명시적으로 반환 타입 지정도 가능함
function add4(a: number, b: number): number {
  return a + b;
}

```

<br>

### 객체의 속성 타입 추론
```ts
// let user: {
//   name: string;
//   age: number;
// }
let user = {
  name: "Marty",
  age: 30,
};
```

<br>

### 함수 인자의 타입 추론
```ts
let strings = ["a", "b", "c"];

// (parameter) str: string
strings.forEach((str) => console.log(str.toUpperCase()));
```

<br>

### 제네릭을 통한 타입 추론
- 제네릭 함수를 사용하면 하나의 함수가 다양한 타입을 지원하여 다형성이 높은 함수가 됨
- 아래 `identity` 함수는 표현식에서 전달한 인자 arg의 탕비으로 T의 실제 타입이 정해지며 그게 곧 반환 타입이 됨
```ts
function identity<T>(arg: T): T {
  return arg;
}

// const a: "hi"
const a = identity("hi");

// const b: 1
const b = identity(1);

// const c: string
const c = identity<string>("a");

// const d: number
const d = identity<number>(1);

class User {}
// const e: User
const e = identity(new User());

// const f: (n: number) => boolean
const f = identity((n: number) => n % 2 === 1);
```

<br>

## 함수 타입과 제네릭
- 타스는 함수형 프로그래밍 지원을 위해서 HoC, 합수 타입, 제네릭 등 다양한 기능을 제공함
- 명시적인 지정으로 정확한 타입 표현도 가능하며 제네릭을 활용해서 폭넓은 타입을 지원하는 범용 함수도 만들 수 있음

<br>

### 함수의 타입을 정의하는 여러 가지 방법
```ts
// 기본적인 지정 방법
function add(a: number, b: number): number {
  return a + b;
}

const result: number = add(1, 2);

// 함수 오버로드를 통한 다양한 시그니처 정의
function double(a: number): number;
function double(a: string): string;
function double(a: number | string): number | string {
  if (typeof a === "number") {
    return a * 2;
  } else {
    return a + a;
  }
}

const num: number = double(10); // 20
const str: string = double("Hi"); // 'HiHi'

// 화살표 함수에서 반환 타입 지정하기
const multiply = (a: number, b: number): number => a * b;
const num2: number = multiply(2, 3); // 6

// 함수 타입 별칭 지정하기
type Add = (a: number, b: number) => number;
const add2: Add = (a, b) => a + b;
```

<br>

### constants와 제네릭
- 아래 `constant` 함수는 입력받은 값을 항상 그대로 돌려주는 함수를 반환함
- 특정 값을 캡처해서 호출될 때마다 해당 값을 반환하는 함수임
- 이처럼 함수를 제네릭으로 구현하면 다양한 타입의 값을 처리할 수 있음

```ts
function constant<T>(a: T): () => T {
  return () => a;
}

const getFive = constant(5);
const ten: number = getFive() + getFive();
console.log(ten); // 10

const getHi = constant("Hi");
const hi2: string = getHi() + getHi();
console.log(hi2); // 'HiHi'
```