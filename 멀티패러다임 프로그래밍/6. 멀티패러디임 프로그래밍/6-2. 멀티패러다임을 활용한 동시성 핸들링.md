## 함수를 일정 개수 모아 순차적으로 동시성 부하 제어하기
### 명령형으로 작성
- 총 7개의 작업을 3개씩 나누어서 순차적으로 동시성 부하를 제어함
- 총 실행시간은 약 300ms가 소요됨

```ts
function delay<T>(ms: number, value: T): Promise<T> {
  return new Promise((resolve) => setTimeout(() => resolve(value), ms));
}

async function executionWithLimit<T>(fs: (() => Promise<T>)[], limit: number): Promise<T[]> {
  const results: T[] = [];

  for (let i = 0; i < fs.length; i += limit) {
    const batchPromises = [];
    for (let j = 0; j < limit && i + j < fs.length; j++) {
      const promise = fs[i + j];
      if (promise) {
        batchPromises.push(promise());
      }
    }

    const batchResults = await Promise.all(batchPromises);
    results.push(...batchResults);
  }

  return results;
}

console.time("executionWithLimit");
const fs = [
  () => delay(100, 1),
  () => delay(100, 2),
  () => delay(100, 3),
  () => delay(100, 4),
  () => delay(100, 5),
  () => delay(100, 6),
  () => delay(100, 7),
];

console.log(await executionWithLimit(fs, 3));
console.timeEnd("executionWithLimit");
```

<br>

### 함수형으로 작성
- 명령형과 결과는 똑같지만 훨씬 간단해졌음

```ts
import { fx } from "@fxts/core";

function delay<T>(ms: number, value: T): Promise<T> {
  return new Promise((resolve) => setTimeout(() => resolve(value), ms));
}

async function executionWithLimit<T>(fs: (() => Promise<T>)[], limit: number): Promise<T[]> {
  return fx(fs)
    .toAsync()
    .map((f) => f())
    .concurrent(limit)
    .toArray();
}

console.time("executionWithLimit");
const fs = [
  () => delay(100, 1),
  () => delay(100, 2),
  () => delay(100, 3),
  () => delay(100, 4),
  () => delay(100, 5),
  () => delay(100, 6),
  () => delay(100, 7),
];

console.log(await executionWithLimit(fs, 3));
console.timeEnd("executionWithLimit");
```

<br>

## runTaskWithPool 구현하기
- `runTaskWithPool` 함수는 특정 poolSize 값만큼 동시에 작업을 실행하고 하나의 작업이 완료될때마다 대기 중인 새로운 작업을 실행하는 형태로 동작함

<br>

### GPT가 만들어준 명령형 방식
```ts
async function runTasksWithPool<T>(fs: (() => Promise<T>)[], poolSize: number): Promise<T[]> {
  const results: T[] = new Array(fs.length);
  const executing: Promise<void>[] = [];

  for (let i = 0; i < fs.length; i++) {
    const promise = fs[i]!().then((result) => {
      results[i] = result;
    });

    executing.push(promise);

    if (executing.length >= poolSize) {
      await Promise.race(executing);

      for (let j = executing.length - 1; j >= 0; j--) {
        const isSettled = await Promise.race([executing[j]!.then(() => true), Promise.resolve(false)]);

        if (isSettled) {
          executing.splice(j, 1);
          break;
        }
      }
    }
  }

  await Promise.all(executing);

  return results;
}

function createAsyncTask(name: string, ms: number): () => Promise<string> {
  return () => {
    return new Promise((resolve) => {
      console.log(`Started: ${name}`);
      setTimeout(() => {
        console.log(`Finished: ${name}`);
        resolve(name);
      }, ms);
    });
  };
}

const tasks = [
  createAsyncTask("A", 1000),
  createAsyncTask("B", 500),
  createAsyncTask("C", 800),
  createAsyncTask("D", 300),
  createAsyncTask("E", 1200),
];

const poolSize = 2;
const results = await runTasksWithPool(tasks, poolSize);

// Started: A
// Started: B
// Finished: B
// Started: C
// Finished: A
// Started: D
// Finished: D
// Started: E
// Finished: C
// Finished: E
// Results: A,B,C,D,E
console.log(`Results: ${results}`);
```

<br>

### 멀티패러다임으로 구현한 동시성 핸들링 함수
```ts
function createAsyncTask(name: string, ms: number): () => Promise<string> {
  return () => {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve(name);
      }, ms);
    });
  };
}

class TaskRunner<T> {
  private f: () => Promise<T>;
  private _promise: Promise<T> | null = null;
  private _isDone = false;

  get promise() {
    return this._promise ?? this.run();
  }

  get isDone() {
    return this._isDone;
  }

  constructor(f: () => Promise<T>) {
    this.f = f;
  }

  /**
   * 작업 시작 로직을 명확하게 분리했음
   * 이를 통해서 Promise 생성과 완료 상태 갱신을 일관되게 처리가 가능함
   * 캡슐화를 통해 상태 관리가 직관적으로 이루어짐
   */
  async run() {
    if (this._promise) {
      return this._promise;
    } else {
      return (this._promise = this.f().then((res) => {
        this._isDone = true;
        return res;
      }));
    }
  }
}

async function runTasksWithPool<T>(fs: (() => Promise<T>)[], poolSize: number): Promise<T[]> {
  const tasks = fs.map((f) => new TaskRunner(f));
  console.log(tasks.length); // 5

  let pool: TaskRunner<T>[] = [];
  for (const nextTask of tasks) {
    /**
     * pool 내부에 작업을 poolSize 만큼 추가함
     */
    pool.push(nextTask);

    if (pool.length < poolSize) {
      continue;
    }

    /**
     * 현재 풀에 있는 작업을 시작시키고 하나가 끝날 때까지 대기함
     */
    await Promise.race(pool.map((task) => task.run()));

    /**
     * 완료된 작업은 제거함
     */
    pool.splice(
      pool.findIndex((task) => task.isDone),
      1
    );
  }

  /**
   * 이미 완료된 결과를 수집함
   */
  return Promise.all(tasks.map((task) => task.promise));
}

const tasks = [
  createAsyncTask("A", 1000),
  createAsyncTask("B", 500),
  createAsyncTask("C", 800),
  createAsyncTask("D", 300),
  createAsyncTask("E", 1200),
];

const poolSize = 2;
const results = await runTasksWithPool(tasks, poolSize);
```

<br>

## 동시성 크기를 동적으로 변경할 수 있도록 확장
- 이런 요구사항의 경우 단순히 함수 형태보다는 클래스 기반 구조를 채택하는것이 좋음
- 클래스는 상태와 로직을 한 곳에 모아 관리가 가능해서 동적 동시성 조절이나 자원 재할당을 훨씬 명확하고 직관적으로 구현이 가능함
- 처음에는 간단하게 기능을 함수 형태로 구현해서 문제를 해결한 뒤 기능적 요구사항이나 복잡성이 늘어날 때 점진적으로 클래스를 도입하고 추상화를 높이는 방법이 더 실용적임

```ts
class TaskPool<T> {
  private readonly tasks: TaskRunner<T>[];
  private readonly pool: TaskRunner<T>[] = [];
  poolSize: number;

  constructor(fs: (() => Promise<T>)[], poolSize: number) {
    this.tasks = fs.map((f) => new TaskRunner(f));
    this.poolSize = poolSize;
  }

  /**
   * 외부에서 동시성 카운트 제어가 가능함
   */
  setPoolSize(poolSize: number) {
    this.poolSize = poolSize;
  }

  /**
   * 현재 테스크 풀의 상태를 점검해서 추가 작업 투입이 가능한지 판별함
   * @returns
   */
  private canExpandPool() {
    return this.pool.length < this.poolSize;
  }

  async runAll() {
    const { pool, tasks } = this;

    let i = 0;
    const { length } = tasks;

    while (i < length) {
      /**
       * 다음 작업을 풀에 추가함
       */
      pool.push(tasks[i]!);

      /**
       * 다음 작업이 마지막 작업이 아니고 풀에 추가할 수 있는 경우 다음 작업을 풀에 추가함
       */
      const isNotLast = ++i < length;
      if (isNotLast && this.canExpandPool()) {
        continue;
      }

      /**
       * 현재 풀에 있는 작업을 시작시키고 하나가 끝날 때까지 대기함
       */
      await Promise.race(pool.map((task) => task.run()));

      /**
       * 완료된 작업은 제거함
       */
      pool.splice(
        pool.findIndex((task) => task.isDone),
        1
      );
    }

    return Promise.all(tasks.map((task) => task.promise));
  }
}
```

<br>

## 무한 반복되는 작업의 부하 조절하기
```ts
class TaskPool<T> {
  /**
   * 무한 반복을 지원하기 위해서 Array -> IterableIterator로 변경
   */
  private readonly tasksIterator: IterableIterator<TaskRunner<T>>;
  private readonly pool: TaskRunner<T>[] = [];
  poolSize: number;

  constructor(fs: Iterable<() => Promise<T>>, poolSize: number) {
    /**
     * Iterable를 받고 IterableIterator를 반환하는 map 함수를 통해서 설정함
     */
    this.tasksIterator = map((f) => new TaskRunner(f), fs);
    this.poolSize = poolSize;
  }

  /**
   * 외부에서 동시성 카운트 제어가 가능함
   */
  setPoolSize(poolSize: number) {
    this.poolSize = poolSize;
  }

  /**
   * 현재 테스크 풀의 상태를 점검해서 추가 작업 투입이 가능한지 판별함
   * @returns
   */
  private canExpandPool() {
    return this.pool.length < this.poolSize;
  }

  async runAll() {
    const { pool, tasksIterator } = this;
    const tasks: TaskRunner<T>[] = [];

    while (true) {
      const { done, value: nextTask } = tasksIterator.next();
      if (!done) {
        /**
         * 이터레이터에서 항목을 하나씩 꺼내서 nextTask를 pool, tasks에 추가함
         */
        pool.push(nextTask);
        tasks.push(nextTask);

        if (this.canExpandPool()) {
          continue;
        }

        /**
         * 만약 더 이상 소비할 항목이 없고 풀이 모두 소진되었다면 반복이 끝남
         */
        if (done && pool.length === 0) {
          break;
        }

        await Promise.race(pool.map((task) => task.run()));

        pool.splice(
          pool.findIndex((task) => task.isDone),
          1
        );
      }
    }

    return Promise.all(tasks.map((task) => task.promise));
  }
}

async function crawling(page: number) {
  console.log(`${page} 분석 시작`);
  await delay(page * 100);
  console.log(`${page} 분석 완료`);
  return page;
}

// 0 분석 시작
// 1 분석 시작
// 2 분석 시작
// 3 분석 시작
// 4 분석 시작
// 0 분석 완료
// 5 분석 시작
// 1 분석 완료
// 6 분석 시작
// 2 분석 완료
// 7 분석 시작
// 3 분석 완료
// 8 분석 시작
// 4 분석 완료
// 9 분석 시작
// 5 분석 완료
void new TaskPool(
  map((page) => () => crawling(page), range(Infinity)),
  5
).runAll();
```

<br>

## runAllSettled 추가하기
- Promise.allSettled랑 동일한 역할을 하는 메서드를 구현함
- 이는 모든 작업이 완료될 때까지 기다린 뒤 각 작업의 성공/실패 상태를 배열 형태로 반환함

```ts
class TaskPool<T> {
  /**
   * 무한 반복을 지원하기 위해서 Array -> IterableIterator로 변경
   */
  private readonly tasksIterator: IterableIterator<TaskRunner<T>>;
  private readonly pool: TaskRunner<T>[] = [];
  poolSize: number;

  constructor(fs: Iterable<() => Promise<T>>, poolSize: number) {
    /**
     * Iterable를 받고 IterableIterator를 반환하는 map 함수를 통해서 설정함
     */
    this.tasksIterator = map((f) => new TaskRunner(f), fs);
    this.poolSize = poolSize;
  }

  setPoolSize(poolSize: number) {
    this.poolSize = poolSize;
  }

  private canExpandPool() {
    return this.pool.length < this.poolSize;
  }

  /**
   * 각 작업을 순차적으로 풀에 추가하고 poolSize 만큼 병렬로 수행하는 공통 로직을 담당함
   */
  async run(errorHandler: (err: unknown) => unknown) {
    const { pool, tasksIterator } = this;
    const tasks: TaskRunner<T>[] = [];

    while (true) {
      const { done, value: nextTask } = tasksIterator.next();
      if (!done) {
        pool.push(nextTask);
        tasks.push(nextTask);
        if (this.canExpandPool()) continue;
      }

      if (done && pool.length === 0) {
        break;
      }

      /**
       * 외부에서 주입한 에러 핸들링 함수를 연결함
       */
      await Promise.race(pool.map((task) => task.run())).catch(errorHandler);

      pool.splice(
        pool.findIndex((task) => task.isDone),
        1
      );
    }

    return tasks.map((task) => task.promise);
  }

  /**
   * Promise.all을 통해서 처리하는데 모든 작업이 성공적으로 완료될 때까지 대기하는 패턴을 구현함
   * 1개의 Promise라도 실패하면 그 즉시 전체가 실패함
   */
  async runAll() {
    return Promise.all(await this.run((err) => Promise.reject(err)));
  }

  /**
   * Promise.allSettled()로 처리하는데 모든 작업을 실패 여부와 상관없이 끝날 때까지 기다리고 결과를 하 번에 받아볼 수 있는 패턴을 적용함
   * () => undefined는 사실상 에러를 무시하는 방식으로 처리함
   * 마지막으로 allSettled를 통해서 성공/실패 결과 모두를 담은 배열을 얻을 수 있음
   */
  async runAllSettled() {
    return Promise.allSettled(await this.run(() => undefined));
  }
}
```

<br>

## 두 개 차이점 비교해보기
### runAll
- 여러개의 작업 중 하나라도 실패해서 try 구문의 콘솔이 출력되지 않고 NO! 만 출력됨
```ts
async function runAllTest() {
  try {
    const result = await new TaskPool(tasks, poolSize).runAll();
    console.log(result);
  } catch (e) {
    console.error(e);
  }
}

// NO!
await runAllTest();
```

<br>

### runAllSettled
```ts
async function runAllSettledTest() {
  const result = await new TaskPool(tasks, poolSize).runAllSettled();
  console.log(result);
}

// [
//   { status: 'fulfilled', value: 'A' },
//   { status: 'rejected', reason: 'NO!' },
//   { status: 'fulfilled', value: 'C' },
//   { status: 'fulfilled', value: 'D' },
//   { status: 'fulfilled', value: 'E' }
// ]
await runAllSettledTest();
```

<br>

### runAllSettled 2
```ts
async function crawling(page: number) {
  console.log(`${page} 분석 시작`);
  await delay(page * 100);
  console.log(`${page} 분석 완료`);
  return page;
}

async function runAllSettledTest2() {
  const task = (page: number) => () => page === 7 ? Promise.reject(page) : crawling(page);

  const taskPool = new TaskPool(map(task, range(Infinity)), 5);

  /**
   * 중간에 작업이 실패하더라도 계속 진행시킴
   */
  void taskPool.runAllSettled();

  /**
   * 10초 뒤에 동시 작업량을 10으로 증가시킴
   */
  setTimeout(() => {
    taskPool.setPoolSize(10);
  }, 10_000);
}

// 0 분석 시작
// 1 분석 시작
// 2 분석 시작
// 3 분석 시작
// 4 분석 시작
// 0 분석 완료
// 5 분석 시작
// 1 분석 완료
// 6 분석 시작
// 2 분석 완료
// 8 분석 시작
// 3 분석 완료
// 9 분석 시작
// 4 분석 완료
// 10 분석 시작
// 5 분석 완료
// 11 분석 시작
// 6 분석 완료
// 12 분석 시작
// 8 분석 완료
// 13 분석 시작
// 9 분석 완료
// 14 분석 시작
await runAllSettledTest2();
```