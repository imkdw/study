## 2차원 배열에서 숫자 다루기
```ts
const numbers = [
  [1, 2],
  [3, 4],
  [5, 6],
  [7, 8],
  [9, 10, 11],
  [11, 12, 13],
  [13, 14],
  [15, 16],
  [17, 18, 19],
  [20, 21, 22],
];

const oddSquareSum = numbers
  .flat()
  .filter((num) => num % 2 === 1)
  .reduce((acc, cur) => acc + cur, 0);

console.log(oddSquareSum); // 145
```

<br>

## 농구팀 데이터 다루기
```ts
type Player = {
  name: string;
  score: number;
};

type Team = {
  name: string;
  players: Player[];
};

const teams: Team[] = [
  {
    name: "Team A",
    players: [
      { name: "Player 1", score: 10 },
      { name: "Player 2", score: 20 },
    ],
  },
  {
    name: "Team B",
    players: [
      { name: "Player 3", score: 30 },
      { name: "Player 4", score: 40 },
    ],
  },
  {
    name: "Team C",
    players: [
      { name: "Player 5", score: 50 },
      { name: "Player 6", score: 60 },
    ],
  },
];

const HIGH_SCORE = 30;
const totalHighScore = teams
  .flatMap((team) => team.players)
  .filter((player) => player.score > HIGH_SCORE)
  .map((player) => player.score)
  .reduce((acc, cur) => acc + cur, 0);

console.log(totalHighScore); // 150
```

<br>

## 커머스 데이터 다루기
```ts
type Product = {
  name: string;
  price: number;
  quantity: number;
  selected: boolean;
};

const products: Product[] = [
  {
    name: "Product 1",
    price: 100,
    quantity: 1,
    selected: true,
  },
  {
    name: "Product 2",
    price: 200,
    quantity: 2,
    selected: false,
  },
  {
    name: "Product 3",
    price: 300,
    quantity: 3,
    selected: true,
  },
];

const sumSelectedQuantities = products
  .filter((product) => product.selected)
  .reduce((acc, cur) => acc + cur.quantity, 0);

const calcSelectedPrices = products
  .filter((product) => product.selected)
  .reduce((acc, cur) => acc + cur.price * cur.quantity, 0);

console.log(sumSelectedQuantities); // 4
console.log(calcSelectedPrices); // 1000
```

<br>

## 커머스 데이터 다루기 2
```ts
type Option = {
  name: string;
  price: number;
  quantity: number;
};

type Product = {
  name: string;
  price: number;
  selected: boolean;
  options: Option[];
};

const products: Product[] = [
  {
    name: "Product 1",
    price: 100,
    selected: true,
    options: [
      {
        name: "Option 1",
        price: 100,
        quantity: 1,
      },
      {
        name: "Option 2",
        price: 200,
        quantity: 2,
      },
    ],
  },
  {
    name: "Product 2",
    price: 200,
    selected: false,
    options: [
      {
        name: "Option 1",
        price: 100,
        quantity: 1,
      },
    ],
  },
  {
    name: "Product 3",
    price: 300,
    selected: true,
    options: [
      {
        name: "Option 1",
        price: 100,
        quantity: 1,
      },
      {
        name: "Option 2",
        price: 200,
        quantity: 2,
      },
    ],
  },
];

const selectedProductOptions = products.filter((product) => product.selected).flatMap((product) => product.options);

const sumSelectedQuantities = selectedProductOptions.reduce((acc, cur) => acc + cur.quantity, 0);
console.log(sumSelectedQuantities); // 6

const sumSelectedPrices = selectedProductOptions.reduce((acc, cur) => acc + cur.price * cur.quantity, 0);
console.log(sumSelectedPrices); // 1000
```

<br>

## 명령형 코드로 작성해보기 부분
- 가독성이 저하됨
- 유지보수성이 부족함
- 코드가 문장으로 구성되어 조합성과 가독성이 떨어지고 불필요한 중복코드가 생김

```ts
function calcTotalPrice(products: Product[]) {
  let totalPrice = 0;

  for (let i = 0; i < products.length; i++) {
    const product = products[i];
    if (product.selected) {
      totalPrice += product.price;
    }
  }

  return totalPrice;
}
```