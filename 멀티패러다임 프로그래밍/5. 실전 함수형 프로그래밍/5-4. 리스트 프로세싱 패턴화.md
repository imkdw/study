## 변형 누적 패턴
- 초기 이터러블을 map으로 변형하고 reduce로 누적해서 최종 결과를 도출하는 방식
- 결과물이 단일 값일 떄 주로 사용하고 배열이 아닌 객체, 숫자 문자열 등으로 데이터를 변환하는데 적합함

<br>

### 상품의 총 수량 구하기
```ts
const totalQuantity = products.map((product) => product.quantity).reduce((acc, cur) => acc + cur, 0);
```

<br>

### Query String을 객체로 변환
```ts
const queryString = "name=Dongwoo%20Kim&age=27&city=seoul";

const queryObject = queryString
  .split("&")
  .map((param) => param.split("="))
  .map((entry) => entry.map(decodeURIComponent))
  .map(([key, val]) => ({ [key as string]: val }))
  .reduce((acc, cur) => Object.assign(acc, cur));

console.log(queryObject); // { name: 'Dongwoo Kim', age: '27', city: 'seoul' }
```

<br>

### 객체를 Query String으로 변환
```ts
const params = { name: "Dongwoo Kim", age: 27, city: "seoul" };

const queryString = Object.entries(params)
  .map((entry) => entry.map(encodeURIComponent))
  .map(([key, val]) => `${key}=${val}`)
  .join("&");

console.log(queryString); // name=Dongwoo%20Kim&age=27&city=seoul
```

<br>

## 중첩-변형 패턴
- 중첩된 데이터 구조를 처리하거나 데이터의 게층을 따라 각 수준에서 변형을 수행할 떄 사용하는 패턴
- 트리 구조나 2차원 배열 등 계층적인 데이터를 변경/처리할 때 매우 유용함

<br>

### 트리 구조 변형
```ts
const tree = [
  { id: 1, children: [{ id: 2 }, { id: 3 }] },
  { id: 4, children: [{ id: 5 }, { id: 6 }] },
];

const transformedTree = tree.map(({ id, children }) => ({
  name: `parent-${id}`,
  children: children.map((child) => `child-${child.id}`),
}));

// [
//   { name: 'parent-1', children: [ 'child-2', 'child-3' ] },
//   { name: 'parent-4', children: [ 'child-5', 'child-6' ] }
// ]
console.log(transformedTree);
```

<br>

### 달력 그리기(2차원 배열 join)
```ts
import { chunk, flat, join, map, pipe, range, toArray } from "@fxts/core";

function getMonthEndDates(monthEnd: Date) {
  return monthEnd.getDate() === 6 ? [] : range(monthEnd.getDate() - monthEnd.getDay(), monthEnd.getDate() + 1);
}

function generateCalendar(prevMonthEnd: Date, currentMonthEnd: Date) {
  return pipe(
    flat([
      getMonthEndDates(prevMonthEnd),
      range(1, currentMonthEnd.getDate() + 1),
      range(1, 6 - currentMonthEnd.getDay() + 1),
    ]),
    chunk(7),
    toArray
  );
}

function formatCalendar(calendarWeeks: number[][]) {
  return pipe(calendarWeeks, map(map((day) => (day < 10 ? ` ${day}` : `${day}`))), map(join(" ")), join("\n"));
}

function renderCalendar(year: number, month: number) {
  return pipe(generateCalendar(new Date(year, month - 1, 0), new Date(year, month, 0)), formatCalendar, console.log);
}

renderCalendar(2025, 10);
// 28 29 30  1  2  3  4
//  5  6  7  8  9 10 11
// 12 13 14 15 16 17 18
// 19 20 21 22 23 24 25
// 26 27 28 29 30 31  1
```

<br>

## 반복자 - 효과 패턴
- 이터레이터를 만들어둔 후 지연 평가를 통해 데이터를 소비해서 부수적인 효과를 발생시키는 패턴
- 주로 데이터를 변형하거나 가져와서 하나씩 소비하면서 특정 작업을 수행할 떄 사용함

<br>

### 콘솔 출력으로 로그 남기기
```ts
import { fx, range } from "@fxts/core";

fx(range(5)).forEach((x) => console.log(`Processed: ${x}`));
// Processed: 0
// Processed: 1
// Processed: 2
// Processed: 3
// Processed: 4
```

<br>

### 결제 동기화 스케줄러 코드
```ts
async function runScheduler() {
  /**
   * 무한 이터러블 지정
   */
  await fx(range(1, Infinity))
    /**
     * 비동기 작업으로 변경
     */
    .toAsync()

    /**
     * 10초를 대기하는 동시에 결제 동기화 작업을 진행함
     * 10초 보다 오래 걸리는 경우 동기화 작업이 끝난 시간 이후가 다시 작업을 들어가는 시점
     * 만약 10초 보다 빨리 끝난다면 10초까지 대기하고 다음 작업을 진행함
     */
    .forEach(() => Promise.all([syncPayments(), delay(10000)]));
}

await runScheduler();
```

<br>

### 부수 효과를 격리하는 forEach
- forEach는 반환값이 없는 메서드로 명시적으로 부수 효과를 수반하는 동작을 수행하기 위해서 설계됨
- 주어진 콜백함수를 배열의 각 요소에 대해서 실행하지만 따로 값을 반환하지 않음
- 만약 부수적인 효과를 일으키면서 실행 결과를 반환해야된다면 mapEffect 같은 함수를 사용하면됨

<br>

## 필터 - 중단 패턴
- 데이터를 조건에 따라 필터링한 후 일부 데이터만 선택해서 소비하는 패턴
- 대규모 데이터 셋에서 특정 조건을 만족하는 일부 데이터만 빠르게 추출해야 할 때 사용함

<br>

### find, some, every 함수
- find, some, every 같은 함수는 filter, take를 통해 명령형 방식 없이도 효율적으로 구현이 가능함

```ts
import { filter, pipe, reject, take } from "@fxts/core";

/**
 * 조건 f를 만족하는 첫번째 요소를 찾아서 반환
 */
function find<T>(f: (a: T) => boolean, iterable: Iterable<T>) {
  return pipe(iterable, filter(f), take(1), ([found]) => found as T | undefined);
}

const arr = [1, 2, 3, 4, 5];
const result1 = find((x) => x % 2 === 0, arr);
console.log(result1); // 2

/**
 * 조건 f를 만족하는 요소가 1개라도 있으면 true를 반환
 */
function some<T>(f: (a: T) => boolean, iterable: Iterable<T>) {
  return pipe(iterable, filter(f), take(1), ([...arr]) => arr.length === 1);
}

const result2 = some((x) => x % 2 === 0, arr);
console.log(result2); // true

/**
 * 모든 요소가 조건 f를 만족하면 true를 반환
 */
function every<T>(f: (a: T) => boolean, iterable: Iterable<T>) {
  return pipe(iterable, reject(f), take(1), ([...arr]) => arr.length === 0);
}

const result3 = every((x) => x % 2 === 0, arr);
console.log(result3); // false
```

<br>

## 무한 - 중단 패턴
- 끝이 없는 데이터 스트림에서 필요한 만큼만 데이터 추출을 위한 패턴
- range를 통해서 무한히 증가하는 숫자나 특정 규칙을 따르는 데이터를 생성함
- take를 통해서 원하는 개수만큼 데이터를 추출하게됨
- 이런 패턴은 특히 정해진 데이터가 개수보다 더 많을때 효율적임

<br>

### 결제 내역이 있을 때까지 가져오기
```ts
const payments = await fx(range(1, Infinity))
  .toAsync()
  .map((page) => PgApi.getPayments(page))
  .takeUntilInclusive(({ length }) => length < 3) // 처음으로 3보다 작을 떄 까지 가져오고 멈춤
  .flat()
  .toArray();
```

<br>

## 분할 - 평탄 패턴
- 데이터를 일정 크기로 분할한 뒤 다시 평탄화해서 원하는 형태로 변환하는 기법
- 데이터의 구성을 조정하거나 대규모 데이터를 일정한 단위로 처리한 뒤 결과를 합칠 떄 유용함

<br>

### API 요청에 제한 적용하기
```ts
const orders = await fx(payments)
  .map((p) => p.store_order_id)
  .chunk(5) // 요청 5개씩 분할
  .toAsync()
  .map((p) => StoreDB.getOrders)
  .flat() // 평탄화
  .toArray();
```

<br>

## 변형 - 평탄 패턴
- 데이터를 변형하고 결과를 평탄화해서 하나의 연속된 데이터 흐름으로 만드는 기법
- 중첩된 데이터를 단일 수준으로 펼치거나 각 요소를 변형해서 새 데이터를 생성하고 이를 하나의 구조로 병합시 유용

<br>

### 댓글과 답글 하나로 병합하기
```ts
import { fx } from "@fxts/core";

type Comment = {
  id: number;
  text: string;
  replies: Omit<Comment, "replies">[];
};

const comments: Comment[] = [
  {
    id: 1,
    text: "Hello",
    replies: [{ id: 2, text: "Hi" }],
  },
  {
    id: 2,
    text: "Hi",
    replies: [
      { id: 3, text: "Hello" },
      { id: 4, text: "Hi" },
    ],
  },
  {
    id: 3,
    text: "Hello",
    replies: [{ id: 4, text: "Hi" }],
  },
];

// { id: 1, text: 'Hello' }
// { id: 2, text: 'Hi' }
// { id: 2, text: 'Hi' }
// { id: 3, text: 'Hello' }
// { id: 4, text: 'Hi' }
// { id: 3, text: 'Hello' }
// { id: 4, text: 'Hi' }
fx(comments)
  .map(({ id, text, replies }) => [{ id, text }, ...replies])
  .flat()
  .forEach(console.log);
```

<br>

## 결합 - 누적 패턴
- 여러 이터러블을 결합한 후 이를 수노히하며 최정 결과를 누적하는 패턴

<br>

### keys + values로 객체 생성
```ts
import { fx, zip } from "@fxts/core";

const keys = ["name", "job", "age"];
const values = ["Dongwoo", "Developer", 27];

const object = fx(zip(keys, values))
  .map(([key, val]) => ({ [key]: val }))
  .reduce((acc, cur) => Object.assign(acc, cur));

console.log(object); // { name: 'Dongwoo', job: 'Developer', age: 27 }
```

<br>

### 리스트에 고유 ID 부여하기
```ts
import { map, pipe, range, toArray, zip } from "@fxts/core";

const items = ["Java", "Python", "Javascript"];

const itemWithIds = pipe(
  zip(range(Infinity), items),
  map(([id, item]) => ({ id, item })),
  toArray
);

console.log(itemWithIds);
// [
//   { id: 0, item: 'Java' },
//   { id: 1, item: 'Python' },
//   { id: 2, item: 'Javascript' }
// ]
```

<br>

## 해시 - 매치 패턴
- 데이터를 효율적으로 구성하거나 조회하기 위한 해시 구조를 생성하는데 사용함
- 데이터를 키로 매핑, 그룹화, 카운팅, 변환 등 작업에 활용함

<br>

### posts, users 매칭
```ts
import { indexBy } from "@fxts/core";

type User = {
  id: number;
  name: string;
};

const users: User[] = [
  { id: 1, name: "John" },
  { id: 2, name: "Jane" },
  { id: 3, name: "Jim" },
];

type Post = {
  id: number;
  title: string;
  user_id: User["id"];
};

const posts: Post[] = [
  { id: 1, title: "Hello", user_id: 1 },
  { id: 2, title: "World", user_id: 2 },
  { id: 3, title: "Hello", user_id: 3 },
];

const usersById = indexBy((user) => user.id, users);

const postsWithUsers = posts.map((post) => ({
  ...post,
  user: usersById[post.user_id],
}));

console.log(postsWithUsers);
// [
//   { id: 1, title: 'Hello', user_id: 1, user: { id: 1, name: 'John' } },
//   { id: 2, title: 'World', user_id: 2, user: { id: 2, name: 'Jane' } },
//   { id: 3, title: 'Hello', user_id: 3, user: { id: 3, name: 'Jim' } }
// ]
```

<br>

## 리스트 프로세싱 함수 유형별 개념 정리
### 지연 중간 연산
- 결과가 실제로 필요할 때까지 연산을 미루며 이 단계만으로는 최종 결과가 나오지 않음
- 에시로는 map, filter, zip 등이 있음

<br>

### 단축 중간 연산
- 특정 조건이 충족되면 그 시점에서 더 이상 데이터를 읽지 않아서 불필요한 연산을 건너뜀
- 에시로는 take, takeUntilInclusive 등이 있음

<br>

### 터미널 연산
- 실제 이터러블을 전부 소비하여 최종 결과를 만들어냄
- 한번 연산을 호출하면 지연이 해체되고 실제 순회가 발생함
- 예시로는 find, every, reduce 등이 있음

<br>

### 폴드/리듀스 연산
- 터미널 연산 중에서도 시퀀스 전체를 하나의 값으로 누적하여 반환하는 연산을 가르킴
- 예시로는 reduce, groupBy, indexBy이 있고 Promise.all, Array.fromAsync도 있음

<br>

### 부수 효과
- 출력, 로그 등 외부 상태를 변화시키는 연산으로 보통 내부에서 콜백으로 `무언가 실행`하고 끝나는 형태임
- 대표적으로 forEach가 있음