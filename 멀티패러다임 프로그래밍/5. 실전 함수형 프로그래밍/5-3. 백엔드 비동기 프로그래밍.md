## 커머스 플랫폼의 결제 프로세스 문제
- 커머스 플랫폼에서 결제 과정 도중에 네트워크 장애, 브라우저 종료 등으로 인해 결제 성공 알림이 커머스 플랫폼에 정상적으로 전달되지 못하는 상황이 발생할 수 있음
- 이를 해결하기 위해서 주기적으로 PG사의 결제 데이터를 조회해서 우리 커머스 플랫폼의 데이터와 대조하는 작업이 필요함
- 이러한 동기화 작업은 데이터 불일치를 해결하고 고객의 결제 및 주문 문제를 예방, UX 개선에 중요한 역할을 함

<br>

## 결제 내역 동기화 스케줄러 만들기
### PG사 SDK
```ts
function delay<T>(time: number): Promise<undefined>;
function delay<T>(time: number, value: T): Promise<T>;
function delay<T>(time: number, value?: T): Promise<T | undefined> {
  return new Promise((resolve) => setTimeout(resolve, time, value));
}

type Payment = {
  pg_uid: string;
  store_order_id: number;
  amount: number;
};

const pgDatPaymentsPage: Payment[][] = [
  [
    { pg_uid: "PG11", store_order_id: 1, amount: 15000 },
    { pg_uid: "PG12", store_order_id: 2, amount: 15000 },
    { pg_uid: "PG13", store_order_id: 3, amount: 15000 },
  ],
  [
    { pg_uid: "PG14", store_order_id: 4, amount: 20000 },
    { pg_uid: "PG15", store_order_id: 5, amount: 20000 },
    { pg_uid: "PG16", store_order_id: 6, amount: 20000 },
  ],
  [
    { pg_uid: "PG17", store_order_id: 7, amount: 25000 },
    { pg_uid: "PG18", store_order_id: 8, amount: 25000 },
    { pg_uid: "PG19", store_order_id: 9, amount: 25000 },
  ],
];

const pgApi = {
  async getPayments(page: number) {
    console.log(`결제 내역 요청: https://api.pg.com/v1/payments?page=${page}`);
    await delay(500);

    const payments = pgDatPaymentsPage[page - 1] ?? [];
    console.log(`${payments.length}개: ${payments.map((p) => p.pg_uid).join(", ")}`);

    return payments;
  },

  async cancelPayment(pg_uid: string) {
    console.log(`취소 요청: ${pg_uid}`);
    await delay(300);
    return {
      code: 200,
      message: `${pg_uid} 취소 완료`,
      pg_uid,
    };
  },
};
```

<br>

### 커머스 플랫폼의 디비
```ts
type Order = {
  id: number;
  amount: number;
  is_paid: boolean;
};

const StoreDB = {
  async getOrders(ids: number[]): Promise<Order[]> {
    console.log(`SELECT * FROM orders WHERE IN (${ids}) AND is_paid = true`);
    await delay(100);

    return [
      { id: 1, amount: 15000, is_paid: true },
      { id: 3, amount: 25000, is_paid: true },
      { id: 5, amount: 20000, is_paid: true },
      { id: 7, amount: 25000, is_paid: true },
      { id: 8, amount: 25000, is_paid: true },
    ];
  },
};
```

<br>

### 결제 동기화 작업 구현하기
```ts
async function syncPayments() {
  {
    /**
     * 1. PG사 결제 내역 조회
     * - 페이지 단위로 데이터 요청
     * - 결제 데이터 있는 모든 페이지를 가져와서 하나로 병합
     */
    /**
     * 2. PG사 결제 내역과 일치하는 커머스 플랫폼 주문 데이터 조회
     */
    /**
     * 누락된 결제 취소 및 환불 처리
     * - 주문 내역과 매칭되지 않은 PG사 결제를 추려냄
     * - 해당 결제 ID를 취소 API를 통해서 처리함
     */
  }
}

await syncPayments();
```

<br>

### PG사 결제 내역 조회
- 로직의 시작 단게에서는 요청해야 할 페이지의 수를 미리 알 수 없음
- 만약 다음 데이터가 존재한다면 다시 재요청을 해야되는 상황임
```ts
/**
 * 1. PG사 결제 내역 조회
 * - 페이지 단위로 데이터 요청
 * - 결제 데이터 있는 모든 페이지를 가져와서 하나로 병합
 */
const payments = await fx(range(1, Infinity)) // 무한 이터러블 생성
  .toAsync() // 비동기 작업으로 변환
  .map((page) => pgApi.getPayments(page)) // 결제 내역 가져오기
  .takeUntilInclusive(({ length }) => length < 3) // 처음으로 3보다 적다면 즉시 종료
  .flat() // 평탄화
  .toArray(); // 배열로 변환

// 결제 내역 요청: https://api.pg.com/v1/payments?page=1
// 3개: PG11, PG12, PG13
// 결제 내역 요청: https://api.pg.com/v1/payments?page=2
// 3개: PG14, PG15, PG16
// 결제 내역 요청: https://api.pg.com/v1/payments?page=3
// 2개: PG17, PG18
// [
//   { pg_uid: 'PG11', store_order_id: 1, amount: 15000 },
//   { pg_uid: 'PG12', store_order_id: 2, amount: 15000 },
//   { pg_uid: 'PG13', store_order_id: 3, amount: 15000 },
//   { pg_uid: 'PG14', store_order_id: 4, amount: 20000 },
//   { pg_uid: 'PG15', store_order_id: 5, amount: 20000 },
//   { pg_uid: 'PG16', store_order_id: 6, amount: 20000 },
//   { pg_uid: 'PG17', store_order_id: 7, amount: 25000 },
//   { pg_uid: 'PG18', store_order_id: 8, amount: 25000 }
// ]
console.log(payments);
```

<br>

### 주문 데이터 가져오기
```ts
/**
 * 2. PG사 결제 내역과 일치하는 커머스 플랫폼 주문 데이터 조회
 */
const orders = await StoreDB.getOrders(payments.map((p) => p.store_order_id));

// SELECT * FROM orders WHERE IN (1,2,3,4,5,6,7,8) AND is_paid = true
// [
//   { id: 1, amount: 15000, is_paid: true },
//   { id: 3, amount: 25000, is_paid: true },
//   { id: 5, amount: 20000, is_paid: true },
//   { id: 7, amount: 25000, is_paid: true },
//   { id: 8, amount: 25000, is_paid: true }
// ]
console.log(orders);
```

<br>

### 누락된 결제 취소 및 환불처리
- `reject`를 통해서 주문 내역과 결제 내역 모두에 존재하는 결제는 전부 제거해서 결제 이후 완료처리가 안된 주문만 남음
- 이후에 `forEach`를 통해서 주문 완료처리가 안된 결제들은 환불을 진행함

```ts
/**
 * 누락된 결제 취소 및 환불 처리
 * - 주문 내역과 매칭되지 않은 PG사 결제를 추려냄
 * - 해당 결제 ID를 취소 API를 통해서 처리함
 */
await fx(payments)
  .toAsync()
  .reject((payment) => orders.some((order) => order.id === payment.store_order_id))
  .forEach(async (payment) => {
    const { message } = await pgApi.cancelPayment(payment.pg_uid);
    console.log(message);
  });

// 취소 요청: PG12
// PG12 취소 완료
// 취소 요청: PG14
// PG14 취소 완료
// 취소 요청: PG16
// PG16 취소 완료
```

<br>

## 해시 기반 접근으로 시간 복잡도 최적화
- `orders.some(func)` 방식의 경우 최대 `O(n * m)`의 시간복잡도가 나올 수 있음
- orders를 해시 구조로 변환해서 접근에 대한 시간복잡도를 `O(1)`으로 줄일 수 있음
- 만약 대규모 데이터셋의 경우 `Array.map`보다 이터레이터의 map이 메모리 효율면에서 유리함

```ts
// {
//   '1': { id: 1, amount: 15000, is_paid: true },
//   '3': { id: 3, amount: 25000, is_paid: true },
//   '5': { id: 5, amount: 20000, is_paid: true },
//   '7': { id: 7, amount: 25000, is_paid: true },
//   '8': { id: 8, amount: 25000, is_paid: true }
// }
const ordersById = Object.fromEntries(map((order) => [order.id, order], orders));

/**
 * 누락된 결제 취소 및 환불 처리
 * - 주문 내역과 매칭되지 않은 PG사 결제를 추려냄
 * - 해당 결제 ID를 취소 API를 통해서 처리함
 */
await fx(payments)
  .toAsync()
  .reject((payment) => ordersById[payment.store_order_id])
  .forEach(async (payment) => {
    const { message } = await pgApi.cancelPayment(payment.pg_uid);
    console.log(message);
  });
```

<br>

## 안정적인 비동기 작업 간격 유지
```ts
async function runScheduler() {
  /**
   * 무한 이터러블 지정
   */
  await fx(range(1, Infinity))
    /**
     * 비동기 작업으로 변경
     */
    .toAsync()

    /**
     * 10초를 대기하는 동시에 결제 동기화 작업을 진행함
     * 10초 보다 오래 걸리는 경우 동기화 작업이 끝난 시간 이후가 다시 작업을 들어가는 시점
     * 만약 10초 보다 빨리 끝난다면 10초까지 대기하고 다음 작업을 진행함
     */
    .forEach(() => Promise.all([syncPayments(), delay(10000)]));
}
```

<br>

## 최대 요청 크기 제한을 효과적으로 처리하기
- 현대의 백엔드 시스템은 외부 API, DB, 마이크로 서비스간 통신시 요청 크기에 대한 제한을 두는 경우가 많음
- 만약 기존에 `StoreDB.getOrders()`에서 한번에 조회가 가능한 주문을 5건으로 제한한다는 가정을 함

<br>

### 주문 동시요청 카운트 제한
```ts
const StoreDB = {
  MAX_ORDERS_PER_REQUEST: 5,
  async getOrders(ids: number[]): Promise<Order[]> {
    if (ids.length > this.MAX_ORDERS_PER_REQUEST) {
      throw new Error(`주문은 한번에 ${this.MAX_ORDERS_PER_REQUEST}개 이상 조회할 수 없습니다.`);
    }

    console.log(`SELECT * FROM orders WHERE IN (${ids}) AND is_paid = true`);
    await delay(100);

    return [
      { id: 1, amount: 15000, is_paid: true },
      { id: 3, amount: 25000, is_paid: true },
      { id: 5, amount: 20000, is_paid: true },
      { id: 7, amount: 25000, is_paid: true },
      { id: 8, amount: 25000, is_paid: true },
    ];
  },
};
```
```
file:///Users/imkdw/Desktop/ts-pg/dist/app.js:43
  throw new Error(`주문은 한번에 ${this.MAX_ORDERS_PER_REQUEST}개 이상 조회할 수 없습니다.`);
```

<br>

### 요청 분할하기
- `chunk`를 통해서 요청을 N개씩 분할해서 안전하고 효율적으로 데이터 조회가 가능함

```ts
    const orders = await fx(payments)
      .map((payment) => payment.store_order_id)
      .chunk(StoreDB.MAX_ORDERS_PER_REQUEST)
      .toAsync()
      // SELECT * FROM orders WHERE IN (1,2,3,4,5) AND is_paid = true
      // SELECT * FROM orders WHERE IN (6,7,8) AND is_paid = true
      .flatMap(StoreDB.getOrders)
      .toArray();
```

<br>

## 사전 카운트로 효율 높이기
```ts
const pgApi = {
  async getPageCount() {
    console.log(`페이지 카운트 요청: https://api.pg.com/v1/pages`);
    await delay(50);
    return pgDatPaymentsPage.length;
  },
  // ...
}
```

```ts
/**
 * 결제의 총 페이지수 조회
 */
const totalPaymentPages = await pgApi.getPageCount();

/**
 * 1. PG사 결제 내역 조회
 * - 페이지 단위로 데이터 요청
 * - 결제 데이터 있는 모든 페이지를 가져와서 하나로 병합
 */
const payments = await fx(range(1, totalPaymentPages + 1)) // 실제 결제 페이지 수만큼 이터러블 생성
  .toAsync() // 비동기 작업으로 변환
  .map((page) => pgApi.getPayments(page)) // 결제 내역 가져오기
  .flat() // 평탄화
  .toArray(); // 배열로 변환
```

<br>

## 병렬성으로 효율 높이기
- 기존에는 총 몇 페이지가 존재하는지 알 수 없었어서 순차적으로 요청하면서 특정 조건에 만족하면 종료하는게 필요함
- 하지만 이제 총 몇페이지가 존재하는지 알 수 있으므로 병렬처리가 가능해짐

<br>

### 순차적 처리 예제
```ts
console.time("TEST");
const result = await fx([1, 2, 3, 4, 5, 6])
  .toAsync()
  .map((a) => delay(1000, a))
  .toArray();

console.log(result);
console.timeEnd("TEST");

// [ 1, 2, 3, 4, 5, 6 ]
// TEST: 6.014s
```

<br>

### 병렬처리 예제
- concurrent 메서드를 추가해서 병렬로 실행이 가능함
- 내부 인자만큼 동시에 이터레이터를 소모하게됨

```ts
console.time("TEST");
const result = await fx([1, 2, 3, 4, 5, 6])
  .toAsync()
  .map((a) => delay(1000, a))
  .concurrent(2)
  .toArray();

console.log(result);
console.timeEnd("TEST");

// [ 1, 2, 3, 4, 5, 6 ]
// TEST: 3.016s
```

<br>

### 기존 결제 조회시 병렬처리 적용하기
```ts
  console.time("GET_PAYMENTS");
  const payments = await fx(range(1, totalPaymentPages + 1)) // 실제 결제 페이지 수만큼 이터러블 생성
    .toAsync() // 비동기 작업으로 변환
    .map((page) => pgApi.getPayments(page)) // 결제 내역 가져오기
    .concurrent(totalPaymentPages) // 총 페이지의 개수만큼 병렬로 요청
    .flat() // 평탄화
    .toArray(); // 배열로 변환
  console.timeEnd("GET_PAYMENTS");

  // 페이지 카운트 요청: https://api.pg.com/v1/pages
  // 결제 내역 요청: https://api.pg.com/v1/payments?page=1
  // 결제 내역 요청: https://api.pg.com/v1/payments?page=2
  // 결제 내역 요청: https://api.pg.com/v1/payments?page=3
  // 3개: PG11, PG12, PG13
  // 3개: PG14, PG15, PG16
  // 2개: PG17, PG18
  // GET_PAYMENTS: 502.789ms
```