## FxTS 라이브러리
- Iterable/AsyncIterable 프로토콜에 기반한 리스트 프로세싱 함수 세트를 제공하는 라이브러리
- 타입 추론, 비동기/병렬/동시성 프로그래밍을 강력하게 지원해서 실제 업무 환경에서 유용하게 쓸 수 있음

<br>

## pipe 함수
- 여러 함수를 연속적으로 적용하여 값을 처리하는 함수로 주로 두 개 이상의 함수를 합성하고 코드의 표현력을 높이기 위해서 사용함
- pipe는 reduce를 활용해 여러 함수를 이터러블로 다루고 각 함수의 결과를 다음 함수에 연속적으로 전달해서 최종 결과를 생성하게됨

```ts
import { pipe } from "@fxts/core";

const result = pipe(
  10,
  (a) => a + 4,
  (a) => a / 2
);

console.log(result); // 7
```

<br>

## 커링과 함께 사용하기
- 커링의 장점을 살려주는 표현력과 강력한 타입 추론을 제공함
- pipe를 통해서 커링된 함수들을 연결해서 자연스럽고 읽기 쉬운 코드로 작성이 가능함

```ts
import { pipe } from "@fxts/core";

const add = (a: number) => (b: number) => a + b;

const result = add(10)(5);
console.log(result); // 15

const add10 = add(10);
console.log(add10(5)); // 15

const result2 = pipe(5, add(10), add(5));
console.log(result2); // 20
```
```ts
pipe(
  ["1", "2", "3", "4", "5"],
  map((a) => parseInt(a)),
  filter((a) => a % 2 === 1),
  reduce((a, b) => a + b),
  console.log
); // 9
```

<br>

## pipe와 비동기 함수 합성
- pipe는 비동기 함수의 결과를 자동으로 처리해서 다음 함수의 인자로 전달함
- 각 단계에서 정확한 타입 추론을 제공하는데 이를 통해 코드의 명확성과 가독성을 높이고 동기/비동기 작업을 자연스럽게 연결할 수 있음

```ts
import { delay, pipe } from "@fxts/core";

const result = await pipe(
  Promise.resolve(10), // 초기 비동기 값
  (a) => a + 10, // 동기 함수로 a: number 상태
  async (a) => {
    // 비동기 함수로 1초간 대기하고 a: number 반환
    await delay(1000);
    return a * 2;
  },
  (a) => a - 5 // 동기 함수로 a: number 상태
);

console.log(result); // 35
```

<br>

### AsyncIterable을 다루는 함수와 합성
```ts
import { filter, fx, map, pipe, toArray, toAsync } from "@fxts/core";

const arr = [1, 2, 3, 4, 5];

/**
 * 파이프라이닝
 */
const result = await pipe(
  arr,
  toAsync,
  map((a: number) => Promise.resolve(a + 10)), // Promise<number>를 반환
  filter((a) => a % 2 === 0), // 여기서 a는 단순 a: number
  toArray,
  (arr) => arr.reverse()
);
console.log(result); // [14, 12]

/**
 * 체이닝
 */
const result2 = await fx(arr)
  .toAsync()
  .map((a) => Promise.resolve(a + 10))
  .filter((a) => a % 2 === 0)
  .toArray()
  .then((arr) => arr.reverse());
console.log(result2); // [14, 12]
```

<br>

## zip 함수
- keys, values 같은 두 배열을 결합해서 entries 형태의 이터러블을 생성하는 함수
- 이를 활용해서 두 배열의 인덱스를 다루지 않고 쉽게 결합이 가능함

<br>

### entries를 만드는 방법들
```ts
const keys = ["name", "job", "location"];
const values = ["John", "Engineer", "Seoul"];

/**
 * keys, values를 통한 object 만들기
 */
const object: Record<string, string> = {};
for (let i = 0; i < keys.length; i++) {
  const key = keys[i];
  const value = values[i];

  if (key && value) {
    object[key] = value;
  }
}
console.log(object); // { name: 'John', job: 'Engineer', location: 'Seoul' }

/**
 * entires로 object 만들기
 */
const entries = [
  ["name", "John"],
  ["job", "Engineer"],
  ["location", "Seoul"],
];
const object2: Record<string, string> = {};
for (const [key, value] of entries) {
  if (key && value) {
    object2[key] = value;
  }
}
console.log(object2); // { name: 'John', job: 'Engineer', location: 'Seoul' }

const obj3 = Object.fromEntries(entries);
console.log(obj3); // { name: 'John', job: 'Engineer', location: 'Seoul' }
```

<br>

### zip을 활용한 entries 만들기
- 함수형 스타일에서는 반복문이나 인덱스 증가와 같은 명령형 코드를 사용하는 대신 데이터 흐름과 변환 과정을 명확하게 표현하는 선언적인 접근 방식을 선호함
- zip의 경우 이런 문제를 리스트 프로세싱으로 해결하는 데 유용한 도구 중 하나임

```ts
import { pipe, zip } from "@fxts/core";

const keys = ["name", "job", "location"];
const values = ["John", "Engineer", "Seoul"];

/**
 * 이터레이터 만들기
 */
const iterator = zip(keys, values);
console.log(iterator.next()); // { value: ['name', 'John'], done: false }
console.log(iterator.next()); // { value: ['job', 'Engineer'], done: false }
console.log(iterator.next()); // { value: ['location', 'Seoul'], done: false }
console.log(iterator.next()); // { value: undefined, done: true }

/**
 * fromEntries로 object 만들기
 */
const object = Object.fromEntries(zip(keys, values));
console.log(object); // { name: 'John', job: 'Engineer', location: 'Seoul' }

/**
 * pipe랑 함께 사용하기
 */
pipe(zip(keys, values), Object.fromEntries, console.log); // { name: 'John', job: 'Engineer', location: 'Seoul' }

/**
 * 커링하기
 */
pipe(values, zip(keys), Object.fromEntries, console.log); // { name: 'John', job: 'Engineer', location: 'Seoul' }
```

<br>

## 인덱스가 값으로 필요한 경우
### 숫자 배열 + zip 사용하기
```ts
import { zip } from "@fxts/core";

const strings = ["a", "b", "c", "d"];
const iter = zip([0, 1, 2, 3], strings);
console.log(iter.next()); // { value: [0, 'a'], done: false }
console.log(iter.next()); // { value: [1, 'b'], done: false }
console.log(iter.next()); // { value: [2, 'c'], done: false }
console.log(iter.next()); // { value: [3, 'd'], done: false }
console.log(iter.next()); // { value: undefined, done: true }
```

<br>

### 동적으로 숫자 생성하기 - range
- range는 원하는 길이의 숫자 이터러블을 생성함
- `range(3)`의 경우 `[0, 1, 2]`를 생성하는 방식임
- 아래에서 `range(Infinity)`는 무한 이터레이터를 생성하는데 이 때 strings의 길이만큼 반복하게됨
- 이처럼 zip, range를 함께 사용하면 배열의 길이에 관계없이 유연하게 인덱스를 생성하고 매핑이 가능함

```ts
import { range, zip } from "@fxts/core";

const iter = range(3);
console.log(iter.next()); // { value: 0, done: false }
console.log(iter.next()); // { value: 1, done: false }
console.log(iter.next()); // { value: 2, done: false }
console.log(iter.next()); // { value: undefined, done: true }

const strings = ["a", "b", "c", "d"];
const iter2 = zip(range(Infinity), strings);
for (const a of iter2) {
  console.log(a); // [0, 'a'] [1, 'b'] [2, 'c'] [3, 'd']
}
```

<br>

## break를 대신하는 take, takeWhile, takeUntilInclusive
- break는 명령형 코드에서 문장 사이에 들어가 반복문의 불필요한 반복을 줄이고 시간 복잡도를 낮추며 효율을 높이기 위해서 사용함
- 함수형 프로그래밍에서도 이와 비슷한 take, find, some 등이 존재함
- find, some, every 같은 경우 잘 구현하지 못하면 시간복잡도는 최악의 경우는 O(n)이 되며 잘 구현했다면 O(k)까지 줄어들 수 있음. k는 조건이 충족된 지점까지의 요소 개수
- 결론적으로 take 함수는 지연 평가된 이터레이터에서 소비할  최대 개수를 지정하여 결과를 제한하는 함수임

<br>

### takeWhile과 takeUntilInclusive
- 위 두 함수는 모두 이터레이터의 소비슷 제어하는 함수로 특정 조건에 따라 소비를 중단하게됨
- 하지만 여기서 소비된 요소의 개수와 처리 방식에는 차이가 존재함

```ts
import { fx } from "@fxts/core";

/**
 * 조건이 false가 되는 첫 번째 요소를 평가하고 소비를 중단함
 * 소비된 요소는 1,2,3,0 4개이며 결과는 [1,2,3]임
 */
fx([1, 2, 3, 0, 0, 0, 5, 6])
  .takeWhile((a) => {
    console.log("takeWhile", a, a >= 1);
    return a >= 1;
  })
  .forEach((a) => console.log(a));
// 1
// takeWhile 2 true
// 2
// takeWhile 3 true
// 3
// takeWhile 0 false
// 0

/**
 * 조건이 true가 되는 첫 번째 요소(5)까지 소비한 뒤 중단함
 * 소비된 요소 개수는 0, 10, 1, 3, 5 5개이며 결괏값은 0, 10, 1, 3, 5임
 */
fx([0, 10, 1, 3, 5, 0, 4, 2])
  .takeUntilInclusive((a) => {
    console.log("takeUntilInclusive", a, a === 5);
    return a === 5;
  })
  .forEach((a) => console.log(a));
// takeUntilInclusive 0 false
// 10
// takeUntilInclusive 10 false
// 1
// takeUntilInclusive 1 false
// 3
// takeUntilInclusive 3 false
// 5
// takeUntilInclusive 5 true
```

<br>

### takeWhile, takeUntilInclusive간의 차이가 중요한 유
#### takeWhile
- 조건이 true인 구간까지만 결과에 포함되므로 특정 조건을 만족하는 데이터만 정확히 추출할 떄 유용함
- 결국 조건에 맞는 결과물을 엄격하게 추려내야 할 때 적합함

<br>

#### takeUntilInclusive
- 조건 평가 비용이 높거나 앞서 만들어진 이터레이터의 소비 비용이 큰 경우 더 효율적임
- 결국 조건을 만족하는 시점에 초점을 맞추고 소비 중단을 통한 효율성이 중요한 경우 적합함