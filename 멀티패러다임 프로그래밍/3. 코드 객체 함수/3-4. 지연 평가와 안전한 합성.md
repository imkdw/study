## find 함수 시그니처
- map, filter는 연산을 지연한 이터레이터를 만든 후 계속 리스트 프로세승을 이어갈 수 있도록 하는 함수임
- find의 경우는 지연된 이터레이터를 평가해서 결과를 만드는 유형의 함수임
- 이터러블을 순회하면서 요소마다 f로 조건을 평가하고, 있으면 첫번째 요소 반환, 없으면 undefined를 반환함

<br>

### 하스켈의 함수 시그니처
- `(a -> Bool)` 타입의 함수랑 `[a]` 타입의 리스트를 인자로 받음
- `Maybe a`의 뜻은 함수에 의해 만족하는게 있다면 `Just a`, 없다면 `Nothing`을 반환하게됨
- 이러한 부분은 타스의 `undefined | A`와 유사함

```haskell
find :: (a -> Bool) -> [a] -> Maybe a
```

<br>

### 타스로 표현하기
```ts
type Find1 = <A>(f: (a: A) => boolean, arr: A[]) => A | undefined;
type Find2 = <A>(f: (a: A) => boolean, iterable: Iterable<A>) => A | undefined;
```

<br>

## 하스켈에서 find 함수와 안전한 합성
- fromMaybe 함수는 두 개의 인자를 받는데 0과 커링으로 한번 더 전달함
- find의 경우 짝수를 판별하는 `event` 함수와 리스트로 `[1, 3, 5]`를 전달함
- 결과적으로 `0`을 반환하게됨

```haskell
module Main where

import Data.List (find)
import Data.Maybe (fromMaybe)

main :: IO ()
main = do
  let result = fromMaybe 0 (find even [1, 3, 5])
  print result -- 0
```

<br>

## find 함수로 생각하는 지연 평가와 리스트 프로세싱
### 명령형으로 find 함수 구현
```ts
function find<A>(f: (a: A) => boolean, iterable: Iterable<A>): A | undefined {
  const iterator = iterable[Symbol.iterator]();
  while (true) {
    const { done, value } = iterator.next();
    if (done) return undefined;
    if (f(value)) return value;
  }
}

const result = find((a) => a % 2 === 0, [1, 2, 3, 4]);
console.log(result); // 2
```

<br>

### 함수형으로 구현한 find 함수
```ts
function* find<A>(f: (a: A) => boolean, iterable: Iterable<A>): IterableIterator<A> {
  const iterator = iterable[Symbol.iterator]();
  while (true) {
    const { done, value } = iterator.next();
    if (done) return;
    if (f(value)) yield value;
  }
}

const result = find((a) => a % 2 === 0, [1, 2, 3, 4]);
console.log(result.next()); // { value: 2, done: false }
```

<br>

### 함수형으로 구현된 filter와 find의 차이
- `Array.prototype.filter` 처럼 지연평가를 지원하지 않는 경우 모든 배열을 순회하고 그 결과를 반환함
- 하지만 지연평가를 지원하는 경우 이터레이터를 사용하는 곳에서 원하는 만큼만 실행이 가능해짐
- 그래서 find 함수는 filter를 사용해서도 구현이 가능해짐

```ts
function* filter<A>(f: (a: A) => boolean, iterable: Iterable<A>): IterableIterator<A> {
  const iterator = iterable[Symbol.iterator]();
  while (true) {
    const { done, value } = iterator.next();
    if (done) break;
    if (f(value)) yield value;
  }
}

function* find<A>(f: (a: A) => boolean, iterable: Iterable<A>): IterableIterator<A> {
  const iterator = iterable[Symbol.iterator]();
  while (true) {
    const { done, value } = iterator.next();
    if (done) return;
    if (f(value)) yield value;
  }
}
```

<br>

### filter를 사용해서 find를 구현하는 여러가지 방법들
#### 단순 filter를 사용하고 next() 메서드에서 반환된 값 사용하기
```ts
function find<A>(f: (a: A) => boolean, iterable: Iterable<A>): A | undefined {
  return filter(f, iterable).next().value;
}
```

<br>

#### head라는 헬퍼 함수를 사용하기
- head 함수는 주어진 이터러블의 첫 번째 요소를 반환하게됨
- find 함수는 filter 함수를 사용해서 필터링할 준비를 하고 head 함수로 첫번째 요소를 반환함
- head 라는 헬퍼 함수를 별도로 정의해서 코드의 모듈성, 재사용성을 높이고 함수의 책임을 분명하게함

```ts
function head<A>(iterable: Iterable<A>): A | undefined {
  return iterable[Symbol.iterator]().next().value;
}

function find<A>(f: (a: A) => boolean, iterable: Iterable<A>): A | undefined {
  return head(filter(f, iterable));
}
```

<br>

#### FxIterable을 통해서 체이닝 방식으로 구현
```ts
function find<A>(f: (a: A) => boolean, iterable: Iterable<A>): A | undefined {
  return fx(iterable).filter(f).to(head);
}

const result = find((a) => a > 2, [1, 2, 3, 4]);
console.log(result); // 3
```

<br>

## 타스에서 안전한 합성
```ts
function find<A>(f: (a: A) => boolean, iterable: Iterable<A>): A | undefined {
  return fx(iterable).filter(f).to(head);
}

const desserts = [
  { name: "apple pie", price: 5000 },
  { name: "carrot cake", price: 3500 },
  { name: "donut", price: 3000 },
];

/**
 * Optional Chaining 연산자를 통해서 name 프로퍼티에 안전하게 접근
 */
const dessert = find(({ price }) => price < 2000, desserts);
console.log(dessert?.name ?? "T.T"); // T.T

/**
 * Non-null 단언 연산자(!)를 통해서 무조건 찾을 상황을 의도하고 있다고 언어와 소통함
 */
const dessert2 = find(({ price }) => price < Infinity, desserts);
console.log(dessert2!.name); // apple pie
```

<br>

## every 함수
- 주어진 함수 f가 모든 요소에 대해서 참이라면 true, 1개라도 거짓이 있다면 false를 반환함
- 이 때 배열을 순회하는 reduce 함수를 통해서 구현도 가능함
- 대부분 언어의 경우 && 연산자를 지원하는데 reduce + && 연산자를 혼합해서 구현이 가능함

<br>

### 시그니처
```ts
type Every1 = <A>(f: (a: A) => boolean, arr: A[]) => boolean;
type Every2 = <A>(f: (a: A) => boolean, iterable: Iterable<A>) => boolean;
```

<br>

### 구현
- map 함수를 통해서 함수 f를 적용해서 값을 boolean 값으로 변환함
- 이후에 reduce f 인자에 `acc && a`를 통해서 한번이라도 false가 발생하면 값은 false가 반환됨

```ts
function every<A>(f: (a: A) => boolean, iterable: Iterable<A>): boolean {
  return fx(iterable)
    .map(f)
    .reduce((acc, a) => acc && a, true);
}

const isOdd = (n: number): boolean => n % 2 === 1;

console.log(every(isOdd, [1, 3, 5, 7, 9])); // true
```

<br>

## some 함수
- every 함수와 거의 유사함
- every의 경우 && 연산을 통해서 값을 반환했지만 some의 경우 하나라도 만족하면 참이므로 ||를 사용함

```ts
type Some1 = <A>(f: (a: A) => boolean, arr: A[]) => boolean;
type Some2 = <A>(f: (a: A) => boolean, iterable: Iterable<A>) => boolean;

function some<A>(f: (a: A) => boolean, iterable: Iterable<A>): boolean {
  return fx(iterable)
    .map(f)
    .reduce((acc, a) => acc || a, true);
}

const isOdd = (n: number): boolean => n % 2 === 1;

console.log(some(isOdd, [2, 5, 6])); // true
```

<br>

## 지연 평가에 기반한 break 로직 끼워 넣기
- every, some 두 함수가 결과를 만들기 위해서 굳이 모든 인자를 탐색할 필요는 없음
- some의 경우 true를 하나라도 만나면 그 즉시 반환하게 만들 수 있음
- every의 경우 반대로 false를 하나라도 만나면 그 즉시 반환하게 만들 수 있음

```ts
function every<A>(f: (a: A) => boolean, iterable: Iterable<A>): boolean {
  return fx(iterable)
    .map(f)
    .filter((a) => !a)
    .take(1)
    .reduce((acc, a) => acc && a, true);
}

function some<A>(f: (a: A) => boolean, iterable: Iterable<A>): boolean {
  return fx(iterable)
    .map(f)
    .filter((a) => a)
    .take(1)
    .reduce((acc, a) => acc || a, true);
}

const isOdd = (n: number): boolean => n % 2 === 1;

console.log(every(isOdd, [1, 3, 5, 7, 9])); // true
console.log(some(isOdd, [2, 5, 6])); // true
```

<br>

## every, some 함수의 공통 로직을 함수형으로 추상화
- 함수형 프로그래밍은 리스트, 코드, 함수를 값으로 다루므로 공통 로직을 분리하여 추상화하기 편리함

```ts
function accumulateWith<A>(
  accumulator: (a: boolean, b: boolean) => boolean,
  acc: boolean,
  taking: (a: boolean) => boolean,
  f: (a: A) => boolean,
  iterable: Iterable<A>
): boolean {
  return fx(iterable).map(f).filter(taking).take(1).reduce(accumulator, acc);
}

function every<A>(f: (a: A) => boolean, iterable: Iterable<A>): boolean {
  return accumulateWith(
    (a, b) => a && b,
    true,
    (a) => !a,
    f,
    iterable
  );
}

function some<A>(f: (a: A) => boolean, iterable: Iterable<A>): boolean {
  return accumulateWith(
    (a, b) => a || b,
    false,
    (a) => a,
    f,
    iterable
  );
}

const isOdd = (n: number): boolean => n % 2 === 1;

console.log(every(isOdd, [1, 3, 5, 7, 9])); // true
console.log(some(isOdd, [2, 5, 6])); // true
```

<br>

## concat으로 더하기
- 배열 메서드 concat은 여러 배열을 하나로 결합하는데 사용함
- 여러개의 배열을 한번에 결합해서 반환하는데 이 과정에서 원본 배열은 수정되지 않음
- 하지만 한 시점에 모든 배열 요소를 즉시 평가하고 결합하므로 매우 큰 배열 결합시 메모리 사용량이 증가할 수 있음
- 제너레이터를 통한 concat을 구현하게되면 지연 평가를 통해 요소를 필요할 때 마다 처리가 가능해서 효율이 좋음

<br>

### 제너레이터로 concat 구현하기
```ts
function* concat<A>(...iterables: Iterable<A>[]): IterableIterator<A> {
  for (const iterable of iterables) {
    yield* iterable;
  }
}

const arr = [1, 2, 3, 4];
const iter = concat(arr, [5]);
console.log([...iter]); // [1, 2, 3, 4, 5]
```

<br>

### 배열 메서드 concat, 제너레이터 concat의 차이점
- Array.concat의 경우 즉시 길이가 10인 배열을 만듦, 만약 길이가 크다면 메모리 사용량이 증가함
- 제너레이터를 활용한 경우 새로운 배열을 만들지 않고 결합된 요소를 하나씩 생성해서 처리함
  - 해당 과정에서 배열이 만들어지지 않고 필요한 순간에만 값을 생성해서 작동함
```ts
/**
 * Array.concat 메서드 예제
 */
const arr = [1, 2, 3, 4, 5];
const arr2 = arr.concat([6, 7, 8, 9, 10]);
console.log(arr2); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
let acc = 0;
for (const a of take(7, arr2)) {
  acc += a;
}
console.log(acc); // 28

/**
 * 제너레이터 concat 예제
 */
const iter = concat(arr, [6, 7, 8, 9, 10]);
console.log(iter); // Object [Generator] {}
let acc2 = 0;
for (const a of take(7, iter)) {
  acc2 += a;
}
console.log(acc2); // 28
```

<br>

### push, unshift 대신 concat을 사용하며 생각해보기
- push나 unshift의 경우 원본 배열의 새로운 값을 추가하므로 원본 배열에 변경점이 생김
- concat의 경우 원본 배열을 변경하지 않고 작업이 가능함

<br>

### take와 함께 사용하기
- unshift 대신 concat을 사용해서 필요한 개수만 가져오면 전체 배열을 조작할 필요가 없음
- take에 limit으로 전달한 만큼만 처리하므로 전체 배열을 조작하지 않아도 됨

```ts
const arr1 = [1, 2, 3, 4, 5];
const arr2 = [6, 7, 8, 9, 10];
const iter = take(3, concat(arr1, arr2));
console.log([...iter]); // [1, 2, 3]
```

<br>

### some과 함계 사용하기
- take와 함께 사용하는 것 처럼 unshift -> concat 사용하고 some으로 조건을 만족하는 요소를 찾음
- 이러면 필요한 만큼만 요소를 생성하고 처리가 가능해서 효율적임
- some 함수의 경우 조건을 만족하는 첫 번째 요소를 찾은 후 즉시 순회를 중지해서 효율적임

```ts
const arr = [3, 4, 5];
console.log(some((n) => n < 3, arr)); // false

const iter = concat([1, 2], arr);
console.log(some((n) => n < 3, iter)); // true
```