## 하스켈로부터 배우기
- 하스켈은 순수 함수형 프로그래밍 언어로 평가되며 함수형 패러다임이 잘 반영하도록 설계된 문법을 지님
- 순수 함수와 함수 합성을 강조하고 커링이 기본이며 지연 평가를 지원하고 부수 효과를 특별하게 관리함

<br>

## 하스켈의 함수 시그니처
- 하스켈과 타스 모두 함수 시그니처를 명시함으로써 함수의 입출력 타입을 분명히 할 수 있음

```haskell
square :: Int -> Int
square x = x * x
```

```ts
type Square = (x: number) => number
const square: Square = (x) => x * x;
```

<br>

## 언어 차원에서 지원하는 커링
- 여러 인자를 받는 함수를 인자 하나씩 받는 함수들의 연쇄로 표현하는 기법
- 중위연산자로 표현도 가능해서 `3 add 7` -> `add 3 7`과 동일함  
- 하스켈은 언어 차원에서 커링을 지원해서 자연스럽게 함수 시그니처 표현이 가능함

```haskell
module Main where

add :: Int -> Int -> Int
add x y = x + y

addFive :: Int -> Int
addFive = add 5

main :: IO ()
main = do
  print (addFive 10) -- 15
  print (add 3 7) -- 10
  print  (3 `add` 7) -- 10
```

<br>

## main 함수와 IO
- 하스켈은 모든 프로그램이 main 함ㅅ구로 시작하고 main 함수는 IO 타입을 반환해야함
- IO는 하스켈에서 입출력 작업을 나타내는 함수인데 순수 함수형 언어인 하스켈은 입출력과 같은 부수효과 관리를 위해서 IO 타입을 사 용함

<br>

### IO와 부수 효과 관리
- 모든 함수가 같은 인자에 대해서 항상 동일한 결과를 내놓아야하는 순수성을 지향함
- 하스켈에선부수 효과가 있는 함수는 IO 타입을 통해서 격리하는 식으로 해결함
- `순수 함수(A -> B)`와 `IO 함수(A -> IO)`를 확실하게 구분함
- 정리하자면 IO는 하스켈에서 이 함수는 입출력 상태변경 등 순수하지 않은 일을 할 수 있다는 것을 선언하는 타입임

<br>

### Unit 타입 ()와 타입스크립트의 void
- Unit 타입은 의미 없는 값을 나타내며 함수가 유의미한 값을 반환하지 않을 떄 사용함
- 타입스크립트의 경우도 void 타입을 사용해서 비슷한 의도를 드러낼수 있음

<br>

## head, map, filter, foldl 함수 시그니처
### head 함수
- 리스트의 첫번째 요소를 반환함

```haskell
head :: [a] -> a
```
```ts
type Head1 = <A>(arr: A[]) => A;
type Head2 = <A>(iterable: Iterable<A>) => A;
```

<br>

### map 함수
- 리스트의 각 요소에 주어진 함수를 적용해서 새로운 리스트를 반환함

```haskell
map :: (a -> b) -> [a] -> [b]
```

```ts
type Map1 = <A, B>(f: (a: A) => B, arr: A[]) => B[];
type Map2 = <A, B>(f: (a: A) => B, iterable: Iterable<A>) => Iterable<B>;
```

<br>

### filter 함수
- 리스트의 각 요소에 대해서 주어진 조건을 검사해서 조건을 만족하는 요소만을 포함하는 새로운 리스트를 반환
```haskell
filter :: (a -> Bool) -> [a] -> [a]
```
```ts
type Filter1 = <A>(f: (a: A) => boolean, arr: A[]) => A[];
type Filter2 = <A>(f: (a: A) => boolean, iterable: Iterable<A>) => Iterable<A>;
```

<br>

### foldl 함수
- reduce 함수와 유사하게 리스트를 요소를 왼 -> 오순으로 순회하면서 하나의 값으로 누적시킴

```haskell
foldl :: (b -> a -> b) -> b -> [a] -> b
```
```ts
type Foldl1 = <A, B>(f: (acc: B, a: A) => B, acc: B, arr: A[]) => B;
type Foldl2 = <A, B>(f: (acc: B, a: A) => B, acc: B, iterable: Iterable<A>) => B;
```

<br>

## 함수 합성 - `.` 연산자와 `$` 연산자
### `.` 연산자
- 함수를 합성할 때 사용함
- f, g, h 3개의 함수를 합성한다면 `(\x -> f(g (h x)))`와 동일함
- h를 먼저 실행 -> 그 결과를 g에 전달 -> 그 결과를 f에 전달하는 식으로 동작함
- 자스의 경우 `(x) => f(g(h(x)))`와 동일함

<br>

### `$` 연산자
- 함수 적용을 위한 연산자로서 우선순위를 조정하고 인자를 전달해서 함수를 즉시 평가함
- `f $ g $ h x` -> `f (g (h x))`와 동일함
- 자스의 경우 `f(g(h(x)))`와 동일함

```haskell
module Main where

f :: Int -> Int
f x = x + 1

g :: Int -> Int
g x = x * 2

h :: Int -> Int
h x = x - 3

main :: IO ()
main = do
  let result = f . g . h $ 5 -- f (g (h 5))
  print result -- 5
```

<br>

## 하스켈에서 sumOfSquaresOfOddNumbers 함수 구현
```haskell
module Main where

square :: Int -> Int
square x = x * x

sumOfSquaresOfOddNumbers :: Int -> [Int] -> Int
sumOfSquaresOfOddNumbers limit list =
  foldl (+) 0 . take limit . map square . filter odd $ list

main :: IO ()
main = print (sumOfSquaresOfOddNumbers 3 [1, 2, 3, 4, 5, 6, 7, 8, 9]) -- 35
```

<br>

## 파이프라인 스타일 - &
- 함수 합성 연산자 대신 정방향 함수 적용 연산자를 통해서 파이프라인 스타일로 작성이 가능함

```haskell
import Data.Function ((&))

square :: Int -> Int
square x = x * x

sumOfSquaresOfOddNumbers :: Int -> [Int] -> Int
sumOfSquaresOfOddNumbers limit list =
  list
    & filter odd
    & map square
    & take limit
    & foldl (+) 0

main :: IO ()
main = print (sumOfSquaresOfOddNumbers 3 [1, 2, 3, 4, 5, 6, 7, 8, 9]) -- 35
```

<br>

## Either를 통한 에러 처리
- 순수 함수형 언어로써 전통적인 try~catch 문법이 아닌 타입을 통해 에러 상황을 명시적으로 표현하는 방식을 선호함
- 대표적인 타입으로 Either가 있는데 이는 성공, 실패를 구분해서 함수의 결과를 명확하게 구분함
- 이로써 컴파일 타임에 에러 처리가 필요함을 인지시킴

<br>

### (div 10 0) - 예외
```haskell
main :: IO ()
main = do
  print (div 10 2)
  print (div 10 0) -- Exception: divide by zero
```

<br>

### 안전한 나눗셈
- 런타임 Exception 대신에 명시적인 에러 상황 표현이 가능함

```haskell
module Main where

safeDiv :: Int -> Int -> Either String Int
safeDiv _ 0 = Left "Cannot Devide by Zero"
safeDiv x y = Right (div x y)

main :: IO ()
main = do
  print (safeDiv 10 2) -- Right 5
  print (safeDiv 10 0) -- Left "Cannot Devide by Zero"
```

<br>

## 패턴 매칭
- 패턴 매칭 문법은 간결하고 직관적인 코드를 작성하게 도와줌
- TS랑 비교하면 함수 오버로드, if, 타입가드 등 문법을 패턴 매칭 하나로 해결이 가능함

```haskell
module Main where

safeDiv :: Int -> Int -> Either String Int
safeDiv _ 0 = Left "Cannot Devide by Zero"
safeDiv x y = Right (div x y)

processResult :: Either String Int -> String
processResult (Left errMsg) = "에러: " ++ errMsg
processResult (Right value) = "결과: " ++ show value

main :: IO ()
main = do
  let result1 = safeDiv 10 2
  let result2 = safeDiv 10 0

  putStrLn (processResult result1) -- 결과: 5
  putStrLn (processResult result2) -- 에러: Cannot Devide by Zero
```