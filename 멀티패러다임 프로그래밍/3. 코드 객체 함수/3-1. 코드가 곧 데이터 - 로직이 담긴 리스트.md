## 코드를 리스트로 생각하기
- 코드를 리스트로 바라보는 사고방식은 프로그래밍 패러다임을 확장하는 강력한 도구
- 함수형 프로그래밍에선 코드 = 데이터, 데이터 = 코드인 특성을 이용해서 더 읽기쉽고 유지보수하기 좋은 코드 작성이 가능

<br>

### 명령형으로 작성한 n개의 홀수를 제곱하여 모두 더하는 함수
- 처음으로 등장하는 홀수 `limit`개를 제곱해서 더하는 함수다

```ts
function sumOfSquaresOfOddNumbers(limit: number, list: number[]): number {
  let acc = 0;

  for (const a of list) {
    if (a % 2 === 1) {
      const b = a * a;
      acc += b;
      if (--limit === 0) {
        break;
      }
    }
  }

  return acc;
}

console.log(sumOfSquaresOfOddNumbers(3, [1, 2, 3, 4, 5, 6, 7, 8, 9])); // 35
```

<br>

### if -> filter로 변경
```ts
function sumOfSquaresOfOddNumbers(limit: number, list: number[]): number {
  let acc = 0;

  for (const a of list.filter((a) => a % 2 === 1)) {
    const b = a * a;
    acc += b;
    if (--limit === 0) {
      break;
    }
  }

  return acc;
}

console.log(sumOfSquaresOfOddNumbers(3, [1, 2, 3, 4, 5, 6, 7, 8, 9])); // 35
```

<br>

### 값 변화 후 변수 할당을 map으로 대체
```ts
function sumOfSquaresOfOddNumbers(limit: number, list: number[]): number {
  let acc = 0;

  for (const a of list.filter((a) => a % 2 === 1).map((a) => a * a)) {
    acc += a;
    if (--limit === 0) {
      break;
    }
  }

  return acc;
}

console.log(sumOfSquaresOfOddNumbers(3, [1, 2, 3, 4, 5, 6, 7, 8, 9])); // 35
```

<br>

### break -> take 대체
- `take` 함수는 주어진 이터러블에서 지정된 limit 만큼의 요소를 반환하는 지연된 리스트인 이터러블 이터레이터를 반환함
- take에 전달되는 iterable을 만들기 위한 filter, map은 아무런 연산도 이루어지지 않음
- `for...of` 문에서 a를 처음 뽑을 때 1이 들어오고 두번째는 9, 세번째는 25가 들어오게됨

```ts
function* take<A>(limit: number, iterable: Iterable<A>): IterableIterator<A> {
  const iterator = iterable[Symbol.iterator]();
  while (true) {
    const { done, value } = iterator.next();
    if (done) {
      break;
    }

    yield value;
    if (--limit === 0) {
      break;
    }
  }
}

function sumOfSquaresOfOddNumbers(limit: number, list: number[]): number {
  let acc = 0;

  for (const a of take(
    limit,
    list.filter((a) => a % 2 === 1).map((a) => a * a)
  )) {
    acc += a;
    if (--limit === 0) {
      break;
    }
  }

  return acc;
}

console.log(sumOfSquaresOfOddNumbers(3, [1, 2, 3, 4, 5, 6, 7, 8, 9])); // 35
```

<br>

### 합산을 reduce로 대체
```ts
function sumOfSquaresOfOddNumbers(limit: number, list: number[]): number {
  return reduce(
    (acc, cur) => acc + cur,
    take(
      limit,
      map(
        (a) => a * a,
        filter((a) => a % 2 === 1, list)
      )
    )
  );
}

console.log(sumOfSquaresOfOddNumbers(3, [1, 2, 3, 4, 5, 6, 7, 8, 9])); // 35
```

<br>

### 체이닝으로 변경하기
- `리스트 프로세싱`은 이처럼 명령형 코드 라인들을 리스트 변환해줌
- 코드를 값으로 다루고 함수를 값으로 다루어 작은 코드들의 목록으로 복잡한 문제를 해결할 수 있음
- 이것이 함수형 프로그래밍과 리스트 프로세싱의 방법임

```ts
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}

  // ...

  take(limit: number): FxIterable<A> {
    return fx(take(limit, this));
  }
}

const fx = <A>(iterable: Iterable<A>): FxIterable<A> => new FxIterable(iterable);

const sumOfSquaresOfOddNumbers = (limit: number, list: number[]): number =>
  fx(list)
    .filter((a) => a % 2 === 1)
    .map((a) => a * a)
    .take(limit)
    .reduce((acc, cur) => acc + cur);

console.log(sumOfSquaresOfOddNumbers(3, [1, 2, 3, 4, 5, 6, 7, 8, 9])); // 35
```

<br>