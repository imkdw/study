## 중첩된 이터레이터의 실행 순서 - 제너레이터로 확인
- 단순히 코드로 보면 filter -> map -> take 순으로 실행될꺼라고 생각할 수 있음
- 하지만 실제 실행 결과로는 take -> map -> filter 순으로 실행됨
- 처음으로 take 함수까지 실행한 결과로 만들어진 이터레이터의 next()를 for...of를 통해서 처음 호출할 때 take 함수의 while 루프부터 실행되기 때문임
- 다시 자신이 인자로 받은 이터레이터의 next()를 호출하는데 해당 이터레이터는 map까지 실행한 이터레이터라서 map 내부 while 루프가 실행되고 다음에 filter로 이어지게됨

```ts
const iterable = fx([1, 2, 3, 4, 5])
  .filter((a) => a % 2 === 1)
  .map((a) => a * a)
  .take(2);

for (const a of iterable) {
  console.log(`result : ${a}`);
}
```

```
take limit: 2
map
filter
result : 1
take limit: 1
map
filter
filter
result : 9
```

<br>

## 자세히 살펴보기
- 맨 처음 for...of 루프가 처음 next()를 호출하면 take 함수의 while 루프가 시작됨
- take 함수는 파라미터로 전달된 limit 값을 로그에 출력함
- take 함수도 내부의 `iterator.next()` 호출을 통해서 map 함수의 next()를 호출함
- map 함수는 map 로그를 출력하고 `iterator.next()` 호출을 통해서 filter 함수의 next()를 호출함
- filter 함수는 filter 로그를 출력하고 `iterator.next()` 호출함
- 이 때 첫 번째 값인 1이 filter 함수에 도달하고 조건을 만족해서 추가 로그를 출력함
- map 함수는 추가 로그를 출력하고 take 함수는 take value: 1을 출력하게됨
- 그리고 루프가 완료되어서 for...of 루프 내부의 console.log("result : ${a}")가 실행됨
```
take limit: 2
map
filter
filter value f(value: 1) true
map value f(value: 1) 1
take value: 1
result : 1
---
take limit: 1
map
filter
filter value f(value: 2) false
filter
filter value f(value: 3) true
map value f(value: 3) 9
take value: 9
result : 9
---
```

<br>

## 이터레이터로 직접 살펴보기
- take 함수에서 반환한 이터레이터의 `next()` 메서드가 호출되면서 `take limit: 2`가 출력됨
- 해당 시점에 iterator는 mapped 이므로 next() 메서드를 호출하면서 mapped.next()가 호출됨
- map 함수가 반환한 이터레이터의 next() 메서드가 호출되면서 `map` 로그가 출력됨
- 해당 시점에 10이 반환되면서 `map value f(value: 10) 100` 로그가 출력됨
- 그 다음에 `take value: 100`이 출력되며 결과적으로 `taked.next()`는 `{ value: 100, done: false }`를 반환
```ts
function map<A, B>(f: (a: A) => B, iterable: Iterable<A>): IterableIterator<B> {
  const iterator = iterable[Symbol.iterator]();
  return {
    next() {
      console.log("map");
      const { done, value } = iterator.next();
      console.log(`map value f(value: ${value}) ${f(value)}`);
      return done ? { value: undefined, done } : { value: f(value), done };
    },
    [Symbol.iterator](): IterableIterator<B> {
      return this;
    },
  };
}

function take<A>(limit: number, iterable: Iterable<A>): IterableIterator<A> {
  const iterator = iterable[Symbol.iterator]();
  return {
    next() {
      if (limit === 0) return { done: true, value: undefined };

      console.log(`take limit: ${limit}`);

      const { done, value } = iterator.next();
      if (done) return { done, value: undefined };

      limit--;

      console.log(`take value: ${value}`);

      return { value, done };
    },
    [Symbol.iterator](): IterableIterator<A> {
      return this;
    },
  };
}

const mapped = map((a) => a * a, [10, 20, 30]);
const taked = take(2, mapped);
console.log(taked.next());

// take limit: 2
// map
// map value f(value: 10) 100
// take value: 100
// { value: 100, done: false }
```

<br>

## 단순화해서 살펴보기
- `taked.next()`를 실행하면 `take -> map -> filter` 순으로 진행해서 결과를 반환
- 이후에 다시 `filter -> map -> take` 순으로 돌아옴
```ts
const filtered = {
  next: () => iterator.next(),
};

const mapped = {
  next: () => filtered.next(),
};

const taked = {
  next: () => mapped.next(),
};

taked.next();
```