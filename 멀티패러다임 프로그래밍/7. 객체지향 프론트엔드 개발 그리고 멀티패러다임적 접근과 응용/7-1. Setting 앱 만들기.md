## 객체지향이 중요한 이유
- 현대의 클라이언트 측 개발에서는 UI 렌더링 갱신을 대신 관리해주는 리액티브한 패러다임의 라이브러리가 널리 활용되고 있음
- 히지만 여전히 피그마, 구글 시트처럼 풍부한 기능과 고품질 UX를 제공하는 실시간 편집 툴을 만들기 위해서는 OOP 능력이 필요함
- 방대한 기능을 모듈화하고 관리하는 데도 객체지향적인 접근이 매우 유용함
- 네이티브로 제공되는 기능들은 대부분 객체지향적 패러다임을 바탕으로 설계되어 있고 높은 사용성을 갖춘 소프트웨어 개발을 목표로 하고있음
- 탄탄한 기본기는 결국 뛰어난 응용력을 이끌어냄

<br>

## Web API
- 웹 브라우저 환경에서 동작하는 소프트웨어를 프로그래밍 하기 위한 기초 도구임
- Web API 중 다수는 이미 객체지향적으로 설게되어 있음
- Web API 인터페이스 위에 사용자 정의 클래스를 정의하는 것만으로도 충분히 객체지향적이고 확장 가능한 설계를 구현할 수 있음
- 소프트웨어 개발 분야에서 오랫동안 검증된 객체지향 패턴과 아이디어를 활용하면 더욱 견고하고 유지보수가 용이한 코드 작성이 가능함

<br>

## SwitchView
```ts
import { html, Html, View } from "rune-ts";

class SwitchView extends View<{ on: boolean }> {
  protected override template(data: { on: boolean }): Html {
    return html`
      <button class=${this.data.on ? "on" : ""}>
        <span class="toggle"></span>
      </button>
    `;
  }
}

export function main() {
  const switchView = new SwitchView({ on: true });

  // <button data-rune="SwitchView" data-rune-parent="null" class="SwitchView" class=on>
  //   <span class="toggle"></span>
  // </button>
  console.log(switchView.toHtml());

  document.querySelector("#app")!.append(switchView.render());
}

main();
```

<br>

### 버튼을 클릭하면 스위치를 토글하게 만들기
- render 메서드가 실행되면 onRender() 메서드도 같이 실행된다
- 이 때 현재 element에 이벤트를 등록하는데 클릭할 때 마다 반대값으로 바뀌게되며 클래스에 `on or ''`가 추가된다

```ts
class SwitchView extends View<{ on: boolean }> {
  protected override template(data: { on: boolean }): Html {
    return html`
      <button class=${this.data.on ? "on" : ""}>
        <span class="toggle"></span>
      </button>
    `;
  }

  protected override onRender() {
    this.element().addEventListener("click", () => {
      this.setOn(!this.data.on);
    });
  }

  setOn(bool: boolean) {
    this.data.on = bool;
    this.element().classList.toggle("on", bool);
  }
}
```

<br>

### public과 protected
- public: 클래스 외부에서도 해당 메서드를 자유롭게 호출 가능
  - 이를 통해 프로그램 로직이 필요할 때 언제든지 SwitchView의 상태를 직접 변경 가능
- protected: 클래스 외부에서는 접근이 불가능하고 클래스 내부나 이를 상속받은 하위 클래스만 가능함
  - onRender()의 경우 뷰 렌더링 과정에서 자동으로 호출되는 라이프사이클 훅 메서드임
  - 위 같은 메서드는 외부에 공개하지 않오록 설정해서 UI 변화나 상태에 문제가 발생하는걸 예방함

<br>

## SettingItemView
```ts
interface Setting {
  title: string;
  on: boolean;
}

class SettingItemView extends View<Setting> {
  protected override template(data: Setting): Html {
    return html`
      <div>
        <span class="title">${this.data.title}</span>
        ${new SwitchView(this.data)}
      </div>
    `;
  }
}

export function main() {
  const setting = { title: "WIFI", on: false };

  const settingItem = new SettingItemView(setting);

  // <div data-rune="SettingItemView" data-rune-parent="null" class="SettingItemView">
  //   <span class="title">WIFI</span>
  //   <button data-rune="SwitchView" data-rune-parent="SettingItemView" class="SwitchView" class=>
  //     <span class="toggle"></span>
  //   </button>
  // </div>
  console.log(settingItem.toHtml());
  document.querySelector("#app")!.append(settingItem.render());
}
```

<br>

## SettingListView
```ts
class SettingListView extends View<Setting[]> {
  protected template(data: Setting[]): Html {
    return html` <div>${data.map((setting) => new SettingItemView(setting))}</div> `;
  }
}

export function main() {
  const settings: Setting[] = [
    { title: "WIFI", on: false },
    { title: "Bluetooth", on: true },
    { title: "Airplane Mode", on: false },
  ];

  const settingList = new SettingListView(settings);
  // <div data-rune="SettingListView" data-rune-parent="null" class="SettingListView">
  //   <div data-rune="SettingItemView" data-rune-parent="SettingListView" class="SettingItemView">
  //     <span class="title">WIFI</span>
  //     <button data-rune="SwitchView" data-rune-parent="SettingItemView" class="SwitchView">
  //       <span class="toggle"></span>
  //     </button>
  //   </div>

  //   <div data-rune="SettingItemView" data-rune-parent="SettingListView" class="SettingItemView">
  //     <span class="title">Bluetooth</span>
  //     <button data-rune="SwitchView" data-rune-parent="SettingItemView" class="SwitchView on">
  //       <span class="toggle"></span>
  //     </button>
  //   </div>

  //   <div data-rune="SettingItemView" data-rune-parent="SettingListView" class="SettingItemView">
  //     <span class="title">Airplane Mode</span>
  //     <button data-rune="SwitchView" data-rune-parent="SettingItemView" class="SwitchView">
  //       <span class="toggle"></span>
  //     </button>
  //   </div>
  // </div>
  console.log(settingList.toHtml());
  document.querySelector("#app")!.append(settingList.render());
}

main();
```

<br>

## 전체 토글 기능 추가하기
- `toggleAll` 메서드에서 쉬운 접근을 위해서 각 뷰 내부에서 views, items를 재할당함
- window 객체에 settingPage 인스턴스를 추가해서 콘솔창에서 접근 가능하게 만듦
- 콘솔에 `settingPage.toggleAll(bool: boolean)` 메서드를 입력하면 토글 조정이 가능해짐

```ts
interface Setting {
  title: string;
  on: boolean;
}

class SwitchView extends View<{ on: boolean }> {
  protected override template(): Html {
    return html`
      <button class=${this.data.on ? "on" : ""}>
        <span class="toggle"></span>
      </button>
    `;
  }

  protected override onRender() {
    this.element().addEventListener("click", () => {
      this.setOn(!this.data.on);
    });
  }

  setOn(bool: boolean) {
    this.data.on = bool;
    this.element().classList.toggle("on", bool);
  }
}

class SettingItemView extends View<Setting> {
  switchView = new SwitchView(this.data);

  protected override template(): Html {
    return html`
      <div>
        <span class="title">${this.data.title}</span>
        ${this.switchView}
      </div>
    `;
  }
}

class SettingListView extends View<Setting[]> {
  itemViews = this.data.map((setting) => new SettingItemView(setting));

  protected override template(): Html {
    return html` <div>${this.itemViews}</div> `;
  }
}

class SettingPage extends View<Setting[]> {
  listView = new SettingListView(this.data);

  protected template(data: Setting[]): Html {
    return html`
      <div>
        <div class="header">
          <h2>Setting</h2>
          ${new SwitchView({ on: false })}
        </div>
        <div class="body">${this.listView}</div>
      </div>
    `;
  }

  toggleAll(bool: boolean) {
    this.listView.itemViews
      .filter((itemView) => itemView.data.on !== bool)
      .forEach((itemView) => itemView.switchView.setOn(bool));
  }
}

export function main() {
  const settings: Setting[] = [
    { title: "WIFI", on: false },
    { title: "Bluetooth", on: true },
    { title: "Airplane Mode", on: false },
  ];

  const settingPage = new SettingPage(settings);
  (window as any).settingPage = settingPage;

  document.querySelector("#body")!.append(settingPage.render());
}

main();
```

<br>

## 객체 간 통신과 커스텀 이벤트 디스패치
중단