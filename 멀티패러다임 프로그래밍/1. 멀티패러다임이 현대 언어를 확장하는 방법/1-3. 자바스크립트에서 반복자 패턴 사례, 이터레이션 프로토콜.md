## 이터레이터와 이터러블
- 어떤 객체가 이터레이터를 반환하는 `[Symbol.iterator]() { return { next() { ... }}; }` 메소드를 가지고 있다면 `이터러블`임
- 이터러블 객체는 자신이 가진 요서들을 이터레이터를 통해 순회할 수 있도록 하며 앞에서 설명한 반복자 패턴의 특성을 모두 갖추고 있음

<br>

### 이터레이터
- `function*` 키워드를 안쓰고 만드는것도 가능함

```ts
function naturals(end = Infinity): Iterator<number> {
  let n = 1;
  return {
    next(): IteratorResult<number> {
      return n <= end
        ? { value: n++, done: false }
        : { value: undefined, done: true };
    },
  };
}

const iter = naturals(3);
console.log(iter.next().value); // 1
console.log(iter.next().value); // 2
console.log(iter.next().value); // 3
console.log(iter.next().value); // undefined
```

<br>

### 하지만 for...of문으로 순회하려면
- 내부에는 `[Symbol.iterator]() {...}` 메소드가 있어야 함
```ts
const iter = naturals(3);

/**
 * Type 'Iterator<number, any, any>' must have a '[Symbol.iterator]()' method that returns an iterator.ts(2488)
 */
for (const num of iter) {
  console.log(num);
}
```

<br>

#### 메소드 추가하기
- Iterator -> IterableIterator로 타입을 변경하고 하단에 `[Symbol.iterator](): IterableIterator<number> { return this; }` 메소드를 추가함
- `for ... of` 문에서는 이터레이터의 `next()`를 자동으로 호출하게됨
```ts
function naturals(end = Infinity): IterableIterator<number> {
  let n = 1;
  return {
    next(): IteratorResult<number> {
      return n <= end
        ? { value: n++, done: false }
        : { value: undefined, done: true };
    },
    [Symbol.iterator](): IterableIterator<number> {
      return this;
    },
  };
}

const iter = naturals(3);

for (const num of iter) {
  // 1, 2, 3
  console.log(num);
}
```

<br>

#### 정리하기
- iterator: `{ value, done }`객체를 반환하는 `next()` 메서드를 가진 값
- iterable: iterator를 반환하는 `[Symbol.iterator]()` 메서드를 가진 값
- iterableIterator: iterator 이면서 iterable인 값
- 이터레이션 프로토콜 : 이터러블을 `for ... of`, 스프레드 연산자 등과 함께 동작하도록 한 규약

<br>

### 내장 이터러블
#### Array
- 배열 array는 기본적으로 iterable임

```ts
const array = [1, 2, 3];
const arrayIterator = array[Symbol.iterator]();

console.log(arrayIterator.next()); // { value: 1, done: false }
console.log(arrayIterator.next()); // { value: 2, done: false }
console.log(arrayIterator.next()); // { value: 3, done: false }
console.log(arrayIterator.next()); // { value: undefined, done: true }

for (const value of array) {
  // 1, 2, 3
  console.log(value);
}

```

<br>

#### Set
- set도 iterable임
- Symbol.iterator를 통해서 이터레이터를 생성하고 모든 요소를 next() 메서드로 순회가 가능함

```ts
const set = new Set([1, 2, 3]);
const setIterator = set[Symbol.iterator]();

console.log(setIterator.next()); // { value: 1, done: false }
console.log(setIterator.next()); // { value: 2, done: false }
console.log(setIterator.next()); // { value: 3, done: false }
console.log(setIterator.next()); // { value: undefined, done: true }

for (const value of set) {
  // 1, 2, 3
  console.log(value);
}
```

<br>

#### Map
```ts
const map = new Map([
  ["a", 1],
  ["b", 2],
  ["c", 3],
]);
const mapIterator = map[Symbol.iterator]();

console.log(mapIterator.next()); // { value: ["a", 1], done: false }
console.log(mapIterator.next()); // { value: ["b", 2], done: false }
console.log(mapIterator.next()); // { value: ["c", 3], done: false }
console.log(mapIterator.next()); // { value: undefined, done: true }

for (const value of map) {
  // ["a", 1], ["b", 2], ["c", 3]
  console.log(value);
}
```

<br>

#### Map의 entries() 메서드
```ts
const map = new Map([
  ["a", 1],
  ["b", 2],
  ["c", 3],
]);
const mapEntries = map.entries();

console.log(mapEntries.next()); // { value: ["a", 1], done: false }
console.log(mapEntries.next()); // { value: ["b", 2], done: false }
console.log(mapEntries.next()); // { value: ["c", 3], done: false }
console.log(mapEntries.next()); // { value: undefined, done: true }

const mapValues = map.values();
for (const value of mapValues) {
  console.log(value);
}

const mapKeys = map.keys();
for (const key of mapKeys) {
  // a, b, c
  console.log(key);
}
```