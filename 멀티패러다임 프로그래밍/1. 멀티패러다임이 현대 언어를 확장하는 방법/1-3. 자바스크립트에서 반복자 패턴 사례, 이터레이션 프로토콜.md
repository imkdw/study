## 이터레이터와 이터러블
- 어떤 객체가 이터레이터를 반환하는 `[Symbol.iterator]() { return { next() { ... }}; }` 메소드를 가지고 있다면 `이터러블`임
- 이터러블 객체는 자신이 가진 요서들을 이터레이터를 통해 순회할 수 있도록 하며 앞에서 설명한 반복자 패턴의 특성을 모두 갖추고 있음

<br>

### 이터레이터
- `function*` 키워드를 안쓰고 만드는것도 가능함

```ts
function naturals(end = Infinity): Iterator<number> {
  let n = 1;
  return {
    next(): IteratorResult<number> {
      return n <= end
        ? { value: n++, done: false }
        : { value: undefined, done: true };
    },
  };
}

const iter = naturals(3);
console.log(iter.next().value); // 1
console.log(iter.next().value); // 2
console.log(iter.next().value); // 3
console.log(iter.next().value); // undefined
```

<br>

### 하지만 for...of문으로 순회하려면
- 내부에는 `[Symbol.iterator]() {...}` 메소드가 있어야 함
```ts
const iter = naturals(3);

/**
 * Type 'Iterator<number, any, any>' must have a '[Symbol.iterator]()' method that returns an iterator.ts(2488)
 */
for (const num of iter) {
  console.log(num);
}
```

<br>

#### 메소드 추가하기
- Iterator -> IterableIterator로 타입을 변경하고 하단에 `[Symbol.iterator](): IterableIterator<number> { return this; }` 메소드를 추가함
- `for ... of` 문에서는 이터레이터의 `next()`를 자동으로 호출하게됨
```ts
function naturals(end = Infinity): IterableIterator<number> {
  let n = 1;
  return {
    next(): IteratorResult<number> {
      return n <= end
        ? { value: n++, done: false }
        : { value: undefined, done: true };
    },
    [Symbol.iterator](): IterableIterator<number> {
      return this;
    },
  };
}

const iter = naturals(3);

for (const num of iter) {
  // 1, 2, 3
  console.log(num);
}
```

<br>

#### 정리하기
- iterator: `{ value, done }`객체를 반환하는 `next()` 메서드를 가진 값
- iterable: iterator를 반환하는 `[Symbol.iterator]()` 메서드를 가진 값
- iterableIterator: iterator 이면서 iterable인 값
- 이터레이션 프로토콜 : 이터러블을 `for ... of`, 스프레드 연산자 등과 함께 동작하도록 한 규약

<br>

### 내장 이터러블
#### Array
- 배열 array는 기본적으로 iterable임

```ts
const array = [1, 2, 3];
const arrayIterator = array[Symbol.iterator]();

console.log(arrayIterator.next()); // { value: 1, done: false }
console.log(arrayIterator.next()); // { value: 2, done: false }
console.log(arrayIterator.next()); // { value: 3, done: false }
console.log(arrayIterator.next()); // { value: undefined, done: true }

for (const value of array) {
  // 1, 2, 3
  console.log(value);
}

```

<br>

#### Set
- set도 iterable임
- Symbol.iterator를 통해서 이터레이터를 생성하고 모든 요소를 next() 메서드로 순회가 가능함

```ts
const set = new Set([1, 2, 3]);
const setIterator = set[Symbol.iterator]();

console.log(setIterator.next()); // { value: 1, done: false }
console.log(setIterator.next()); // { value: 2, done: false }
console.log(setIterator.next()); // { value: 3, done: false }
console.log(setIterator.next()); // { value: undefined, done: true }

for (const value of set) {
  // 1, 2, 3
  console.log(value);
}
```

<br>

#### Map
```ts
const map = new Map([
  ["a", 1],
  ["b", 2],
  ["c", 3],
]);
const mapIterator = map[Symbol.iterator]();

console.log(mapIterator.next()); // { value: ["a", 1], done: false }
console.log(mapIterator.next()); // { value: ["b", 2], done: false }
console.log(mapIterator.next()); // { value: ["c", 3], done: false }
console.log(mapIterator.next()); // { value: undefined, done: true }

for (const value of map) {
  // ["a", 1], ["b", 2], ["c", 3]
  console.log(value);
}
```

<br>

#### Map의 entries() 메서드
```ts
const map = new Map([
  ["a", 1],
  ["b", 2],
  ["c", 3],
]);
const mapEntries = map.entries();

console.log(mapEntries.next()); // { value: ["a", 1], done: false }
console.log(mapEntries.next()); // { value: ["b", 2], done: false }
console.log(mapEntries.next()); // { value: ["c", 3], done: false }
console.log(mapEntries.next()); // { value: undefined, done: true }

const mapValues = map.values();
for (const value of mapValues) {
  console.log(value);
}

const mapKeys = map.keys();
for (const key of mapKeys) {
  // a, b, c
  console.log(key);
}
```

<br>

## 언어와 이터러블의 상호작용
### 전개 연산자와 이터러블
- 이터러블 객체의 모든 요소를 개별 요소로 확장하는데 사용함
- 배열이나 객체를 쉽게 복사하거나 병합이 가능함

```ts
// array 병합
const array = [1, 2, 3];
const array2 = [...array, 4, 5, 6];
console.log(array2); // [1, 2, 3, 4, 5, 6]

// set -> array 변환
const set = new Set([1, 2, 3]);
const array3 = [...set];
console.log(array3); // [1, 2, 3]

// 전개 연산자로 인자를 펼쳐서 전달하기
const numbers = [1, 2, 3];

function sum(...nums: number[]) {
  return nums.reduce((acc, num) => acc + num, 0);
}

console.log(sum(...numbers)); // 6
```

<br>

### 구조 분해 할당과 이터러블
- 이터러블 객체의 요소들을 개별 변수에 할당하는 방법

```ts
// 구조 분해 할당
const array = [1, 2, 3];
const [first, second] = array;
console.log(first, second); // 1, 2

// head, tail 추출
const array2 = [1, 2, 3, 4];
const [head, ...tail] = array2;
console.log(head, tail); // 1, [2, 3, 4]

// Map, for ... of, 구조 분해 할당
const map = new Map();
map.set("a", 1);
map.set("b", 2);
map.set("c", 3);

for (const [key, value] of map.entries()) {
  console.log(`${key}: ${value}`); // a: 1, b: 2, c: 3
  // a: 1
  // b: 2
  // c: 3
}
```

<br>

### 사용자 정의 이터러블과 전개 연산자
- 이터러블 프로토콜을 활용해서 자스/타스에서 데이터와 코드를 더욱 효율적으로 다룰수 있음

```ts
function* naturals(end = Infinity) {
  let n = 1;
  while (n <= end) {
    yield n++;
  }
}

const array = [0, ...naturals(4)];
console.log(array); // [0, 1, 2, 3, 4]
```

<br>

## 제너레이터로 만든 이터레이터도 이터러블
### 제너레이터로 만든 map 함수
- 함수를 이터레이터로 만들면 반환한은 항상 이터레이션 프로토콜을 만족함
- `next()`, `[Symbol.iterator]()`, `전개 연산자` 등 모두 사용이 가능함

```ts
function* map<A, B>(
  func: (value: A) => B,
  iterable: Iterable<A>
): IterableIterator<B> {
  for (const value of iterable) {
    yield func(value);
  }
}

const array = [1, 2, 3, 4];
const mapped: IterableIterator<number> = map((x) => x * 2, array);
const iterator = mapped[Symbol.iterator]();

console.log(mapped.next().value); // 2
console.log(iterator.next().value); // 4
console.log([...iterator]); // [6, 8]
```

<br>

### 제너레이터로 만든 이터레이터와 `for ... of`
- 제너레이터로 만든 이터레이터도 이터러블이므로 for ... of 문 사용이 가능함
- TS에서는 이러한 이터레이션 프로토콜을 통해서 다양한 프로그래밍 패러다임으로 전환하고 조합이 가능함
```ts
function* map<A, B>(
  func: (value: A) => B,
  iterable: Iterable<A>
): IterableIterator<B> {
  for (const value of iterable) {
    yield func(value);
  }
}

function* naturals(end = Infinity) {
  let n = 1;
  while (n <= end) {
    yield n++;
  }
}

let acc = 0;
for (const num of map((x) => x * 2, naturals(4))) {
  acc += num;
}
console.log(acc); // 2 + 4 + 6 + 8 = 20
```