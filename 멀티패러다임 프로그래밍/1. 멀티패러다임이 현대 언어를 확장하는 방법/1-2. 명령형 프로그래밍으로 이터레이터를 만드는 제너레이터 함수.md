## 제너레이터 기본 문법
- 제너레이터는 명령형 스타일로 이터레이터를 작성할 수 있게 해주는 문법
- `function*` 키워드로 정의되며 곧바로 실행되지 않고 이터레이터 객체를 반환함
- 해당 객체를 통해서 함수의 실행 흐름을 외부에서 제어가 가능함

<br>

### yield와 next()
- 함수가 반환한 이터레이터에 대해서 `next()` 메소드 호출시 제너레이터 함수의 본문의 `yield`를 만날 때까지 실행됨
- `yield` 키워드를 통해 외부로 값을 반환하고 이후에 `next()`를 다시 호출하면 이전 실행 지점부터 이어서 함수가 재개됨
- `yield` + `next()` 조합으로 함수 내부 상태를 유지해서 순차적으로 값을 반환하는 구조를 쉽게 구현할 수 있음

<br>

#### 예시
- done 속성이 true가 될 떄까지 제너레이터는 yield 키워드가 있는 지점까지 실행함
- 이후에 값을 반환하고 일시 중지하는 과정을 반복하게됨

```ts
function* generator() {
  yield 1;
  console.log("hi");
  yield 2;
  yield 3;
}

const iter = generator();

console.log(iter.next()); // { value: 1, done: false }
console.log(iter.next()); // hi, { value: 2, done: false }
console.log(iter.next()); // { value: 3, done: false }
```

<br>

### 제너레이터와 제어문
- 명령형으로 구현하기 때문에 조건문 사용이 가능함
- 제너레이터 내부에서 if문을 사용해서 이터레이터가 리스트를 만드는 로직 제어가 가능함

```ts
function* generator(condition: boolean) {
  yield 1;
  if (condition) {
    yield 2;
  }
  yield 3;
}

const iter1 = generator(false);
console.log(iter1.next()); // { value: 1, done: false }
console.log(iter1.next()); // { value: 3, done: false }
console.log(iter1.next()); // { value: undefined, done: true }

const iter2 = generator(true);
console.log(iter2.next()); // { value: 1, done: false }
console.log(iter2.next()); // { value: 2, done: false }
console.log(iter2.next()); // { value: 3, done: false }
console.log(iter2.next()); // { value: undefined, done: true }
```

<br>

### yield* 키워드
- `yield*` 키워드는 제너레이터 함수 안에서 이터러블을 순회해서 해당 이터러블이 제공하는 요소들을 순차적으로 반환하게 해줌
- 배열은 자스에서 이터러블로 간주되며 for..of, ..., yield* 를 통해서도 순회가 가능함

```ts
function* generator() {
  yield 1;
  yield* [2, 3];
  yield 4;
}

const iter = generator();
console.log(iter.next()); // { value: 1, done: false }
console.log(iter.next()); // { value: 2, done: false }
console.log(iter.next()); // { value: 3, done: false }
console.log(iter.next()); // { value: 4, done: false }
console.log(iter.next()); // { value: undefined, done: true }
```

<br>

### naturals 제너레이터 함수
- 무한 시퀀스를 생성하는 제너레이터 함수임
- 무한 루프를 사용하지만 iter.next()를 호출할 때만 n을 반환하고 다시 일시 중지해서 프로세스나 브라우저가 안멈춤
- 결국 제너레이터는 코드를 지연시켜서 실행한다고 할 수 있음
```ts
function* naturals() {
  let n = 1;
  while (true) {
    yield n++;
  }
}

const iter = naturals();

for (let i = 0; i < 10; i++) {
  // 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
  console.log(iter.next().value);
}
```

<br>

## 제너레이터로 작성한 reverse 함수
```ts
function* reverse<T>(arrLike: ArrayLike<T>): Iterator<T> {
  let index = arrLike.length;

  while (index) {
    yield arrLike[--index];
  }
}

const array = ["A", "B", "C", "D", "E", "F"];
const reversed = reverse(array);

console.log(reversed.next().value); // F
console.log(reversed.next().value); // E
console.log(reversed.next().value); // D
console.log(reversed.next().value); // C
console.log(reversed.next().value); // B
console.log(reversed.next().value); // A
console.log(reversed.next().value); // undefined
```