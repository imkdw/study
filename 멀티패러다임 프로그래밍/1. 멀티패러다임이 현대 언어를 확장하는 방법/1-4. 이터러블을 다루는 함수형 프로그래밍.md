## forEach 함수
- 함수와 이터러블을 받아서 이터러블을 순회하면서 각 요소에 인자로 받은 함수를 적용하는 고차 함수

<br>

### for...of 활용하기
```ts
function forEach<T>(f: (value: T) => void, iterable: Iterable<T>): void {
  for (const value of iterable) {
    f(value);
  }
}

const array = [1, 2, 3];
forEach(console.log, array); // 1, 2, 3
```

<br>

### while 활용하기
```ts
function forEach<T>(f: (value: T) => void, iterable: Iterable<T>): void {
  const iterator = iterable[Symbol.iterator]();
  let result = iterator.next();
  while (!result.done) {
    f(result.value);
    result = iterator.next();
  }
}

// Set도 iterable 이므로 forEach 함수 사용이 가능함
const set = new Set([4, 5, 6]);
forEach(console.log, set); // 4, 5, 6
```

<br>

## map 함수
- map 함수는 이터러블을 인자로 받아서 이터레이터를 결과로 반환하게됨
- 반환 결과는 동시에 이터러블이기 때문에 전개 연산자, for...of로 순회가 가능함

```ts
function forEach<T>(f: (value: T) => void, iterable: Iterable<T>): void {
  for (const value of iterable) {
    f(value);
  }
}

function* map<A, B>(
  f: (value: A) => B,
  iterable: Iterable<A>
): IterableIterator<B> {
  for (const value of iterable) {
    yield f(value);
  }
}

const array = [1, 2, 3, 4];
const mapped = map((x) => x * 2, array);
console.log([...mapped]); // [2, 4, 6, 8]

const mapped2 = map((x) => x * 3, array);
forEach(console.log, mapped2); // 3, 6, 9, 12
```

```ts
function* map<A, B>(
  f: (value: A) => B,
  iterable: Iterable<A>
): IterableIterator<B> {
  const iterator = iterable[Symbol.iterator]();
  while (true) {
    const { value, done } = iterator.next();

    if (done) {
      break;
    }

    yield f(value);
  }
}

const mapped = map(
  ([k, v]) => `${k}:${v}`,
  new Map([
    ["a", 1],
    ["b", 2],
  ])
);

forEach(console.log, mapped); // a:1, b:2
```

<br>

## filter 함수
- 이터러블의 각 요소에 대해 조건을 확인해서 해당 조건을 만족하는 요소들만 반환하는 고차 함수
```ts
function* filter<T>(f: (value: T) => boolean, iterable: Iterable<T>) {
  for (const value of iterable) {
    // f에 만족하는 항목에 대해서만 데이터를 반환함
    if (f(value)) {
      yield value;
    }
  }
}

const array = [1, 2, 3, 4, 5];
const filtered = filter((x) => x % 2 === 0, array);
console.log([...filtered]); // [2, 4]
```

<br>

## 고차 함수 조합하기
- 함수가 여러개 중첩되서 코드를 읽기 약간 불편할수도 있음
- 하지만 LISP 계열 언어에서는 흔히 사용하는 컨벤션임
- 오른쪽 아래 -> 왼쪽 위로 올라가면서 읽는다고 생각하면 더 쉽게 이해가 가능함

```ts
function* map<A, B>(
  func: (value: A) => B,
  iterable: Iterable<A>
): IterableIterator<B> {
  for (const value of iterable) {
    yield func(value);
  }
}

function* naturals(end = Infinity) {
  let n = 1;
  while (n <= end) {
    yield n++;
  }
}

function* filter<T>(f: (value: T) => boolean, iterable: Iterable<T>) {
  for (const value of iterable) {
    if (f(value)) {
      yield value;
    }
  }
}

function forEach(f: (value: unknown) => void, iterable: Iterable<unknown>) {
  for (const value of iterable) {
    f(value);
  }
}

forEach(
  console.log,
  map(
    (x) => x * 10,
    filter((x) => x % 2 === 1, naturals(5))
  )
); // 10, 30, 50
```

<br>

## 재미난 filter
- 아래 함수는 각 요소를 단일 배열로 감싸고 `Array.prototype.filter` 메서드를 호출해서 필터링을 수행함 (if문 대체)
- 이런 방식도 지연 평가를 지원하고 기존 방식과 시간 복잡도는 본직적으로 동일함
- 이터레이션 프로토콜을 특수하게 조합한 접근 방식임
```ts
function* filter<T>(
  f: (value: T) => boolean,
  iterable: Iterable<T>
): IterableIterator<T> {
  for (const value of iterable) {
    yield* [value].filter(f);
  }
}

const array = [1, 2, 3, 4, 5];
const filtered = filter((x) => x % 2 === 0, array);
console.log([...filtered]); // [2, 4]
```