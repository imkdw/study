## Web API의 NodeList도 이터러블
- NodeList는 문서 내의 노드들을 컬렉션 형태로 나타내며 이터러블 프로토콜을 따름

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <ul>
      <li>1</li>
      <li>2</li>
      <li>3</li>
      <li>4</li>
      <li>5</li>
    </ul>
    <script>
      function* map(func, iterable) {
        for (const value of iterable) {
          yield func(value);
        }
      }

      function* naturals(end = Infinity) {
        let n = 1;
        while (n <= end) {
          yield n++;
        }
      }

      function* filter(f, iterable) {
        for (const value of iterable) {
          if (f(value)) {
            yield value;
          }
        }
      }

      function forEach(f, iterable) {
        for (const value of iterable) {
          f(value);
        }
      }

      const nodeList = document.querySelectorAll("li");

      // 1, 3, 5
      forEach(
        console.log,
        filter(
          (x) => x % 2 === 1,
          map((node) => parseInt(node.textContent, 10), nodeList)
        )
      );

      // 2, 4번 li 삭제됨
      forEach(
        (element) => element.remove(),
        filter((node) => parseInt(node.textContent, 10) % 2 === 0, nodeList)
      );
    </script>
  </body>
</html>
```

<br>

## 상속이 아닌 인터페이스로 해결해야 하는 이유
### 이터러블을 사용하는 이유
- 자바스크립트의 배열은 map, filter, forEach 등의 고차함수를 지원함
- 하지만 위 HTML 예제에서 `NodeList`의 경우 배열이 아니며 정의가 다르게 되어있음
- 이터레이션 프로토콜에 기반하여 위 예제처럼 사용할 경우 적용이 가능함

<br>

#### NodeList에 사용 불가능한 map 함수
```js
const nodes = document.querySelectorAll("li");

/**
 * li (1), li(2), 5
 */
console.log(nodes[0], nodes[1], nodes.length);

/**
 * Uncaught TypeError: nodes.map is not a function
 */
nodes.map((node) => node.textContent);
```

<br>

#### NodeList 정의
```ts
/**
 * **`NodeList`** objects are collections of nodes, usually returned by properties such as Node.childNodes and methods such as document.querySelectorAll().
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/NodeList)
 */
interface NodeList {
    /**
     * The **`NodeList.length`** property returns the number of items in a NodeList.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/NodeList/length)
     */
    readonly length: number;
    /**
     * Returns a node from a `NodeList` by index.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/NodeList/item)
     */
    item(index: number): Node | null;
    forEach(callbackfn: (value: Node, key: number, parent: NodeList) => void, thisArg?: any): void;
    [index: number]: Node;
}
```

<br>

### 순회가 필요한 자료구조인데 Array를 상속받지 않은 이유
- OOP에서 코드를 추상화하고 기능을 제공하는 좋은 도구를 `상속`이 존재함
- 하지만 자스의 표준 라이브러리에선 `Array`를 상속받은 내장 클래스는 존재하지 않음
- Map, Set 등 이들은 모두 서로 다른 자료구조를 나타내고 각각 고유한 특성과 동작을 갖도록 설계되어있음
- 이처럼 구조적 차이가 있는 자료구조들을 Array의 특성과 동작 방식에 맞추기 위해 상속하는건 부자연 & 비효율적임

<br>

### NodeList는 index, length를 가진 ArrayLike인데 상속받지 않은 이유
- NodeList에는 Live, Static 두 가지 모드가 있는데 라이브는 DOM이 변경될 때 자동으로 업데이트됨
- 하지만 Array는 생성된 이후에는 정적이며 항상 수동으로 요소를 추가 / 제거해야함
- 결국 상속을 사용하지 않은 이유는 용도가 다른 객체들의 의존성을 가지면 불필요한 복잡성 발생 & 최적화가 어렵기 때문임

<br>

### 공통 로직을 공유할 수 있는 방법
- 이터레이션 프로토콜을 활용하면 상속 없이도 다양한 자료구조를 일관성 있게 다룰 수 있음
- 각 자료구조의 특성을 유지하면서도 공통의 인터페이스를 통해 상호작용이 가능함
- 이처럼 인터페이스에 기반한 규약은 언어나 환경에 따라서 달라지는 다양한 구조를 포용할 수 있는 유연한 확장성을 제공함

<br>

## 인터페이스와 클래스 상속
- 인터페이스는 클래스/객체가 따라야 할 규약을 정의하고 이를 통해 동일한 방식으로 상호작용이 가능하도록함
- 상속은 기존 클래스의 속성과 클래스를 물려받아 새로운 클래스를 만드는 과정임
- 인터페이스와 클래스는 목적과 용도가 다름
  - 인터페이스 : 규약을 제시하고 다양한 클래스가 동일한 형식의 동작을 구현하도록 유도
    - 언어나 표준 라이브러리 설계 단계에서 자주 사용됨
  - 상속 : 공통 기능을 직접 구현하고 이를 적절히 확장하는데 초점을 둠
    - SDK나 앱 레벨에서 자주 사용됨