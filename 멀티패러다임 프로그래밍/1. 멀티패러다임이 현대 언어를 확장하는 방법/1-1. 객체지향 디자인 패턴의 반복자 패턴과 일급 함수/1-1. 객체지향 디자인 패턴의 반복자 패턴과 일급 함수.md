## GoF의 반복자 패턴
- 반복자 패턴은 객체지향 디자인 패턴 중 하나로 컬렉션의 요소를 순차적으로 접근하는 규약을 제시함
- 이러한 패턴은 컬렉션의 내부를 노출하는 대신 `next()` 같은 퍼블릭 메서드로 내부 요소에 접근할 수 있도록 설계됨
- 아래 코드의 경우 간결하게 축약된 형태임

```ts
/**
 * 반복자가 아직 완료되지 않음
 */
interface IteratorYieldResult<T> {
  done?: false;
  value: T;
}

/**
 * 반복자가 완료됨
 */
interface IteratorReturnResult {
  done: true;
  value: undefined;
}

/**
 * next()를 가진 인터페이스로 반복자가 완료됬거나 아직 완료되지 않았음을 반환
 */
interface Iterator<T> {
  next(): IteratorYieldResult<T> | IteratorReturnResult;
}
```

<br>

## ArrayLike로 부터 Iterator 생성하기
- 아래 코드는 배열을 받아서 iterator를 생성하는 코드임
- 실제 자바스크립트의 iteration 프로토콜을 사용하지 않았음
- 함수 + 객체리터럴로 좀 더 쉽게 구현도 가능하지만 전통적인 방식을 따른 코드임

```ts
class ArrayLikeIterator<T> implements Iterator<T> {
  private index = 0;

  constructor(private arrayLike: ArrayLike<T>) {}

  next(): IteratorResult<T> {
    if (this.index < this.arrayLike.length) {
      return {
        value: this.arrayLike[this.index++],
        done: false,
      };
    } else {
      return {
        value: undefined,
        done: true,
      };
    }
  }
}

const arrayLike: ArrayLike<number> = {
  0: 10,
  1: 20,
  2: 30,
  length: 3,
};

const iterator: Iterator<number> = new ArrayLikeIterator(arrayLike);

console.log(iterator.next()); // { value: 10, done: false }
console.log(iterator.next()); // { value: 20, done: false }
console.log(iterator.next()); // { value: 30, done: false }
console.log(iterator.next()); // { value: undefined, done: true }
```

<br>

### 다른 ArrayLike 생성하기
- ArrayLike는 0부터 시작하는 number 키와 length 속성을 가진 타입을 의미함
- 꼭 Array가 아니더라도 이 조건에 부합하는 다양한 컬렉션을 순회하는 객체를 만들 수 있음

```ts
const array: Array<string> = ["a", "b", "c"];
const iterator2: Iterator<string> = new ArrayLikeIterator(array);

console.log(iterator2.next()); // { value: 'a', done: false }
console.log(iterator2.next()); // { value: 'b', done: false }
console.log(iterator2.next()); // { value: 'c', done: false }
console.log(iterator2.next()); // { value: undefined, done: true }
```

<br>

## ArrayLike를 역순으로 순회하는 이터레이터 만들기
### Array의 reverse() 메소드
- 호출 시점에 원본 배열의 순서를 뒤집음
- 대규모 데이터 처리나 성능이 중요한 경우 불필요한 메모리 이동과 연산이 유발될 수 있음

```ts
const array = ["A", "B"];
array.reverse();
console.log(array[0], array[1]);
```

<br>

### 이터레이터의 지연성을 이용한 reverse 함수 만들기
- 실제 객체를 뒤집지 않고 배열 뒤집기가 가능함
- reverse 함수 호출 시점에는 아무일도 없지만 next()를 실행할 때 마다 배열을 역순으로 하나씩 효율적으로 꺼냄

```ts
function reverse<T>(arrayLike: ArrayLike<T>): Iterator<T> {
  let index = arrayLike.length;

  return {
    next() {
      if (index === 0) {
        return { value: undefined, done: true };
      } else {
        return { value: arrayLike[--index], done: false };
      }
    },
  };
}

const array = ["A", "B"];
const reversed = reverse(array);
console.log(array); // ["A", "B"]

console.log(reversed.next().value, reversed.next().value); // "B", "A"
```

<br>

## 지연 평가되는 map 함수
- map의 경우 `iterator<A>` 및 A -> B로 변환하는 `transform` 함수를 받아서 지연된 `iterator<B>`를 반환하게됨
- 이 때 일급 함수와 고차 함수는 함수형 프로그래밍 패러다임의 핵심적인 구송 요소임
  - 일급 함수 : 함수를 값처럼 다루어 변수에 담거나 다른 함수의 인자로 전달, 함수의 반환값으로 사용할 수 있는 함수
  - 고차 함수 : 하나 이상의 함수를 인자로 받거나 반환하는 함수
- 반복자 패턴의 지연성은 지연 평가가 가능한 객체를 생성할 수 있게 해주고 일급 함수를 고차 함수를 정의할 수 있게 해줌

```ts
function reverse<T>(arrayLike: ArrayLike<T>): Iterator<T> {
  let index = arrayLike.length;

  return {
    next() {
      if (index === 0) {
        return { value: undefined, done: true };
      } else {
        return { value: arrayLike[--index], done: false };
      }
    },
  };
}

function map<A, B>(
  transform: (value: A) => B,
  iterator: Iterator<A>
): Iterator<B> {
  return {
    next(): IteratorResult<B> {
      const { value, done } = iterator.next();
      return done ? { value, done } : { value: transform(value), done: false };
    },
  };
}

const array = ["A", "B", "C", "D", "E", "F"];
const iterator = map((str: string) => str.toLowerCase(), reverse(array));
console.log(iterator.next().value, iterator.next().value);  // "f", "e"
```