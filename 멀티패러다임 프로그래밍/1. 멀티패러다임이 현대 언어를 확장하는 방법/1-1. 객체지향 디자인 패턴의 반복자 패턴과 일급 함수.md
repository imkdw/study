## GoF의 반복자 패턴
- 반복자 패턴은 객체지향 디자인 패턴 중 하나로 컬렉션의 요소를 순차적으로 접근하는 규약을 제시함
- 이러한 패턴은 컬렉션의 내부를 노출하는 대신 `next()` 같은 퍼블릭 메서드로 내부 요소에 접근할 수 있도록 설계됨
- 아래 코드의 경우 간결하게 축약된 형태임

```ts
/**
 * 반복자가 아직 완료되지 않음
 */
interface IteratorYieldResult<T> {
  done?: false;
  value: T;
}

/**
 * 반복자가 완료됨
 */
interface IteratorReturnResult {
  done: true;
  value: undefined;
}

/**
 * next()를 가진 인터페이스로 반복자가 완료됬거나 아직 완료되지 않았음을 반환
 */
interface Iterator<T> {
  next(): IteratorYieldResult<T> | IteratorReturnResult;
}
```

<br>

## ArrayLike로 부터 Iterator 생성하기
- 아래 코드는 배열을 받아서 iterator를 생성하는 코드임
- 실제 자바스크립트의 iteration 프로토콜을 사용하지 않았음
- 함수 + 객체리터럴로 좀 더 쉽게 구현도 가능하지만 전통적인 방식을 따른 코드임

```ts
class ArrayLikeIterator<T> implements Iterator<T> {
  private index = 0;

  constructor(private arrayLike: ArrayLike<T>) {}

  next(): IteratorResult<T> {
    if (this.index < this.arrayLike.length) {
      return {
        value: this.arrayLike[this.index++],
        done: false,
      };
    } else {
      return {
        value: undefined,
        done: true,
      };
    }
  }
}

const arrayLike: ArrayLike<number> = {
  0: 10,
  1: 20,
  2: 30,
  length: 3,
};

const iterator: Iterator<number> = new ArrayLikeIterator(arrayLike);

console.log(iterator.next()); // { value: 10, done: false }
console.log(iterator.next()); // { value: 20, done: false }
console.log(iterator.next()); // { value: 30, done: false }
console.log(iterator.next()); // { value: undefined, done: true }
```

<br>

### 다른 ArrayLike 생성하기
- ArrayLike는 0부터 시작하는 number 키와 length 속성을 가진 타입을 의미함
- 꼭 Array가 아니더라도 이 조건에 부합하는 다양한 컬렉션을 순회하는 객체를 만들 수 있음

```ts
const array: Array<string> = ["a", "b", "c"];
const iterator2: Iterator<string> = new ArrayLikeIterator(array);

console.log(iterator2.next()); // { value: 'a', done: false }
console.log(iterator2.next()); // { value: 'b', done: false }
console.log(iterator2.next()); // { value: 'c', done: false }
console.log(iterator2.next()); // { value: undefined, done: true }
```