## 비동기 프로그래밍
- 특정 작업이 완료될 때 까지 기다리지 않고 다른 작업을 계속 수행하는 프로그래밍 방식
- 프로그램이 동시에 여러개의 작업 수행이 가능해서 효율성이 높음
- 자스의 경우 대부분 싱글 스레드 기반의 비동기 IO를 통해 프로그램의 동시 실행을 제어함

<br>

## Promise
- 비동기 작업의 성공 또는 실패를 처리하는데 사용하며 비동기 작업의 결과를 값으로 다룰 수 있게 해주는 객체이자 규약
- 비동기 상황을 타입 수준에서 다룰 수 있음
- 생성 즉시 대기(pending) 상태, 작업이 성공하면 이행(fulfilled) 상태, 작업이 실패하면 거부(rejected) 상태가 됨

<br>

### Promise를 반환하는 delay 함수
#### 딜레이 함수 구현 예제
```ts
/**
 * 버전 1
 */
function delay1<T>(time: number, value: T): Promise<T> {
  return new Promise((resolve) => setTimeout(() => resolve(value), time));
}

/**
 * 좀 더 심플한 버전
 */
function delay2<T>(time: number, value: T): Promise<T> {
  return new Promise((resolve) => setTimeout(resolve, time, value));
}
```

<br>

#### delay 함수 사용하기
```ts
function delay<T>(time: number, value: T): Promise<T> {
  return new Promise((resolve) => setTimeout(resolve, time, value));
}

/**
 * then 방식으로 비동기 처리
 */
function testWithThen() {
  console.time("TEST_1");

  delay(1000, "Hello")
    .then((result) => console.log(result))
    .then(() => delay(2000, 40))
    .then((result) => {
      console.log(result);
      console.timeEnd("TEST_1");
    });
}

/**
 * await 방식으로 비동기 처리
 */
async function testWithAwait() {
  console.time("TEST_2");
  const result = await delay(1000, "Hello");
  console.log(result);
  const result2 = await delay(2000, 40);
  console.log(result2);
  console.timeEnd("TEST_2");
}

testWithThen();
// Hello
// 40
// TEST: 3.004s

testWithAwait();
// Hello
// 40
// TEST: 3.005s
```

<br>

## new Promise()를 직접 사용해본적이 있는가
- 최근 들어서는 직접 `new Promise()`를 통해서 비동기를 제어하는 일이 많지는 않음
- 현재는 대부분의 서드파티 라이브러리에서 Promise 기반의 인터페이스를 제공하고 있음
- `new Promise()`를 많이 다뤄봤다는 것은 주어진 환경을 소비하는 수준을 넘어서 비동기 제어에 관한 깊이 있는 이해와 문제 해결 능력을 갖추고 있다고 봐도됨
- 하지만 아직 여전히 일부 케이스에선 직접 new Promise()를 통한 처리가 필요함
  - 병렬로 비동기 작업을 실행하면서 동시 실행 개수 제어하기
  - 애니메이션과 데이터 요청 동시성 핸들링
  - 파일 스트림 및 제너레이터 결합 사용
  - 등등..

<br>

## Promise.race
- 병렬로 실행된 여러 Promise 중에서 가장 먼저 완료된 Promise의 결과나 에러를 반환함

```ts
async function test() {
  const promise1 = new Promise((res) => setTimeout(res, 500, "one"));
  const promise2 = new Promise((res) => setTimeout(res, 100, "two"));

  await Promise.race([promise1, promise2]).then((result) => {
    console.log(result); // two
  });
}

test();
```

<br>

## IO 작업에 타임아웃 설정하기
- 아래 예제는 친구 목록을 가져오는 API 응답이 5초 이상 지연되는 경우 타임아웃을 처리하는 방법임
- 요즘은 AbortController가 추가되어서 fetch와 함께 사용이 가능ㅎ라지만 Promise.race를 통해서도 제어가 가능함

```ts
const delay = <T>(time: number, value: T): Promise<T> => new Promise((resolve) => setTimeout(resolve, time, value));

type User = { name: string };

function getRandomValue<T>(a: T, b: T): T {
  const randomIndex = Math.floor(Math.random() * 2);
  return randomIndex === 0 ? a : b;
}

async function getFriends(): Promise<User[]> {
  return delay(getRandomValue(60, 6_000), [
    { name: "John" },
    { name: "Jane" },
    { name: "Jim" },
    { name: "Jill" },
    { name: "Jack" },
  ]);
}

async function test() {
  const result = await Promise.race([getFriends(), delay(5000, "timeout")]);

  if (result === "timeout") {
    console.log("네트워크 환경이 좋지 않음");
  } else {
    console.log("친구 목록 조회 완료", result);
  }
}

test();
```

<br>

## 응답 속에 따른 전략으로 UI 렌더링하기
- 100ms 보다 친구 목록이 빠르게 렌더링되면 즉시 친구 목록을 보여줌
- 하지만 만약 100ms 보다 오래 걸린다면 로딩 인디케이터를 띄우고 로딩이 완료되면 화면을 갱신함
- 위 같은 요구사항에서 Promise.race를 사용하면 쉽게 구현이 가능함
- 아래 방식처럼 Promise는 변수에 담거나, 함수에 전달하거나, 원할 떄 꺼내서 사용하는 등 원하는 실행 타이밍에 대기를 거는 방식으로 값으로 다룰 수 있음

```ts
const delay = <T>(time: number, value: T): Promise<T> => new Promise((resolve) => setTimeout(resolve, time, value));

type User = { name: string };

function getRandomValue<T>(a: T, b: T): T {
  const randomIndex = Math.floor(Math.random() * 2);
  return randomIndex === 0 ? a : b;
}

async function getFriends(): Promise<User[]> {
  return delay(getRandomValue(60, 6_000), [
    { name: "John" },
    { name: "Jane" },
    { name: "Jim" },
    { name: "Jill" },
    { name: "Jack" },
  ]);
}

function toggleLoadingIndicator(show: boolean): void {
  if (show) {
    console.log("Append Loading...");
  } else {
    console.log("Remove Loading...");
  }
}

async function renderFriendsPicker(): Promise<void> {
  const friendsPromise = getFriends();

  const result = await Promise.race([friendsPromise, delay(100, "isSlow")]);

  if (result === "isSlow") {
    toggleLoadingIndicator(true);
    await friendsPromise;
    toggleLoadingIndicator(false);
  }

  const friends = await friendsPromise;
  console.log(`친구 목록 렌더링: ${friends.map((friend) => friend.name).join(", ")}`);
}

async function test() {
  // Append Loading...
  // Remove Loading...
  // 친구 목록 렌더링: John, Jane, Jim, Jill, Jack
  await renderFriendsPicker();

  // 친구 목록 렌더링: John, Jane, Jim, Jill, Jack
  await renderFriendsPicker();
}

test();
```

<br>

## Promise.all
- 주어진 모든 Promise가 이행될 때 까지 기다렸다가 모든 결과를 배열로 반환하는 함수
- 하나라도 거부된다면 즉시 거부되고 거부된 이유를 반환함
- 여러 비동기 작업을 병렬로 실행하고 모든 작업이 완료될 때까지 기다릴 때 유용함

```ts
const delay = <T>(time: number, value: T): Promise<T> => new Promise((resolve) => setTimeout(resolve, time, value));

type MyFile = {
  name: string;
  body: string;
  size: number;
};

async function getFile(name: string, size = 1000): Promise<MyFile> {
  return delay<MyFile>(size, { name, body: "...", size });
}

async function init() {
  console.time("init");
  const files = await Promise.all([getFile("file1", 500), getFile("file2", 1000), getFile("file3", 1500)]);
  console.timeEnd("init");
  console.log(files);

  //   init: 1.502s
  //   [
  //     { name: 'file1', body: '...', size: 500 },
  //     { name: 'file2', body: '...', size: 1000 },
  //     { name: 'file3', body: '...', size: 1500 }
  //   ]
}

init();
```

<br>

### 프로미스가 하나라도 거부된다면
```ts
const delay = <T>(time: number, value: T): Promise<T> => new Promise((resolve) => setTimeout(resolve, time, value));

type MyFile = {
  name: string;
  body: string;
  size: number;
};

async function getFile(name: string, size = 1000): Promise<MyFile> {
  return delay<MyFile>(size, { name, body: "...", size });
}

async function init() {
  console.time("init");

  try {
    const files = await Promise.all([
      getFile("file1"),
      getFile("file2"),
      getFile("file3"),
      delay(500, "dummy").then(() => Promise.reject("다운로드 실패")),
    ]);
    console.log(files);
    console.timeEnd("init");
  } catch (error) {
    // 다운로드 실패
    console.error(error);
  }
}

init();
```

## Promise.allSettled
- 주어진 모든 Promise가 완료될 때 까지 기다렸다가 각 Promise의 성공 결과나 실패 결과를 객체로 담아 반환
- 모든 Promise의 완료상태를 확인하고싶을때 유용함
- Promise.all이랑 사용 목적이 다른것에 주의해야하며 에러가 전파되는 것을 원할 떄는 Promise.all을 사용해야함

```ts
const delay = <T>(time: number, value: T): Promise<T> => new Promise((resolve) => setTimeout(resolve, time, value));

type MyFile = {
  name: string;
  body: string;
  size: number;
};

async function getFile(name: string, size = 1000): Promise<MyFile> {
  return delay<MyFile>(size, { name, body: "...", size });
}

async function init() {
  console.time("init");

  const files = await Promise.allSettled([
    getFile("file1"),
    getFile("file2"),
    getFile("file3"),
    delay(500, "dummy").then(() => Promise.reject("다운로드 실패")),
  ]);

  // [
  //   {
  //     status: 'fulfilled',
  //     value: { name: 'file1', body: '...', size: 1000 }
  //   },
  //   {
  //     status: 'fulfilled',
  //     value: { name: 'file2', body: '...', size: 1000 }
  //   },
  //   {
  //     status: 'fulfilled',
  //     value: { name: 'file3', body: '...', size: 1000 }
  //   },
  //   { status: 'rejected', reason: '다운로드 실패' }
  // ]
  console.log(files);

  console.timeEnd("init");
}

init();
```

<br>

### ES11 이전에 이러한 상황을 직접 다루는 방법
- Promise.allSettled 는 ES11에 추가되었으며 아래는 ES11 이전에 이러한 상황을 직접 다루는 방법임
- 아래 방법은 Promise를 함수형 고차 함수와 함께 값으로 다루는 방법임

```ts
const delay = <T>(time: number, value: T): Promise<T> => new Promise((resolve) => setTimeout(resolve, time, value));

type MyFile = {
  name: string;
  body: string;
  size: number;
};

async function getFile(name: string, size = 1000): Promise<MyFile> {
  return delay<MyFile>(size, { name, body: "...", size });
}

const settlePromise = <T>(promise: Promise<T>) =>
  promise.then((value) => ({ status: "fulfilled", value })).catch((reason) => ({ status: "rejected", reason }));

async function init() {
  console.time("init");

  const files = await Promise.all(
    [
      getFile("file1"),
      getFile("file2"),
      getFile("file3"),
      delay(500, "dummy").then(() => Promise.reject("다운로드 실패")),
    ].map(settlePromise)
  );

  // [
  //   {
  //     status: 'fulfilled',
  //     value: { name: 'file1', body: '...', size: 1000 }
  //   },
  //   {
  //     status: 'fulfilled',
  //     value: { name: 'file2', body: '...', size: 1000 }
  //   },
  //   {
  //     status: 'fulfilled',
  //     value: { name: 'file3', body: '...', size: 1000 }
  //   },
  //   { status: 'rejected', reason: '다운로드 실패' }
  // ]
  // init: 1.002s
  console.log(files);

  console.timeEnd("init");
}

init();
```

<br>

## Promise.any
- 여러 Promise 중에서 가장 먼저 `이행(성공)`된 Promise의 값을 반환함
- Promise.race는 가장 먼저 완료된 Promise를 `이행(성공)`되는 `거부(실패)`되든 상관없이 즉시 그 결과나 에러를 반환함
- 하지만 모든 Promise가 거부된 경우는 거부된 모든 이유를 포함하는 단일 에러를 반환함

<br>

### 여러개 중에 하나가 먼저 성공한 경우
```ts
async function init() {
  console.time("init");

  const files = await Promise.any([
    getFile("file1", 1500),
    getFile("file2", 900),
    getFile("file3", 700),
    delay(500, "dummy").then(() => Promise.reject("다운로드 실패")),
  ]);

  // { name: 'file3', body: '...', size: 700 }
  // init: 702.18ms
  console.log(files);

  console.timeEnd("init");
}
```

<br>

### 모든 Promise가 거부된 경우
```ts
console.time("init");

const files = await Promise.any([
  getFile("file3", 700),
  delay(500, "dummy").then(() => Promise.reject("다운로드 실패")),
  delay(500, "dummy").then(() => Promise.reject("다운로드 실패")),
]);

// node:internal/process/promises:394
//  triggerUncaughtException(err, true /* fromPromise */);
//  ^

// [AggregateError: All promises were rejected] {
//   [errors]: [ '다운로드 실패', '다운로드 실패' ]
// }
console.log(files);

console.timeEnd("init");
```