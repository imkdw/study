function* naturals(end = Infinity): IterableIterator<number> {
  let n = 1;
  while (n <= end) {
    yield n++;
  }
}

function* map<A, B>(f: (a: A) => B, iterable: Iterable<A>): IterableIterator<B> {
  const iterator = iterable[Symbol.iterator]();

  while (true) {
    const { done, value } = iterator.next();
    if (done) {
      break;
    }

    yield f(value);
  }
}

function forEach<A>(f: (a: A) => void, iterable: Iterable<A>): void {
  for (const a of iterable) {
    f(a);
  }
}

function* filter<A>(f: (a: A) => boolean, iterable: Iterable<A>): IterableIterator<A> {
  const iterator = iterable[Symbol.iterator]();
  while (true) {
    const { done, value } = iterator.next();
    if (done) break;
    if (f(value)) yield value;
  }
}

function baseReduce<A, Acc>(f: (acc: Acc, a: A) => Acc, acc: Acc, iterator: Iterator<A>): Acc {
  while (true) {
    const { done, value } = iterator.next();
    if (done) {
      break;
    }
    acc = f(acc, value);
  }

  return acc;
}

function reduce<A, Acc>(f: (acc: Acc, a: A) => Acc, acc: Acc, iterable: Iterable<A>): Acc;
function reduce<A, Acc>(f: (a: A, b: A) => Acc, iterable: Iterable<A>): Acc;
function reduce<A, Acc>(f: (a: Acc | A, b: A) => Acc, accOrIterable: Acc | Iterable<A>, iterable?: Iterable<A>): Acc {
  if (!iterable) {
    const iterator = (accOrIterable as Iterable<A>)[Symbol.iterator]();
    const { done, value: acc } = iterator.next();
    if (done) {
      throw new TypeError("'reduce' of empty iterable with no initial value");
    }

    return baseReduce(f, acc, iterator) as Acc;
  } else {
    return baseReduce(f, accOrIterable as Acc, iterable[Symbol.iterator]()) as Acc;
  }
}

function* take<A>(limit: number, iterable: Iterable<A>): IterableIterator<A> {
  const iterator = iterable[Symbol.iterator]();
  while (true) {
    const { done, value } = iterator.next();
    if (done) {
      break;
    }

    yield value;
    if (--limit === 0) {
      break;
    }
  }
}

function head<A>(iterable: Iterable<A>): A | undefined {
  return iterable[Symbol.iterator]().next().value;
}

function every<A>(f: (a: A) => boolean, iterable: Iterable<A>): boolean {
  return accumulateWith(
    (a, b) => a && b,
    true,
    (a) => !a,
    f,
    iterable
  );
}

function some<A>(f: (a: A) => boolean, iterable: Iterable<A>): boolean {
  return accumulateWith(
    (a, b) => a || b,
    false,
    (a) => a,
    f,
    iterable
  );
}

function* concat<A>(...iterables: Iterable<A>[]): IterableIterator<A> {
  for (const iterable of iterables) {
    yield* iterable;
  }
}

function find<A>(f: (a: A) => boolean, iterable: Iterable<A>): A | undefined {
  return fx(iterable).filter(f).to(head);
}

function accumulateWith<A>(
  accumulator: (a: boolean, b: boolean) => boolean,
  acc: boolean,
  taking: (a: boolean) => boolean,
  f: (a: A) => boolean,
  iterable: Iterable<A>
): boolean {
  return fx(iterable).map(f).filter(taking).take(1).reduce(accumulator, acc);
}

const delay = <T>(time: number, value: T): Promise<T> => new Promise((resolve) => setTimeout(resolve, time, value));

function* chunk<T>(size: number, iterable: Iterable<T>): IterableIterator<T[]> {
  const iterator = iterable[Symbol.iterator]();
  while (true) {
    const arr = [
      ...take(size, {
        [Symbol.iterator]() {
          return iterator;
        },
      }),
    ];

    if (arr.length) yield arr;
    if (arr.length < size) break;
  }
}

type MyFile = {
  name: string;
  body: string;
  size: number;
};

async function fromAsync<T>(iterable: Iterable<Promise<T>> | AsyncIterable<T>): Promise<T[]> {
  const arr: T[] = [];
  for await (const a of iterable) {
    arr.push(a);
  }

  return arr;
}

const executeWithLimit = async <T>(fs: (() => Promise<T>)[], limit: number): Promise<T[]> =>
  fx(fs)
    .map((f) => f()) // [[P<T>, P<T>, P<T>, ...]] 비동기 함수를 실행
    .chunk(limit) // [[() => Promise<T>,() => Promise<T>], ...]] 처럼 N개씩 그룹화를 진행
    .map((ps) => Promise.all(ps)) // [P<[T, T, T, ...]>, P<[T, T, T, ...]>] 처럼 N개씩 대기하도록 Promise.all로 감싸기
    .to(fromAsync) // P<[[T, T, T, ...]]> 처럼 Promise.all 결과 꺼내기
    .then((arr) => arr.flat()); // P<[T, T, T,...]> 처럼 결과 평탄화

async function getFile(name: string, size = 1000): Promise<MyFile> {
  console.log(`${name} 파일 다운로드 시작`);
  return delay<MyFile>(size, { name, body: "...", size });
}

class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}

  map<B>(f: (a: A) => B): FxIterable<B> {
    return fx(map(f, this));
  }

  filter(f: (a: A) => boolean): FxIterable<A> {
    return fx(filter(f, this));
  }

  forEach(f: (a: A) => void): void {
    return forEach(f, this);
  }

  reduce<Acc>(f: (acc: Acc, a: A) => Acc, acc: Acc): Acc;
  reduce<Acc>(f: (a: A, b: A) => Acc): Acc;
  reduce<Acc>(f: (a: Acc | A, b: A) => Acc, acc?: Acc): Acc {
    return !acc ? reduce(f, this) : reduce(f, acc, this);
  }

  [Symbol.iterator]() {
    return this.iterable[Symbol.iterator]();
  }

  reject(f: (a: A) => boolean): FxIterable<A> {
    return this.filter((a) => !f(a));
  }

  to<R>(converter: (iterable: Iterable<A>) => R): R {
    return converter(this.iterable);
  }

  chain<B>(f: (iterable: Iterable<A>) => Iterable<B>): FxIterable<B> {
    return fx(f(this));
  }

  take(limit: number): FxIterable<A> {
    return fx(take(limit, this));
  }

  chunk(size: number): FxIterable<A[]> {
    return fx(chunk(size, this));
  }
}

const fx = <A>(iterable: Iterable<A>): FxIterable<A> => new FxIterable(iterable);

async function* stringsAsyncTest(): AsyncIterableIterator<string> {
  yield delay(1000, "a");
  const b = await delay(500, "b");
  yield b;
}

/**
 * 동기적인 값 T 또는 Promise<T>가 포함된 iterable를 인자로 받음
 * 반환값은 AsyncIterable<Awaited<T>>로써 함수 내부에서 Symbol.asyncIterator 메서드를 구현해서 비동기 반복자를 반환함
 * 반환한 비동기 반복자의 next() 메서드는 내부의 iterator.next 메서드를 호출해서 값을 가져옴
 */
// function toAsync<T>(iterable: Iterable<T | Promise<T>>): AsyncIterable<Awaited<T>> {
//   return {
//     [Symbol.asyncIterator](): AsyncIterator<Awaited<T>> {
//       const iterator = iterable[Symbol.iterator]();
//       return {
//         async next() {
//           const { done, value } = iterator.next();
//           return done ? { done, value } : { done: false, value: await value };
//         },
//       };
//     },
//   };
// }

async function* toAsync<T>(iterable: Iterable<T | Promise<T>>): AsyncIterableIterator<Awaited<T>> {
  for await (const value of iterable) {
    yield value;
  }
}

function mapSync<A, B>(f: (a: A) => B, iterable: Iterable<A>): IterableIterator<B> {
  const iterator = iterable[Symbol.iterator]();
  return {
    next() {
      const { done, value } = iterator.next();
      return done ? { done, value } : { done: false, value: f(value) };
    },
    [Symbol.iterator]() {
      return this;
    },
  };
}

function mapAsync<A, B>(a: (a: A) => B, asyncIterable: AsyncIterable<A>): AsyncIterableIterator<Awaited<B>> {
  const asyncIterator = asyncIterable[Symbol.asyncIterator]();
  return {
    async next() {
      const { done, value } = await asyncIterator.next();
      return done ? { done, value } : { done: false, value: await a(value) };
    },
    [Symbol.asyncIterator]() {
      return this;
    },
  };
}

async function init() {
  console.time("init");

  // AsyncIterable<T>
  for await (const value of toAsync([1, 2])) {
    console.log(value);
  }

  // AsyncIterable<Promise<T>>
  for await (const value of toAsync([Promise.resolve(1), Promise.resolve(2)])) {
    console.log(value);
  }

  // Iterable<T>
  for await (const value of [1, 2]) {
    console.log(value);
  }

  // Iterable<Promise<T>>
  for await (const value of [Promise.resolve(1), Promise.resolve(2)]) {
    console.log(value);
  }

  console.timeEnd("init");
}

function loadImage(url: string): Promise<HTMLImageElement> {
  return new Promise((resolve, reject) => {
    const image = new Image();
    image.src = url;
    image.onload = () => resolve(image);
    image.onerror = () => reject(new Error(`Failed to load image: ${url}`));
  });
}

async function calcTotalHeight(urls: string[]) {
  try {
    const totalHeight = await urls.map(async (url) => {
      const img = await loadImage(url);
      return img.height
    })
    .reduce(async (a, b) => await a + await b, await Promise.resolve(0))
  }
}

init();
