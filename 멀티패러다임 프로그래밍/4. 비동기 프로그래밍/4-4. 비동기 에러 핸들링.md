## 비동기 에러 핸들링
- 비동기 로직의 특성상 에러가 발생했을 때 코드가 어디서 실행되고 있는지 명확하게 파악이 힘들 수 있음
- 외부 시스템과 상호작용 하는 작업은 에러 가능성이 높으므로 이를 효율적으로 핸들링하는 방법이 중요함

<br>

## 여러 이미지를 불러와서 높이 구하기
- 아래 코드에서 이미지를 다운로드 하는 도중 에러가 발생해도 계속해서 이미지 다운로드를 시도함
- 비동기 로직의 본질적인 흐름과 에러 처리를 충분히 고려하지 않아서 불필요한 요청이 발생함
- 또한 작업 흐름이 비효율적으로 진행될 가능성이 있으며 에러도 감춰지고 있음

```ts
function loadImage(url: string): Promise<HTMLImageElement> {
  return new Promise((resolve, reject) => {
    const image = new Image();
    image.src = url;
    image.onload = () => resolve(image);
    image.onerror = () => reject(new Error(`Failed to load image: ${url}`));
  });
}

async function calcTotalHeight(urls: string[]) {
  try {
    const totalHeight = await urls
      .map(async (url) => {
        const img = await loadImage(url);
        return img.height;
      })
      .reduce(async (a, b) => (await a) + (await b), Promise.resolve(0));

    return totalHeight;
  } catch (error) {
    console.log(error);
  }
}
```

<br>

## 개선된 비동기 로직
- 에러가 발생하면 그 즉시 요청을 멈추게됨
- 비동기 프로그래밍에서 효율적이고 견고한 코드 작성을 위해서는 Promise와 `동기 - 비동기`에 대한 이해가 필요함

```ts
function loadImage(url: string): Promise<HTMLImageElement> {
  return new Promise((resolve, reject) => {
    const image = new Image();
    image.src = url;
    image.onload = () => resolve(image);
    image.onerror = () => reject(new Error(`Failed to load image: ${url}`));
  });
}

async function calcTotalHeight(urls: string[]) {
  try {
    const totalHeight = await fx(urls)
      .toAsync()
      .map(loadImage)
      .map((img) => img.height)
      .reduce((a, b) => a + b, 0);

    return totalHeight;
  } catch (error) {
    console.error(error);
  }
}

console.log(
  await calcTotalHeight([
    "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTFYqoKTu_o3Zns2yExbst2Co84Gpc2Q1RJbA&s",
  ])
);
```

<br>

## 에러가 제대로 발생되도록 하는 것이 핵심
- 비동기 프로그래밍에서 가장 중요한 것은 단순히 에러를 핸들링하는게 아닌 에러가 제대로 발생되도록 설계하는것
- 에러가 발생해야 할 상황에서 이를 적절히 발생시키니는 것은 신뢰성과 유지보수성을 높이는 핵심 원칙임

<br>

### 코드의 순수성을 유지함
- 아래 함수의 경우 에러를 발생시키는 책임을 함수 내부에 두지 않았음
- 에러 처리의 경우는 호출하는 쪽에서 처리할 수 있게 설계했음
- 이러면 코드의 순수성을 유지하면서도 더 다은 에러 핸들링이 가능함

```ts
const getTotalHeight = (urls: string[]) =>
  fx(toAsync(urls))
    .map(loadImage)
    .map((img) => img.height)
    .reduce((a, b) => a + b, 0);
```

<br>

### 사용하는 곳에서 에러 처리하기
- 순수 함수를 작성하는데 유리하고 부수 효과를 관리하기 용이함
- 에러 핸들링은 에러가 발생하는 맥락에 가깝게 작성하는것이 가장 효과적임
```ts
try {
  const height = await getTotalHeight([]);
} catch (error) {
  console.error(error);
  return 0;
}
```

<br>

## 에러가 제대로 발생되도록 설계하기
### Promise, async/await, try/catch를 정확하게 이해하고 활용하기
- 비동기 작업 수행시 Promise, async/await를 적절히 사용해서 에러가 명확히 드러나도록 작성해야함
- try/catch 구문을 활용하면 호출자에게 에러를 명확하게 전달할 수 있음

<br>

### 에러를 숨기지 않고 명확하게 드러내기
- 불필요하게 에러를 처리하려고 하거나 지나치게 복잡한 에러 핸들링 코드를 작성하면 오히려 에러가 숨겨질 가능성이 높음
- 감추기보다는 발생하도록 두고 이를 상위 레벨에서 처리 또는 로깅 도구를 통해 모니터링 하는게 좋음

<br>

### 순수 함수는 에러를 발생시키도록 설계
- 순수 함수는 부수효과를 가지지 않으므로 에러를 발생시키고 이를 상위 호출자에게 위임하는 방식이 바람직함
- 순수 함수 내부에서 에러를 처리혀로 시도하면 함수의 목적이 흐려질 수 있음

<br>

### 제너레이터/이터레이터/이터러블을 활용한 선언적 프로그래밍
- 제너레이터 + 이터러블을 통해서 코드의 표현력을 높이면서 비동기 작업에서 에러핸들링을 직관적이고 명확하게 할 수 있음
- 비동기 이터러블을 통해 에러 발생 시점을 제어하고 에러가 전파되는 흐름을 선언적으로 표현이 가능함

<br>

### 에러 핸들링 코드는 부수 효과 코드 근처에 작성
- 디비 접근, 네트워크 요청 등 부수 효과를 발생시키는 코드 근처에서 에러를 처리해야 에러의 원인과 해결 방안을 명확하게 알 수 있음
- 부수 효과와 무관한 영역에서 에러를 처리하려고 하면 디버깅과 유지보수가 어려워짐

<br>

### Sentry 같은 에러 로깅 서비스 활용
- 에러 핸들링의 한계를 보완하기 위해서 외부 모니터링 서비스를 사용하면 실시간 모니터링이 가능해짐
- 이때도 에러가 숨겨지지 않고 제대로 발생하도록 코드 설계가 필요함