## AsyncIterator, AsyncIterable, AsyncGenerator 프로토콜
- 다양한 프로토콜을 제공하며 비동기 작업의 순차적 처리를 지원함
- 비동기 작업을 더욱 효유적이고 유연하게 처리가 가능하고 각 요소르 비동기적으로 생성 및 소비가 가능함

<br>

### 인터페이스 구조
- `Iterable`을 `for...of`로 순회가 가능하듯이 `AsyncIterable`은 `for await...of`로 순회가 가능함
```ts
interface IteratorYieldResult<T> {
  value: T;
  done: false;
}

interface IteratorReturnResult {
  value: undefined;
  done: true;
}

// 비동기 이터레이터의 경우 Promise를 반환하게됨
interface AsyncIterator<T> {
  next(): Promise<IteratorYieldResult<T> | IteratorReturnResult>;
}

// Symbol.asyncIterator로 비동기적으로 반복될 수 있음을 나타냄
interface AsyncIterable<T> {
  [Symbol.asyncIterator](): AsyncIterator<T>;
}

// 비동기적으로 반복 가능한 반복자를 나타냄을 동시에 반복자 자체가 AsyncIterable임
interface AsyncIterableIterator<T> extends AsyncIterator<T> {
  [Symbol.asyncIterator](): AsyncIterableIterator<T>;
}
```

<br>

### AsyncGenerator 기본 문법
- `stringsAsyncTest` 함수는 비동기 이터러블 이터레이터를 반환함
- 아직 `next()` 메서드가 호출되지 않았으므로 아직 실행되지 않은 상태임
- `next() -> a` / `next() -> b` / `next() -> undefined` 형식으로 동작하며 각 요청은 await로 결과를 기다림
```ts
async function* stringsAsyncTest(): AsyncIterableIterator<string> {
  yield delay(1000, "a");
  const b = await delay(500, "b");
  yield b;
}

async function init() {
  console.time("init");

  const asyncIterator = stringsAsyncTest();
  console.log(asyncIterator); // Object [AsyncGenerator] {}

  const result1 = await asyncIterator.next();
  console.log(result1.value);

  const result2 = await asyncIterator.next();
  console.log(result2.value);

  const { done } = await asyncIterator.next();
  console.log(done);

  // a
  // b
  // true
  // init: 1.506s

  console.timeEnd("init");
}

init();
```

<br>

### toAsync 함수
- 동기적인 iterable 또는 Promise가 포함된 Iterable을 받아서 비동기로 처리할 수 있는 AsyncIterable로 변환함

```ts
/**
 * 동기적인 값 T 또는 Promise<T>가 포함된 iterable를 인자로 받음
 * 반환값은 AsyncIterable<Awaited<T>>로써 함수 내부에서 Symbol.asyncIterator 메서드를 구현해서 비동기 반복자를 반환함
 * 반환한 비동기 반복자의 next() 메서드는 내부의 iterator.next 메서드를 호출해서 값을 가져옴
 */
function toAsync<T>(iterable: Iterable<T | Promise<T>>): AsyncIterable<Awaited<T>> {
  return {
    [Symbol.asyncIterator](): AsyncIterator<Awaited<T>> {
      const iterator = iterable[Symbol.iterator]();
      return {
        async next() {
          const { done, value } = iterator.next();
          return done ? { done, value } : { done: false, value: await value };
        },
      };
    },
  };
}

async function init() {
  console.time("init");

  /**
   * AsyncIterator를 직접 구현하는 방법
   * 1. [1] 이라는 동기적인 iterable을 인자로 전달함
   * 2. asyncIterator.next()를 호출하면 즉시 반환함
   */
  const asyncIterable1 = toAsync([1]);
  const asyncIterator1 = asyncIterable1[Symbol.asyncIterator]();
  await asyncIterator1.next().then(({ value }) => console.log(value));

  /**
   * AsyncGenerator를 사용하는 방법
   * 1. Promise.resolve(2)라는 Promise를 가진 배열을 전달함
   * 2. asyncIterator.next()를 호출하면 Promise가 완료될 때까지 대기하고 값을 반환함
   */
  const asyncIterable2 = toAsync([Promise.resolve(2)]);
  const asyncIterator2 = asyncIterable2[Symbol.asyncIterator]();
  await asyncIterator2.next().then(({ value }) => console.log(value));

  console.timeEnd("init");
}

init();
```

<br>

### AsyncGenerator를 사용해서 구현하기
- 기존에 작성했던 함수랑 역할은 같지만 코드가 매우 단순화됨
- 이런식으로 문제마다 가장 적합한 방법을 찾아서 하는게 중요함

```ts
// function toAsync<T>(iterable: Iterable<T | Promise<T>>): AsyncIterable<Awaited<T>> {
//   return {
//     [Symbol.asyncIterator](): AsyncIterator<Awaited<T>> {
//       const iterator = iterable[Symbol.iterator]();
//       return {
//         async next() {
//           const { done, value } = iterator.next();
//           return done ? { done, value } : { done: false, value: await value };
//         },
//       };
//     },
//   };
// }

async function* toAsync<T>(iterable: Iterable<T | Promise<T>>): AsyncIterableIterator<Awaited<T>> {
  for await (const value of iterable) {
    yield value;
  }
}
```

<br>

### AsyncIterableIterator<Awaited<T>>를 for await...of랑 사용하기
- 아래 예제를 기준으로는 `toAsync` 함수의 필요성이 와닿지도 않을 수 있음
- 하지만 타입으로 다루는 비동기를 위해서는 중요한 역할을함

```ts
async function init() {
  console.time("init");

  // AsyncIterable<T>
  for await (const value of toAsync([1, 2])) {
    console.log(value);
  }

  // AsyncIterable<Promise<T>>
  for await (const value of toAsync([Promise.resolve(1), Promise.resolve(2)])) {
    console.log(value);
  }

  // Iterable<T>
  for await (const value of [1, 2]) {
    console.log(value);
  }

  // Iterable<Promise<T>>
  for await (const value of [Promise.resolve(1), Promise.resolve(2)]) {
    console.log(value);
  }

  console.timeEnd("init");
}
```

<br>

## AsyncIterable을 다루는 고차 함수
- AsyncIterable을 다루는 고차 함수는 비동기 작업을 효율적으로 처리하기데 유용함

<br>

### AsyncIterator를 직접 구현한 mapAsync 함수
- mapSync와 mapAsync는 코드와 값이 흐르는 방식이 완전히 동일함
- mapAsync의 경우 mapSync와 유사한 방식으로 작동하면서 비동기 이터러블을 다룰 수 있도록 설계되어있음

```ts
const delay = <T>(time: number, value: T): Promise<T> => new Promise((resolve) => setTimeout(resolve, time, value));

function mapSync<A, B>(f: (a: A) => B, iterable: Iterable<A>): IterableIterator<B> {
  const iterator = iterable[Symbol.iterator]();
  return {
    next() {
      const { value, done } = iterator.next();
      return done ? { value: undefined, done: true } : { value: f(value), done: false };
    },
    [Symbol.iterator]() {
      return this;
    },
  };
}

function mapAsync<A, B>(f: (a: A) => B, asyncIterable: AsyncIterable<A>): AsyncIterableIterator<Awaited<B>> {
  const asyncIterator = asyncIterable[Symbol.asyncIterator]();

  return {
    async next() {
      const { value, done } = await asyncIterator.next();
      return done ? { value: undefined, done: true } : { value: await f(value), done: false };
    },
    [Symbol.asyncIterator]() {
      return this;
    },
  };
}

async function* strings(): AsyncIterableIterator<string> {
  yield delay(500, "a");
  yield delay(200, "b");
}

const mapped = mapAsync((a) => a.toUpperCase(), strings());

for await (const a of mapped) {
  console.log(a); // A, B
}
```

<br>

### mapAsync를 AsyncGenerator로 구현하기
- 제너레이터를 사용하면 매우 간단하게 구현이 가능함
- 기존 mapAsync 함수와 동일하게 작동하며 비동기 이터러블의 각 요소에 함수 f를 적용한 결과를 비동기적으로 반환함

```ts
async function* mapAsync<A, B>(f: (a: A) => B, asyncIterable: AsyncIterable<A>): AsyncIterableIterator<Awaited<B>> {
  for await (const value of asyncIterable) {
    yield f(value);
  }
}
```

<br>

### toAsync 함수와 함께 사용하기
- mapAsync 함수의 경우 asyncIterable을 인자로 받으므로 toAsync와 함께 사용하면 좋음

```ts
for await (const a of mapAsync((a) => a * 2, numbers())) {
  console.log(a);
}

for await (const a of mapAsync((a) => delay(100, a * 2), toAsync([1, 2]))) {
  console.log(a);
}
```

<br>

### AsyncGenerator로 만든 filterAsync 함수
```ts
function* filterSync<A>(f: (a: A) => boolean, iterable: Iterable<A>): IterableIterator<A> {
  for (const value of iterable) {
    if (f(value)) {
      yield value;
    }
  }
}

async function* filterAsync<A>(
  f: (a: A) => Promise<boolean>,
  asyncIterable: AsyncIterable<A>
): AsyncIterableIterator<A> {
  for await (const value of asyncIterable) {
    if (await f(value)) {
      yield value;
    }
  }
}

for await (const a of filterAsync(async (a) => a % 2 === 1, toAsync([1, 2, 3]))) {
  console.log(a);
}

for await (const a of filterAsync((a) => delay(100, a % 2 === 1), toAsync([1, 2, 3]))) {
  console.log(a);
}
```

<br>

## 동기와 비동기를 동시에 지원하는 함수로 만드는 규약 - toAsync
- `toAsync` 함수는 결과적으로는 `AsyncIterable<T>`를 만드는 함수임

<br>

### iterable 여부를 체크하는 타입가드
```ts
function isIterable<T = unknown>(a: Iterable<T> | unknown): a is Iterable<T> {
  return typeof a?.[Symbol.iterator as unknown as keyof typeof a] === "function";
}
```

<br>

### 동기와 비동기를 모두 지원하는 map 함수
```ts
function map<A, B>(f: (a: A) => B, iterable: Iterable<A>): IterableIterator<B>;
function map<A, B>(f: (a: A) => B, asyncIterable: AsyncIterable<A>): AsyncIterableIterator<Awaited<B>>;
function map<A, B>(
  f: (a: A) => B,
  iterable: Iterable<A> | AsyncIterable<A>
): IterableIterator<B> | AsyncIterableIterator<Awaited<B>> {
  return isIterable(iterable) ? mapSync(f, iterable) : mapAsync(f, iterable);
}
```

<br>

### 동기와 비동기를 모두 지원하는 filter 함수
```ts
function filter<A>(f: (a: A) => boolean, iterable: Iterable<A>): IterableIterator<A>;
function filter<A>(f: (a: A) => boolean | Promise<boolean>, asyncIterable: AsyncIterable<A>): AsyncIterableIterator<A>;
function filter<A>(
  f: (a: A) => boolean | Promise<boolean>,
  iterable: Iterable<A> | AsyncIterable<A>
): IterableIterator<A> | AsyncIterableIterator<A> {
  return isIterable(iterable) ? filterSync(f as (a: A) => boolean, iterable) : filterAsync(f, iterable);
}
```

<br>

## 타입 시스템 + 비동기 함수형 함수 + 클래스
```ts
function fx<A>(iterable: Iterable<A>): FxIterable<A>;
function fx<A>(asyncIterable: AsyncIterable<A>): FxAsyncIterable<A>;
function fx<A>(iterable: Iterable<A> | AsyncIterable<A>): FxIterable<A> | FxAsyncIterable<A> {
  return isIterable(iterable) ? new FxIterable(iterable) : new FxAsyncIterable(iterable);
}

class FxIterable<A> implements Iterable<A> {
  constructor(private readonly iterable: Iterable<A>) {}

  [Symbol.iterator]() {
    return this.iterable[Symbol.iterator]();
  }

  map<B>(f: (a: A) => B): FxIterable<B> {
    return fx(map(f, this.iterable));
  }

  filter(f: (a: A) => boolean): FxIterable<A> {
    return fx(filter(f, this.iterable));
  }

  toArray(): A[] {
    return [...this];
  }

  toAsync() {
    return fx(toAsync(this));
  }
}

class FxAsyncIterable<A> implements AsyncIterable<A> {
  constructor(private readonly asyncIterable: AsyncIterable<A>) {}

  [Symbol.asyncIterator]() {
    return this.asyncIterable[Symbol.asyncIterator]();
  }

  map<B>(f: (a: A) => B) {
    return fx(map(f, this));
  }

  filter(f: (a: A) => boolean | Promise<boolean>) {
    return fx(filter(f, this));
  }

  toArray() {
    return fromAsync(this);
  }
}

/**
 * FxIterable -> filterSync -> mapSync
 */
console.log(
  fx(naturals(4))
    .filter(isOdd)
    .map((a) => a * 100)
    .toArray()
);

/**
 * FxIterable -> FxAsyncIterable -> filterAsync -> mapAsync
 */
const iter2 = fx(naturals(4))
  .toAsync()
  .filter((a) => delay(100, isOdd(a)))
  .map((a) => a * 100);

for await (const a of iter2) {
  console.log(a);
}

/**
 * FxIterable -> FxAsyncIterable -> mapAsync -> toArray
 */
console.log(
  await fx(naturals(4))
    .filter(isOdd)
    .toAsync()
    .map((a) => delay(100, a))
    .toArray()
);
```

<br>

### 타입 시스템을 활용한 비동기 로직 검증
- 타입 시스템을 통해서 비동기 작업 로직을 컴파일 타임에 미리 검증이 가능함
- 타입 시스템의 강력함을 통해서 비동기 로직이 올바르게 작성됬는지, 잠재적인 오류가 없는지 컴파일 타임에 확인하고 런타임 오류를 줄일 수 있음

```ts
/**
 * 비정상
 */
const iter2 = fx(naturals(4))
  .filter((a) => delay(100, isOdd(a))) // Type 'Promise<boolean>' is not assignable to type 'boolean'.ts(2322)
  .map((a) => a * 100);

/**
 * delay 사용을 위해서 AsyncIterableIterator로 변환
 */
const iter3 = fx(naturals(4))
  .toAsync()
  .filter((a) => delay(100, isOdd(a)))
  .map((a) => a * 100);
```

<br>

### 동기와 비동기를 모두 지원하는 reduce 함수
```ts
function reduceSync<A, Acc>(f: (acc: Acc, a: A) => Acc, acc: Acc, iterable: Iterable<A>): Acc {
  for (const a of iterable) {
    acc = f(acc, a);
  }
  return acc;
}

async function reduceAsync<A, Acc>(
  f: (acc: Acc, a: A) => Acc,
  acc: Acc,
  asyncIterable: AsyncIterable<A>
): Promise<Acc> {
  for await (const a of asyncIterable) {
    acc = f(acc, a);
  }
  return acc;
}

function reduce<A, Acc>(f: (acc: Acc, a: A) => Acc, acc: Acc, iterable: Iterable<A>): Acc;
function reduce<A, Acc>(f: (acc: Acc, a: A) => Acc, acc: Acc, asyncIterable: AsyncIterable<A>): Promise<Acc>;
function reduce<A, Acc>(
  f: (acc: Acc, a: A) => Acc,
  acc: Acc,
  iterable: Iterable<A> | AsyncIterable<A>
): Acc | Promise<Acc> {
  return isIterable(iterable) ? reduceSync(f, acc, iterable) : reduceAsync(f, acc, iterable);
}
```

<br>

### reduce 적용하기
```ts
/**
 * FxIterable -> filterSync -> mapSync -> reduceSync
 */
const result = fx(naturals(4))
  .filter(isOdd)
  .map((a) => a * 10)
  .reduce((acc, a) => acc + a, 0);

/**
 * FxAsyncIterable -> filterAsync -> mapAsync -> reduceAsync
 */
const resultPromise = fx(naturals(4))
  .toAsync()
  .filter((a) => delay(100, isOdd(a)))
  .map((a) => a * 10)
  .reduce((acc, a) => acc + a, 0);

console.log(result, await resultPromise); // 40, 40
```

