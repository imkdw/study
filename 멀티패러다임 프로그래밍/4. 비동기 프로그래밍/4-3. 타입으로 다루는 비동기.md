## AsyncIterator, AsyncIterable, AsyncGenerator 프로토콜
- 다양한 프로토콜을 제공하며 비동기 작업의 순차적 처리를 지원함
- 비동기 작업을 더욱 효유적이고 유연하게 처리가 가능하고 각 요소르 비동기적으로 생성 및 소비가 가능함

<br>

### 인터페이스 구조
- `Iterable`을 `for...of`로 순회가 가능하듯이 `AsyncIterable`은 `for await...of`로 순회가 가능함
```ts
interface IteratorYieldResult<T> {
  value: T;
  done: false;
}

interface IteratorReturnResult {
  value: undefined;
  done: true;
}

// 비동기 이터레이터의 경우 Promise를 반환하게됨
interface AsyncIterator<T> {
  next(): Promise<IteratorYieldResult<T> | IteratorReturnResult>;
}

// Symbol.asyncIterator로 비동기적으로 반복될 수 있음을 나타냄
interface AsyncIterable<T> {
  [Symbol.asyncIterator](): AsyncIterator<T>;
}

// 비동기적으로 반복 가능한 반복자를 나타냄을 동시에 반복자 자체가 AsyncIterable임
interface AsyncIterableIterator<T> extends AsyncIterator<T> {
  [Symbol.asyncIterator](): AsyncIterableIterator<T>;
}
```

<br>

### AsyncGenerator 기본 문법
- `stringsAsyncTest` 함수는 비동기 이터러블 이터레이터를 반환함
- 아직 `next()` 메서드가 호출되지 않았으므로 아직 실행되지 않은 상태임
- `next() -> a` / `next() -> b` / `next() -> undefined` 형식으로 동작하며 각 요청은 await로 결과를 기다림
```ts
async function* stringsAsyncTest(): AsyncIterableIterator<string> {
  yield delay(1000, "a");
  const b = await delay(500, "b");
  yield b;
}

async function init() {
  console.time("init");

  const asyncIterator = stringsAsyncTest();
  console.log(asyncIterator); // Object [AsyncGenerator] {}

  const result1 = await asyncIterator.next();
  console.log(result1.value);

  const result2 = await asyncIterator.next();
  console.log(result2.value);

  const { done } = await asyncIterator.next();
  console.log(done);

  // a
  // b
  // true
  // init: 1.506s

  console.timeEnd("init");
}

init();
```

<br>

### toAsync 함수
- 동기적인 iterable 또는 Promise가 포함된 Iterable을 받아서 비동기로 처리할 수 있는 AsyncIterable로 변환함

```ts
/**
 * 동기적인 값 T 또는 Promise<T>가 포함된 iterable를 인자로 받음
 * 반환값은 AsyncIterable<Awaited<T>>로써 함수 내부에서 Symbol.asyncIterator 메서드를 구현해서 비동기 반복자를 반환함
 * 반환한 비동기 반복자의 next() 메서드는 내부의 iterator.next 메서드를 호출해서 값을 가져옴
 */
function toAsync<T>(iterable: Iterable<T | Promise<T>>): AsyncIterable<Awaited<T>> {
  return {
    [Symbol.asyncIterator](): AsyncIterator<Awaited<T>> {
      const iterator = iterable[Symbol.iterator]();
      return {
        async next() {
          const { done, value } = iterator.next();
          return done ? { done, value } : { done: false, value: await value };
        },
      };
    },
  };
}

async function init() {
  console.time("init");

  /**
   * AsyncIterator를 직접 구현하는 방법
   * 1. [1] 이라는 동기적인 iterable을 인자로 전달함
   * 2. asyncIterator.next()를 호출하면 즉시 반환함
   */
  const asyncIterable1 = toAsync([1]);
  const asyncIterator1 = asyncIterable1[Symbol.asyncIterator]();
  await asyncIterator1.next().then(({ value }) => console.log(value));

  /**
   * AsyncGenerator를 사용하는 방법
   * 1. Promise.resolve(2)라는 Promise를 가진 배열을 전달함
   * 2. asyncIterator.next()를 호출하면 Promise가 완료될 때까지 대기하고 값을 반환함
   */
  const asyncIterable2 = toAsync([Promise.resolve(2)]);
  const asyncIterator2 = asyncIterable2[Symbol.asyncIterator]();
  await asyncIterator2.next().then(({ value }) => console.log(value));

  console.timeEnd("init");
}

init();
```

<br>

### AsyncGenerator를 사용해서 구현하기
- 기존에 작성했던 함수랑 역할은 같지만 코드가 매우 단순화됨
- 이런식으로 문제마다 가장 적합한 방법을 찾아서 하는게 중요함

```ts
// function toAsync<T>(iterable: Iterable<T | Promise<T>>): AsyncIterable<Awaited<T>> {
//   return {
//     [Symbol.asyncIterator](): AsyncIterator<Awaited<T>> {
//       const iterator = iterable[Symbol.iterator]();
//       return {
//         async next() {
//           const { done, value } = iterator.next();
//           return done ? { done, value } : { done: false, value: await value };
//         },
//       };
//     },
//   };
// }

async function* toAsync<T>(iterable: Iterable<T | Promise<T>>): AsyncIterableIterator<Awaited<T>> {
  for await (const value of iterable) {
    yield value;
  }
}
```

<br>

### AsyncIterableIterator<Awaited<T>>를 for await...of랑 사용하기
- 아래 예제를 기준으로는 `toAsync` 함수의 필요성이 와닿지도 않을 수 있음
- 하지만 타입으로 다루는 비동기를 위해서는 중요한 역할을함

```ts
async function init() {
  console.time("init");

  // AsyncIterable<T>
  for await (const value of toAsync([1, 2])) {
    console.log(value);
  }

  // AsyncIterable<Promise<T>>
  for await (const value of toAsync([Promise.resolve(1), Promise.resolve(2)])) {
    console.log(value);
  }

  // Iterable<T>
  for await (const value of [1, 2]) {
    console.log(value);
  }

  // Iterable<Promise<T>>
  for await (const value of [Promise.resolve(1), Promise.resolve(2)]) {
    console.log(value);
  }

  console.timeEnd("init");
}
```

<br>

## AsyncIterable을 다루는 고차 함수
- 