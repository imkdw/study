## Promise 실행을 지연하려면
- 만약 6개의 Promise 중에서 총 2번에 걸쳐서 3개씩 실행한다고 가정한다
- `executeWithLimit(promises, limit)` 함수를 만들어서 해결이 가능하다

```ts
const delay = <T>(time: number, value: T): Promise<T> => new Promise((resolve) => setTimeout(resolve, time, value));

type MyFile = {
  name: string;
  body: string;
  size: number;
};

async function getFile(name: string, size = 1000): Promise<MyFile> {
  console.log(`${name} 파일 다운로드 시작`);

  return delay<MyFile>(size, { name, body: "...", size });
}

async function executeWithLimit<T>(promises: Promise<T>[], limit: number): Promise<T[]> {
  const result1 = await Promise.all([promises[0], promises[1], promises[2]]);
  const result2 = await Promise.all([promises[3], promises[4], promises[5]]);

  return [...result1, ...result2];
}

async function init() {
  console.time("init");

  const files = await executeWithLimit<MyFile>(
    [getFile("file1"), getFile("file2"), getFile("file3"), getFile("file4"), getFile("file5"), getFile("file6")],
    3
  );

  // file1 파일 다운로드 시작
  // file2 파일 다운로드 시작
  // file3 파일 다운로드 시작
  // file4 파일 다운로드 시작
  // file5 파일 다운로드 시작
  // file6 파일 다운로드 시작
  // [
  //   { name: 'file1', body: '...', size: 1000 },
  //   { name: 'file2', body: '...', size: 1000 },
  //   { name: 'file3', body: '...', size: 1000 },
  //   { name: 'file4', body: '...', size: 1000 },
  //   { name: 'file5', body: '...', size: 1000 },
  //   { name: 'file6', body: '...', size: 1000 }
  // ]
  console.log(files);

  // init: 1.006s
  console.timeEnd("init");
}

init();
```

<br>

### 위 코드의 문제점
- `Promise.all()`을 통해서 2개의 result1, result2를 만들어서 총 2000ms가 소요될 것 으로 예상한다
- 하지만 실제로는 1000ms가 걸렸다

<br>

### Promise의 즉시 실행
- Promise 객체는 생성되는 즉시 실행됨
- 즉 getFile 함수가 호출되는 순간 이미 Promise가 시작됨
- 3개씩 그룹화해서 `Promise.all` + `await`로 대기하더라도 6개의 Promise는 동시에 실행됨

<br>

### 병렬 실행의 의미
- Promise.all은 이미 실행된 모든 Promise를 받아서 모두 완료될 떄까지 대기했다가 각 Promise를 풀어낸 배열을 반환하는 함수일 뿐 Promise의 시작 자체를 제어하지는 못함
- 위 같은 문제를 해결하기 위해서는 아직 Promise들이 실행되지 않은 상태에서 그룹을 나누고 각 그룹이 순차적으로 실행될 수 있게 해야함
- Promise를 함수로 감싸서 필요할 떄 실행되도록 실행을 지연한 방법임

```ts
const delay = <T>(time: number, value: T): Promise<T> => new Promise((resolve) => setTimeout(resolve, time, value));

type MyFile = {
  name: string;
  body: string;
  size: number;
};

async function getFile(name: string, size = 1000): Promise<MyFile> {
  console.log(`${name} 파일 다운로드 시작`);

  return delay<MyFile>(size, { name, body: "...", size });
}

async function executeWithLimit<T>(fs: (() => Promise<T>)[], limit: number): Promise<T[]> {
  const result1 = await Promise.all([fs[0](), fs[1](), fs[2]()]);
  const result2 = await Promise.all([fs[3](), fs[4](), fs[5]()]);
  return [...result1, ...result2];
}

async function init() {
  console.time("init");

  const files = await executeWithLimit<MyFile>(
    [
      () => getFile("file1"),
      () => getFile("file2"),
      () => getFile("file3"),
      () => getFile("file4"),
      () => getFile("file5"),
      () => getFile("file6"),
    ],
    3
  );

  // -- 즉시 3개가 출력됨
  // file1 파일 다운로드 시작
  // file2 파일 다운로드 시작
  // file3 파일 다운로드 시작

  // -- 약 1초뒤 아래 3개 출력됨
  // file4 파일 다운로드 시작
  // file5 파일 다운로드 시작
  // file6 파일 다운로드 시작

  // -- 약 2초 뒤 아래 내용이 출력됨
  // [
  //   { name: 'file1', body: '...', size: 1000 },
  //   { name: 'file2', body: '...', size: 1000 },
  //   { name: 'file3', body: '...', size: 1000 },
  //   { name: 'file4', body: '...', size: 1000 },
  //   { name: 'file5', body: '...', size: 1000 },
  //   { name: 'file6', body: '...', size: 1000 }
  // ]
  console.log(files);

  // init: 1.006s
  console.timeEnd("init");
}

init();
```

<br>

## GPT가 명령형으로 구현한 동시성 핸들링 함수
```
## INPUT
fs를 limit개씩 나눈 다음 limit개씫 나누어 실행하는 함수로 만들어줘
async function executeWithLimit(fs: (() => Promise<T>[]), limit: number): Promise<T[]> {}

## OUTPUT
async function executeWithLimit<T>(
  fs: (() => Promise<T>)[],
  limit: number
): Promise<T[]> {
  const results: T[] = [];

  for (let i = 0; i < fs.length; i += limit) {
    const chunk = fs.slice(i, i + limit);
    const chunkResults = await Promise.all(chunk.map(f => f()));
    results.push(...chunkResults);
  }

  return results;
}
```

<br>

## 함수형으로 구현한 동시성 핸들링 함수
### 리스트 프로세싱으로 생각하기
- N개의 Promise: `() => P,() => P,() => P,() => P,() => P, ...]`
- 3개씩 그룹화: `[() => P,() => P,() => P,]`
- 함수 실행: `[P, P, P]`
- 3개씩 대기하도록 Promise.all로 감싸기: `[P<[T, T, T]>, P<[T, T, T]>, ...]`
- Promise.all 결과 꺼내기: `[P<[[T, T, T], ...]]`
- 1차원 배열로 평탄화: `P<[T, T, T, ...]>`

<br>

### chunk(size, iterable) 함수
```ts
class FxIterable<A> {
  // ...

  chunk(size: number): FxIterable<A[]> {
    return fx(chunk(size, this));
  }
}

const fx = <A>(iterable: Iterable<A>): FxIterable<A> => new FxIterable(iterable);

function* chunk<T>(size: number, iterable: Iterable<T>): IterableIterator<T[]> {
  const iterator = iterable[Symbol.iterator]();
  while (true) {
    // 주어진 사이즈 만큼 배열화를 진행함
    const arr = [
      ...take(size, {
        [Symbol.iterator]() {
          return iterator;
        },
      }),
    ];

    // 그룹화된 배열이 있다면 해당 값을 반환
    if (arr.length) yield arr;

    // 배열이 더 이상 없다면 루프 종료
    if (arr.length < size) break;
  }
}

// [ 10, 20 ]
// [ 30, 40 ]
// [ 50 ]
fx([1, 2, 3, 4, 5])
  .chunk(2)
  .map((arr) => arr.map((a) => a * 10))
  .forEach(console.log);
```

<br>

### chunk로 시작하여 executeWithLimit 구현 완료하기
```ts
async function fromAsync<T>(iterable: Iterable<Promise<T>> | AsyncIterable<T>): Promise<T[]> {
  const arr: T[] = [];
  for await (const a of iterable) {
    arr.push(a);
  }

  return arr;
}

const executeWithLimit = async <T>(fs: (() => Promise<T>)[], limit: number): Promise<T[]> =>
  fx(fs)
    .chunk(limit) // [[() => Promise<T>,() => Promise<T>], ...]] 처럼 N개씩 그룹화를 진행
    .map((fs) => fs.map((f) => f())) // [[P<T>, P<T>, P<T>, ...]] 비동기 함수를 실행
    .map((ps) => Promise.all(ps)) // [P<[T, T, T, ...]>, P<[T, T, T, ...]>] 처럼 N개씩 대기하도록 Promise.all로 감싸기
    .to(fromAsync) // P<[[T, T, T, ...]]> 처럼 Promise.all 결과 꺼내기
    .then((arr) => arr.flat()); // P<[T, T, T,...]> 처럼 결과 평탄화

async function getFile(name: string, size = 1000): Promise<MyFile> {
  console.log(`${name} 파일 다운로드 시작`);
  return delay<MyFile>(size, { name, body: "...", size });
}

async function init() {
  console.time("init");

  const files = await executeWithLimit(
    [
      () => getFile("file1"),
      () => getFile("file2"),
      () => getFile("file3"),
      () => getFile("file4"),
      () => getFile("file5"),
      () => getFile("file6"),
      () => getFile("file7"),
    ],
    2
  );

  // -- 최초
  // file1 파일 다운로드 시작
  // file2 파일 다운로드 시작

  // -- 1초 뒤
  // file3 파일 다운로드 시작
  // file4 파일 다운로드 시작

  // -- 2초 뒤
  // file5 파일 다운로드 시작
  // file6 파일 다운로드 시작

  // -- 3초 뒤
  // file7 파일 다운로드 시작

  // -- 최총 결과 출력
  // [
  //   { name: 'file1', body: '...', size: 1000 },
  //   { name: 'file2', body: '...', size: 1000 },
  //   { name: 'file3', body: '...', size: 1000 },
  //   { name: 'file4', body: '...', size: 1000 },
  //   { name: 'file5', body: '...', size: 1000 },
  //   { name: 'file6', body: '...', size: 1000 },
  //   { name: 'file7', body: '...', size: 1000 }
  // ]

  // init: 4.010s
  console.log(files);

  console.timeEnd("init");
}

init();
```

<br>

## 효과적인 비동기 핸들링으로 가는 계단 - 지연성
- `executeWithLimit` 함수 구현의 핵심은 지연성임
- 지연성은 효과적인 비동기 핸들링으로 나아가는데 중요한 징검다리 역할을 함
- 위 함수가 가능한 이유는 비동기 작업 평가가 지연된 로직이 담긴 리스트를 `fromAsync` 이전에 만들어놔서 가능한 동작임

<br>

### 지연성을 더욱 잘 활용한 함수 합성으로 코드를 더 간결하게 만들기
- 기존에 작성한 `chunk`, `map` 모두 지연 평가되는 함수라서 일부 변경이 가능함
- `map(f => f()) -> chunk(limit) -> map(ps => Promise.all(ps))` 까지는 아무것도 실행이 안됨
- `to(fromAsync)` 내부 for await...of 내부에서 이터레이터가 소비되는 시점에 N개의 f가 실행되고 그룹화되어서 Promise.all로 전달되는 형태임

```ts
const executeWithLimit = async <T>(fs: (() => Promise<T>)[], limit: number): Promise<T[]> =>
  fx(fs)
    .map((f) => f()) // [[P<T>, P<T>, P<T>, ...]] 비동기 함수를 실행
    .chunk(limit) // [[() => Promise<T>,() => Promise<T>], ...]] 처럼 N개씩 그룹화를 진행
    .map((ps) => Promise.all(ps)) // [P<[T, T, T, ...]>, P<[T, T, T, ...]>] 처럼 N개씩 대기하도록 Promise.all로 감싸기
    .to(fromAsync) // P<[[T, T, T, ...]]> 처럼 Promise.all 결과 꺼내기
    .then((arr) => arr.flat()); // P<[T, T, T,...]> 처럼 결과 평탄화
```

<br>

### 지연성과 비동기 프로그래밍
- 어떤 문제 상황에서는 `new Promise()` or `async/await`를 통한 명령형이 더 좋을 수 있음
- 하지만 대부분의 비동기 상황에서는 지연성 + 리스트 프로세싱을 활용한 것이 더 효과적이고 안전하며 유리하고 적합함
- 이처럼 지연 평가는 언어의 중요한 요소이며 일급 함수, 반복자 패턴을 활용한 리스트 프로세싱은 강력한 도구이자 언어적 표현임

