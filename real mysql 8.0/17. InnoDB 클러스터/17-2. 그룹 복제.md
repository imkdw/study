# 그룹 복제(Group Replication)

- 내부적으로 Row 포멧의 바이너리 로그와 릴레이 로그, GTID를 사용한다
- 모든 서버가 서로 통신하면서 양방향으로도 복제 처리가 가능함
- 하나의 복제 그룹 내부에서는 쓰기를 처리하는 서버가 여러개 존재할 수 있음
- 서버를 표현할때 소스, 레플리카가 아닌 프라이머리, 세컨더리로 지칭함
- 적어도 3대 이상의 서버가 그룹 내 존재해야함
  - `n = 2f + 1` (n: 전체서버, f: 허용하고자 하는 장애서버) 공식으로 서버수를 결정해야함

<br/>

# 그룹 복제 방식

### 뭔가 반동기 방식?

- 반동기 방식처럼 처리되지만 실제 반동기와는 조금 다른점이 존재함
- 반동기 복제에서는 레플리카 서버에서 응답을 받으면 해당 트랜잭션을 커밋했음
- 클러스터에서 사용되는 방식은 트랜잭션 정보를 다른 멤버에게 전송 후 과반수 이상 응답을 받으면 그 때 커밋을 진행함
  - 또한 그룹의 다른 멤버들에 대한 응답을 확인하는 과정을 `합의(Consensus)`라고 부름
- 멤버들에 응답에 따라서 전체 복제 그룹에서 해당 트랜잭션의 적용 여부가 결정되는데 이게 가장 큰 차이점임
- 데이터를 변경하는 작업에 대해서만 위 과정이 필요하고 읽기만 하는 과정에선 필요하지 않음

<br>

# 그룹 복제 아키텍쳐

- 별도의 플러그인으로 구현되어 있고, 플러그인을 설치해야 그룹 복제 사용이 가능함
- 클러스터에 참여하는 플러그인을 통해서 지속적으로 통신하고 동기화를 처리함
- `group_rpelication_applier` 채널에서 그룹에서 실행된 모든 트랜잭션을 전달받아 적용함
- `group_replication_recovery` 채널에서는 새로운 서버가 추가됬을때 분산 복구 작업을 진행함

<br>

### 플러그인 구조

- 최상위 계층에는 인터페이스인 플러그인 API 집합이 존재함
  - 디비 서버 -> 플러그인으론 서버 시작/복구, 트랜잭션 커밋 등에 대한 이벤트를 전달
  - 플러그인 -> 디비 서버로는 처리중인 트랜잭션에 대한 커밋, 중단, 릴레이로그 기록 요청 등을 전달
- 중간 계층에는 그룹 복제 기능이 실제로 구현돼있는 복제 플러그인 계층이 존재함
  - 여러가지 모듈로 나눠져있고, API를 통해서 들어온 요청은 각각 적절한 모듈로 전달됨
  - 트랜잭션들이 처리되고 충돌감지, 전파, 분산복구 작업 등이 여기서 처리됨
- 마지막 두 게층은 그룹 통신 시스템 API, 엔진으로 구성됨
  - eXtended COMmunication 또는 간단하게 xCom으로 부르고, 서버들간의 통신 처리를 담당하는 핵심 구성요소
  - 별도의 포트(`33061`)로 통신하고, 트랜잭션이 그룹 복제 멤버들에 동일한 순서로 전달되게 보장해줌
- 구성원 간 합의를 위해 사용하는 알고리즘에는 2가지`(Paxos, Raft)`가 존재함
  - Paxos : 분산 시스템에서 데이터 변경이 발생하는 서버가 여러개 존재할때 주로 사용
  - Raft : 데이터 변경이 한 대에서만 발생하는 경우 주로 사용
  - 그룹 복제에서는 이를 지원하기 위해 `Paxos 계열의 Mencius 알고리즘`을 기반으로 구현되어 있음

<br>

# 그룹 복제 모드

- 프라이머리 서버 수에 따라서 싱글 및 멀티 프라이머리 모드로 구분함
  - `group_replication_single_primary_mode`로 어떤 모드로 동작할지 제어함, `ON은 싱글`, `OFF는 멀티`, `기본값은 ON`이다
- 그룹에 참여할려는 모든 서버는 위 변수가 같은 값으로 설정해야하고, 8.0.13 버전에서는 `UDF`로 변경이 가능함
  - `group_replication_switch_to_single_primary_mode()` : 싱글 모드로 변경
  - `group_replication_switch_to_multi_primary_mode()` : 멀티 모드로 변경

<br>

### 싱글 프라이머리 모드

- 그룹 내에서 쓰기를 처리할 수 있는 프라이머리 서버가 한대만 존재하는 형태
- 처음 구축하는 경우는 그룹 복제 구축을 진행한 서버가 프라이머리로 지정됨
  - 프라이머리 서버가 그룹을 탈퇴하거나, UDF로 멀티 모드로 바꾸면 프라이머리 서버가 변경됨

<br>

#### 프라이머리 서버 선출 기준

- MySQL 서버 버전
  - 제일 우선시해서 고려되는 요소
  - 모든 멤버가 8.0.17 이상이면 패치버전, 미만의 버전이 있다면 메이저 버전으로 정렬
- 각 멤버의 가중치 값
  - 각 멤버들에게 `group_replication_member_weight`를 비교함
  - 기본값은 50으로 0 ~ 100 사이의 값 지정이 가능함
- UUID 값 사전식 순서
  - 서버 버전과, 가중치 기준으로 해당되는 멤버가 둘 이상 존재하면 UUID 값의 사전 순숴대로 가장 낮을 가지는 멤버가 프라이머리로 선정됨

<br>

### 멀티 프라이머리 모드

- 그룹 멤버들이 모두 프라이머리로 동작하는 형태, 클라이언트는 어떠한 서버로든 읽기/쓰기 요청이 가능함
- 해당 모드에서는 호환성이 매우 중요한데, 가능하면 모든 서버가 동일한 버전을 사용하는게 좋다
- 새로운 멤버가 그룹에 추가될때는 호환 가능 기준에 따라서 참여가능여부 및 읽기전용모드 유지 여부를 결정함
  - 그룹 내 존재하는 가장 낮은 버전보다 더 낮으면 그룹 참여 불가능
  - 그룹 내 존재하는 가장 낮은 버전보다 더 높은 버전은 읽기 전용 모드를 유지함

<br>

# 그룹 멤버 관리

- 어떤 서버들이 그룹에 참여하고 있는지 멤버들에 대한 목록과 상태를 내부적으로 관리함
  - `performance_schema.replication_group_members` 테이블에서 관리함
- 그룹 멤버에 변동이 생기면 자동으로 감지해서 상태를 업데이트함
- 해당 목록과 상태 정보를 `뷰(View)`라고도 부르는데, 그룹 멤버가 변경될 때마다 새로운 뷰 ID 값이 생성됨
  - 해당 값을 통해서 뷰의 변경을 추적하고, 변경된 시점을 구분할 수 있다
  - `View ID = [Prefix value]:[Sequence value]` 처럼 구성됨, 예시는 `87116:4`임

<br>

# 그룹 복제에서의 트랜잭션 처리

### 합의(Consensus)

- 그룹 내 일관된 트랜잭션 적용을 위해서 그룹 멤버들에게 트랜잭션 적용을 제한 및 승낙받는 과정
- Xcom을 통해서 트랜잭션에서 변경한 데이터에 대한 Writeset 및 gtid_executed 스냅샷 등을 전파함
- Paxos 알고리즘 등을 통해 최종적으로 합의가 완료되어 과반수 이상의 동의가 있다면 트랜잭션을 적용함
  - 만약 과반수 이상 동의가 없다면 트랜잭션은 롤백되고 클라이언트로 에러가 반환됨

<br>

### 인증(Certification)

- Xcom을 통해 전달받은 Writeset 및 로컬에서 보유중인 Writeset을 비교해서 트랜잭션 충돌여부를 검사함
- 충돌이 발생했다면 롤백되므로 충돌이 자주 발생하는 환경에서는 이러한 과정이 없는 싱글 프라이머리 모드가 권장됨

<br>

# 트랜잭션 일관성 수준

- `group_replication_consistency1` 시스템 변수로 일관성 수준 설정이 가능함
- 각 수준은 읽기전용 트랜잭션과 읽기-쓰기 트랜잭션에 다른 영향을 끼침

<br>

### EVENTUAL 일관성 수준

- 기본값이며, 최종적으로는 그룹 멤버들이 일관된 데이터를 가지게됨을 의미
- 모든 트랜잭션은 별도의 제약없이 바로 실행이 가능한데, 다른 서버에서는 일시적으로 구버전 데이터를 읽을수도 있음
- 페일오버시 새로운 프라이머리가 이전 프라이머리의 변경사항을 적용하느라 트랜잭션 충돌로 인해 롤백이 발생할수도 있음
- 또한 다른 트랜잭션에서 변경중인 레코드를 읽는 경우는 구버전 데이터를 읽을수도 있음

<br>

### BEFORE_ON_PRIMARY_FAILOVER 일관성 수준

- 싱글모드로 설정된 그룹 복제에서 프라이머리 페일오버가 발생해서 신규 프라이머리 선출됬을때만 트랜잭션에 영향을 미침
- 페일오버가 발생해서 이전 프라이머리의 트랜잭션을 반영중일때는 모든 트랜잭션은 기존 트랜잭션에 의해서 블로킹된다
- 이러한 트랜잭션은 영구대기가 불가능한데 `wait_timeout`에 설정된 시간만큼 대기하고 넘어가면 에러를 반환한다
- `wait_timeout`은 기본값이 28,800으로 8시간이며, 가능하면 앱에서 적절한 타임아웃을 지정하는게 좋다
- 모든 쿼리가 블로킹되는건 아니고 모니터링 등을 위한 일부 쿼리는 바로 실행이 가능하다
  - SHOW, SET, DO, EMPTY 등..
- 읽기 요청의 경우는 항상 최신 데이터를 보장하며, 쓰기 요청은 트랜잭션 충돌이 발생하지 않아서 롤백되지 않는다

<br>

### BEFORE 일관성 수준

- 모든 트랜잭션은 모든 선핼 트랜잭션이 완료될 때 까지 대기하고 처리한다
- 항상 최신 데이터를 읽지만, 트랜잭션이 오래 대기할수도 있음
- 읽기 요청은 적고 쓰기 요청이 많은 경우에 적합함

<br>

### AFTER 일관성 수준

- 최종적으론 해당 시점에 그룹 멤버들이 모두 동기화된 데이터를 가지게 해준다
- 읽기/쓰기 트랜잭션은 다른 모든 멤버들도 해당 트랜잭션이 커밋될 준비가 됐을때까지 대기한 후 최종적으로 처리됨
  - 이는 동시점에 실행되는 트랜잭션에 영향을 미침
- 읽기 전용의 경우는 데이터 변경을 발생시키지 않아서 바로 처리됨
- 쓰기 요청보다 읽기가 많고, 분산된 최신 읽기를 수행하고자 할때 적합함

<br>

### BEFORE_AND_AFTER 일관성 수준

- 읽기/쓰기는 선행 트랜잭션이 적용될때까지 기다리고 실행됨
- 트랜잭션이 다른 모든 멤버들에서도 커밋이 준비되어 응답을 보내면 그 때 최종적으로 커밋함
- 읽기전용 요청의 경우도 모든 선행 트랜잭션이 적용될 때까지 대기한 후 실행됨
- 항상 최신 데이터를 보장하지만, 대기시간 초과가 발생할수도 있음

<br>

# 흐름 제어(Flow Control)

- 그룹 멤버 간의 트랜잭션 적용 불균형으로 인해 발생하는 문제를 방지하기 위해 쓰기 처리량을 조절하는 메커니즘
- 멤버 간 트랜잭션 갭을 적게 유지해서 멤버들의 데이터가 최대한 동기화된 상태로 유지될 수 있게 해줌
- 평소와 다른 워크로드가 유입되는 상황에서도 변화에 빠르게 적응해서 각 멤버의 쓰기 처리량이 균등할 수 있게 해줌
- `group_replication_flow_control_mode`로 제어가 가능하고 현재는 `QUOTA`, `DISABLE` 모드만 존재함

<br>

### QUOTA 모드

- 모든 그룹 멤버의 쓰기 처리량과 대기중인 트랜잭션에 대한 통계를 수집해서 흐름제어의 필요성 판단
- 처리량 조절이 필요하면 통계 데이터를 바탕으로 멤버가 최대 쓰기량을 넘지 않도록 제한
- 그룹 전체가 아닌 각 멤버별로 적용되며 수집된 정보는 그룹의 다른 멤버에게도 공유됨
  - 인증 큐 크기, 적용큐 크기, 인증된 트랜잭션 수, 적용된 원격 트랜잭션 수, 로컬 트랜잭션 수가 수집됨
- 흐름제어의 경우는 인증 큐 크기, 적용 크 큐기를 기반으로 처리량을 조절함

<br>

### 관련된 시스템 변수

#### group_replication_flow_control_certifier_threshold

- 단위는 트랜잭션 수로 인증 큐에서 대기 중인 트랜잭션 수가 해당 값을 초과하면 흐름제어가 작동함
- 기본 값은 25000이며 0 ~ 21억 사이의 숫자 지정이 가능함

<br>

#### group_replication_flow_control_applier_threshold

- 단위는 트랜잭션 수로 어플라이어 큐에서 대기 중인 트랜잭션 수가 해당 값을 초과하면 흐름제어가 작동함
- 기본 값은 25000이며 0 ~ 21억 사이의 숫자 지정이 가능함

<br>

#### group_replication_flow_control_min_quota

- 흐름제어에서 계산된 처리량과 관계없이 멤버에게 할당돼야 하는 최소 쓰기 처리량
- 기본값은 0이며 0 ~ 21억 사이의 숫자 지정이 가능함

<br>

#### group_replication_flow_control_max_quota

- 흐름제어에서 계산된 처리량과 관계없이 멤버에게 할당돼야 하는 최대 쓰기 처리량
- 기본값은 0이며 0 ~ 21억 사이의 숫자 지정이 가능함

<br>

#### group_replication_flow_control_min_recovery_quota

- 그룹에서 복구 상태의 멤버가 존재할때 min_quota 대신 적용되는 변수

그 외에도 다양한 변수가 존재함

<br>

# 그룹 복제의 자동 장애감지 및 대응

- 일부 멤버가 장애가 발생해도 그룹이 정상적으로 작동할 수 있게 장애 감지 매커니즘이 구현되어있음
- 멤버로 부터 5초 이내에 응답을 못받으면 의심을 시작하고, 과반수의 멤버가 동의하면 해당 멤버는 그룹에서 추방됨
  - 추방되기 전에 의심을 받은 멤버는 대기 시간동안 UNREACHABLE 상태로 표현됨
- 추방된 멤버는 다시 통신이 이루어지면 추방당했다는 사실을 감지하는데 5분 간격으로 총 3번의 재가입 요청을 하게됨
- 만약 통신이 계속 불가능하면 `group_replication_unreachable_majority_timeout`을 통해 스스로 탈퇴도 가능함

<br>

# 그룹 복제의 분산 복구

- 새로운 멤버나 추방당했던 멤버는 그룹에 가입할때 동기화된 최신 데이터를 받아야함
- 이러한 복구 프로세스를 자동으로 수행하는데 이를 `분산 복구`라고 부름
- 복구 작업을 위해서 선태한 기존 그룹 멤버는 `기증자(Donor)`라고 부르며, 모든 멤버가 기증자가 될 수 있음

<br>

### 분산 복구 방식

- 기존에 가입했던 멤버라면 릴레이 로그에서 탈퇴시점을 찾아서 적용되지 못한 트랜잭션이 남아있다면 이를 복구함
- 신규 유저의 경우는 처음부터 복구함
- 분산 복구 작업은 `바이너리 로그 복제 방식`과 `원격 클론 방식`으로 나뉨
- 알아서 적절한 방식을 선택해서 구현하는데 원격 클론 플러그인이 없다면 바이너리 로그 복제 방식으로 진행함

<br>

#### 바이너리 로그 복제 방식

- 비동기 복제를 기반으로 규현되어있고 기증자와 별도의 채널로 연결함
- 바이너리 로그에서 아직 적용되지 않은 트랜잭션을 가져와서 멤버에게 적용하는 방식

<br>

#### 원격 클론 방식

- 다른 그룹 멤버의 스토리지 엔진에 저장된 모든 데이터와 메타데이터를 일관된 스냅샷으로 가져옴
- 해당 스냅샷으로 멤버를 재구축 하는 방식임. 해당 방식은 기증자와 신규 멤버 모두 플러그인이 설치되어 있어야함

<br>

### 분산 복구 프로세스

- 로컬 복구
  - 이전에 그룹에 가입한 적이 있다면 릴레이 로그에 미처 적용하지 못한 트랜잭션이 남아있을수도 있음
  - 이를 먼저 적용하고 나서 다음 단계를 진행함
- 글로벌 복구
  - 그룹 내부에서 기증자를 선택하고 해당 멤버로 부터 데이터를 가져와서 적용함
  - 이 작업을 하는 동안은 현재 그룹에서 트랜잭션들을 내부적으로 캐싱해둠
- 캐시 트랜잭션 적용
  - 글로벌 복구 작업동안 캐싱해둔 트랜잭션들을 적용하고 그룹에 참여함

<br>

### 분산 복구 설정

- 연결 시도 횟수
  - 바이너리 로그 복제 방식으로 복구 작업 진행시 가입한 멤버가 기존 그룹 멤버에 연결하는 시도 횟수를 제한함
  - `group_replication_recovery_retry_count`로 설정하고 기본값은 10임
  - 원격 클론 방식은 해당 변수에 영향을 받지 않으며, 멤버당 1번씩만 연결을 시도함
- 연결 시도 간격
  - 연결 대상 멤버들에게 한번씩 전부 연결을 시도하고 대기하는 시간을 지정함
  - `group_replication_recovery_reconnect_interval`로 설정하고 기본값은 60초임
- 가입한 멤버를 온라인 상태로표기하는 시점
  - 분산 복구가 완료되면 해당 멤버는 온라인 상태로 표기됨
  - 이 때 어느 시점에 online으로 표기할지 정할 수 있음
  - `group_replication_recovery_recovery_complete_at`로 설정함

<br>

### 분산 복구 오류 처리

- 분산 복구 도중에도 오류가 발생하면 자동으로 다시 작업을 시도하는 장애 감지 매커니즘이 구현되어 있음
- 재시도 횟수를 모두 소진하거나, 바이너리 로그가 없을때 클론 방식도 안되는 등 의 경우에는 해당 멤버는 그룹을 떠나게됨

<br>

# 그룹 복제 요구사항

- InnoDB 스토리지 엔진 사용하기
- 기본키 사용하기
- 원활한 네트워크 환경
- 바이너리 로그 활성화 및 ROW 형태 사용
- 바이너리 로그 체크섬 설정
- log_slave_updates 활성화
- GTID 사용
- 고유한 server_id 사용
- 복제 메타데이터 저장소 설정
- 트랜잭션 Writeset 설정
- 테이블 스페이스 암호화 설정
- lower_case_table_names 설정
- 멀티 스레드 복제 설정

<br>

# 그룹 복제 제약 사항

- 갭 락이 적용되지 않는 `READ-COMMITTED` 트랜잭션 격리수준 사용하기
- 테이블락, 네임드 락은 고려하지 않음
- 바이너리 로그 체크섬은 8.0.21 부터 지원함
- 멀티 프라이머리 모드에서는 트랜잭션 격리수준인 `SERIALIZABLE` 사용 불가
- 동일한 테이블에 대해서 서로 다른 멤버에서 DDL, DML 문 실행 불가
- CASCADE 제약조건 사용 불가(미동작)
- ...
