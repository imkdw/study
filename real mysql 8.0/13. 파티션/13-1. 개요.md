# 개요

- 논리적으론 하나지만 물리적으론 여러개의 테이블로 분리해서 관리할 수 있게 해주는 기능
- 주로 대용량 테이블을 물리적으로 여러 개의 소규모 테이블로 분산하는 목적으로 사용함

<br>

# 파티션을 사용하는 이유

- 데이터가 많다고해서 무조건 파티션을 적용하는게 효율적이진 않음
- 인덱스 크기가 물리적인 메모리보다 훨씬 크거나, 데이터 특성상 자주 삭제가 필요한 경우 등 에 사용하면 좋음

<br>

### 단일 INSERT와 단일 또는 범위 SELECT의 빠른 처리

- 인덱스는 일반적으로 SELECT를 위한것으로 보이지만, UPDATE/DELETE 등 컬럼을 조회할때도 필수적이다
- 인덱스의 워킹셋이 실직적인 물리 메모리보다 크다면 쿼리 처리가 상당히 느려질것이다
  - 워킹셋은 활발하게 사용되는 데이터를 뜻한다
- 즉 파티션하지 않은 하나의 큰 테이블로 사용하면 인덱스도 커지고 그만큼 물리적인 메모리 공간도 많이 필요하게 된다

<br>

### 데이터의 물리적인 저장소를 분리

- 데이터나 인덱스가 커지면 그만큼 백업이나 관리가 어려워짐
- MySQL은 테이블의 파티션 단위로 인덱스를 생성하거나 파티션 별 다른 인덱스를 가지는 형태는 지원하지 않음

<br>

### 이력 데이터의 효율적인 관리

- 로그 데이터의 경우 수명이 매우 짧다. 기록되는 동시에 일정 기간이 지나면 쓸모가 없어진다
- 시간이 지나면 삭제해버리는데 일반 테이블에서는 이런 대용량 데이터는 상당히 고부하의 작업에 속한다
- 파티션을 통해 이러한 데이터를 쪼개서 관리하면 단순히 파티현 추가, 삭제 방식으로 간단하게 관리가 가능함

<br>

# MySQL 파티션의 내부 처리

```sql
create table tb_article (
	id int not null,
	reg_date datetime not null,
	primary key(id, reg_date)
) partition by range (YEAR(reg_date)) (
	partition p2009 values less than (2010),
	partition p2010 values less than (2011),
	partition p2011 values less than (2012),
	partition p2012 values less than (2013)
);
```

<br>

### 파티션 테이블의 레코드 INSERT

- INSERT 쿼리가 실행되면 파티션 키인 reg_date 컬럼의 값으로 파티션 표현식을 평가
- 이후에 레코드가 저장될 적절한 파티션을 결정함
  - reg_date가 2011-03-09인 경우 partition_2011에 저장되는 느낌

<br>

### 파티션 테이블의 UPDATE

- UPDATE ... WHERE 조건에 파티션키가 있다면 매우 빠르게 대상 레코드 검색이 가능
- 만약 파티션키가 없다면 대상 레코드를 찾기 위해서 테이블의 모든 파티션을 검색해야함
- 파티션 키가 변경되지 않는다면 일반 테이블과 마찬가지로 컬럼의 값만 변경함
- 파티션 키 컬럼이 변경되면 기존 레코드가 저장된 파티션에서 해당 레코드를 삭제함
  - 이후에 파티션 키 컬럼의 표현식을 평가하고, 그 결과로 새로운 파티션을 결정해서 새로 저장함

<br>

### 파티션 테이블의 SELECT

> 4번째 방식은 가능하면 피하고, 2번째 방식도 파티션이 많다면 성능이 저하될 수 있음

- 파티션 키 + 인덱스 사용
  - 파티션의 개수와 관계없이 검색을 위해 꼭 필요한 파티션의 인덱스만 레인지 스캔함
- 파티션 불가 + 인덱스 사용
  - 우선 테이블의 모든 파티션을 대상으로 검색해야함
  - 파티션 개수만큼 테이블에 대해서 인덱스 레인지 스캔 이후에, 결과를 병합해서 가져오는 방식
- 파티션 가능 + 인덱스 불가
  - 대상 파티션에 대해서 풀스캔이 필요함
- 파티션 불가 + 인덱스 불가
  - 풀 테이블 스캔이 필요함

<br>

### 파티션 테이블의 인덱스 스캔과 정렬

- 인덱스는 파티션 단위로 생성되고, 테이블 전체 단위로 하나의 통합된 인덱스는 지원하지 않음
- 여러 파티션에 대해서 인덱스 스캔을 수행할때는 레코드를 정렬된 순서로 읽으면서 우선순위 큐에 저장함
- 이후에 필요한 순서대로 데이터를 가져오므로 따로 정렬을 수행하진 않음

<br>

### 파티션 프루닝

- 최적화 단계에서 필요한 파티션만 골라내고 불필요한 것들은 실행계획에서 배제하는걸 뜻함
- 실행계획에서 partitions 컬럼에 어떤 파티션에 접근했는지 확인이 가능함

| id  | select_type | table      | partitions | type  | possible_keys | key     | key_len | ref | rows | filtered | Extra                    |
| --- | ----------- | ---------- | ---------- | ----- | ------------- | ------- | ------- | --- | ---- | -------- | ------------------------ |
| 1   | SIMPLE      | tb_article | p2010      | index | PRIMARY       | PRIMARY | 9       |     | 1    | 100.0    | Using where; Using index |
