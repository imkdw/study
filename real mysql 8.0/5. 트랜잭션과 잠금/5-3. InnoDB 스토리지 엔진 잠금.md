# InnoDB 스토리지 엔진 잠금

- 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재함
  - MyISAM 보다 뛰어난 동시성 제어를 제공함
  - 잠금 정보가 상당히 작은 공간으로 관리됨
- 이전에는 InnoDB 락에 대한 정보 접근이 힘들었으나 최근엔 많이 완화됨
  - Performance Schema를 통한 모니터링 방법이 추가되었음

<br/>

### 레코드 락

- 레코드 자체만을 잠구는 락을 뜻함
- InnoDB의 경우 레코드 자체가 아니라 인덱스의 레코드를 잠금

<br/>

### 갭 락

- 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠구는 락
- 레코드와 레코드 사이에 새로운 레코드가 생성(INSERT)되는것을 제어함

<br/>

### 넥스트 키 락

- 레코드락과 갭 락을 합쳐 놓은 형태의 잠금을 뜻함
- 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어낸 결과와 동일한 결과를 만들도록 보장하는것이 주 목적임

<br/>

### 자동 증가 락

- AUTO_INCREMENT로 설정된 컬럼에서 설정되는 락으로 테이블 수준의 잠금을 사용함
- 새로운 레코드를 저장하는 쿼리에서만 필요하고, 다른 쿼리에서는 걸리지 않음
- 명시적으로 획득, 해제하는 방법은 없고 대부분의 경우 성능상 문제가 되진 않음
- `innodb_autoinc_lock_mode` 설정으로 작동방식 변경이 가능함

#### 자동 증가 락 옵션

> 만약 ROW가 아닌 STATEMENT 포멧을 사용하면 1로 변경하는걸 권장함

- 0
  - 모든 INSERT 쿼리는 자동 증가 락을 사용
- 1
  - INSERT 문의 크기가 예측이 가능하면 락이 아닌 래치(뮤텍스)를 사용한다
  - INSERT 값이 예측이 불가능하면 여러개의 자동증가 값을 한번에 할당받고 사용한다
    - 만약 자동증가 값이 남는다면 연속되지 않고 누락된 값이 발생할수도 있다
  - 해당 설정은 최소한 하나의 INSERT 문장으로 INSERT 되는 연속된 자동증가값을 가진다
  - 연속모드 라고도 부름
- 2
  - 절대 자동 증가 락을 사용하지 않고 래치(뮤텍스)를 사용한다
  - 연속된 자동 증가 값을 보장하지 않아서 인터리빙 모드라고도 부른다
  - 해당 설정은 하나의 커넥션이 INSERT 중이여도 다른 커넥션도 INSERT가 가능해서 동시성 처리성능이 높다
  - 순차적인 증가값 생성은 보장하지 않지만 유니크한 값이 생성된다는것만 보장한다

<br/>

# 인덱스와 잠금

- InnoDB의 잠금은 레코드가 아닌 인덱스를 잠그는 방식으로 처리됨
- 변경해야 할 레코드를 찾기 위해서 검색한 인덱스의 레코드를 모두 락을 걸어야함
- 성능 저하 방지를 위해서 InnoDB의 인덱스 설계를 잘해야함

<br/>

### 인덱스 잠금 예시

- first_name 컬럼에는 인덱스가 설정되어 있음
- 아래 업데이트를 실행하게 되면 253개의 인덱스가 모두 잠김
- 만약 인덱스가 하나도 없다면 모든 레코드가 전부 잠기게 되버림

```sql
mysql> select count(*) from employees where first_name='Georgi';
+----------+
| count(*) |
+----------+
|      253 |
+----------+
1 row in set (0.00 sec)

mysql> select count(*) from employees where first_name='Georgi' and last_name='Klassen';
+----------+
| count(*) |
+----------+
|        1 |
+----------+
1 row in set (0.00 sec)

mysql> update employees set hire_date=now() where first_name='Georgi' and last_name='Klassen';
Query OK, 1 row affected, 1 warning (0.01 sec)
Rows matched: 1  Changed: 1  Warnings: 1
```

<br/>

# 레코드 수준의 잠금 확인 및 해제

- 레코드 수준의 잠금은 테이블 수준의 잠금보다 조금 더 복잡하다
- KILL 명령을 사용해서 프로세스를 죽이면 강제로 잠금 해제가 가능하다

<br/>

### 잠금 시나리오

- 3개의 커넥션이 동시에 동일한 레코드에 대해서 업데이트를 수행한다고 가정한다
- 커넥션 별로 순차적인 처리를 위해서 각 프로세스는 레코드에 락을 지정한다
- `SHOW PROCESSLIST`, `performance_schema` 테이블 조회를 통해서 잠금 대기순서 확인이 가능하다
