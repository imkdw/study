# 실행 계획 분석

- 표의 각 라인은 쿼레엇 사용한 테이블의 개수만큼 출력됨
- 위에 있을수록 쿼리의 바깥 부분이거나 먼저 접근한 테이블이다
- 아래에 있을수록 쿼리의 안쪽 부분이나 나중에 접근한 테이블에 해당된다

<br/>

# ID 컬럼

- id 컬럼은 단위 SELECT 쿼리별로 부여되는 식별자 값이다
- SELECT가 한개이고, 여러개의 테이블이 조인되면 id값이 증가하지 않고 같은값이 부여된다
- N개의 단위 SELECT 쿼리로 구성하는 경우 id값이 서로 다른 값을 가진다
- id 컬럼은 테이블의 접근순서를 의미하진 않는다. 순서는 EXPLAIN ANALYZE로 확인하자

<br/>

# select_type 컬럼

각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시하는 컬럼

<br/>

### SIMPLE

- UNION, 서브쿼리를 사용하지 않은 단순한 쿼리다
- 일반적으로 제일 바깥의 SELECT 쿼리에서 표시된다

<br/>

### PRIMARY

- UNION, 서브쿼리를 가지는 SELECT 쿼리의 실행계획에서 제일 바깥쪽에 있는 단위 쿼리에 표시된다
- PRIMARY 단위의 쿼리는 하나만 존재하고, 제일 바깥쪽에 있는 SELECT 단위 쿼리에 표시된다

<br/>

### UNION

- UNION으로 결합하는 단위 SELECT 쿼리 카운데 첫 번째를 제외한 두번째 이후 단위 SELECT 쿼리에 표시됨
- 첫번쨰 단위 SELECT에는 DERIVED로 표시되는데, 이는 UNION되는 결과들을 모아서 저장하는 임시테이블을 뜻한다

#### 실행계획

```sql
explain
select * from (
	(
		select emp_no from employees e1 LIMIT 10
	) UNION ALL
	(
		select emp_no from employees e2 LIMIT 10
	) UNION ALL
	(
		select emp_no from employees e3 LIMIT 10
	)
) tb;

```

| id  | select_type | table      | partitions | type  | possible_keys | key         | key_len | ref | rows   | filtered | Extra       |
| --- | ----------- | ---------- | ---------- | ----- | ------------- | ----------- | ------- | --- | ------ | -------- | ----------- |
| 1   | PRIMARY     | <derived2> |            | ALL   |               |             |         |     | 30     | 100.0    |             |
| 2   | DERIVED     | e1         |            | index |               | ix_hiredate | 3       |     | 300030 | 100.0    | Using index |
| 3   | UNION       | e2         |            | index |               | ix_hiredate | 3       |     | 300030 | 100.0    | Using index |
| 4   | UNION       | e3         |            | index |               | ix_hiredate | 3       |     | 300030 | 100.0    | Using index |

- e1 테이블은 조인 결과를 모아서 처리하는 임시테이블로 DERIVED 타입으로 표시된다
- 그 외 나머지 테이블은 UNION 이라고 표시됬다

<br/>

### DEPENDENT UNION

- UNION이랑 마찬가지로 UNION, UNION ALL로 집합을 결합하는 쿼리에서 표시됨
- DEPENDENT는 결합된 단위 쿼리가 외부 쿼리에 의해서 영향을 받는 것을 의미함
- 즉 내부 쿼리가 외부의 값을 참조해서 처리될 때 DEPENDENT 타입으로 표시된다

#### 실행계획

```sql
explain
SELECT *
FROM employees e1 WHERE e1.emp_no IN (
	SELECT e2.emp_no FROM employees e2 WHERE e2.first_name = 'Matt'
	UNION
	SELECT e3.emp_no FROM employees e3 WHERE e3.last_name = 'Matt'
);
```

| id  | select_type        | table      | partitions | type   | possible_keys                              | key     | key_len | ref  | rows   | filtered | Extra           |
| --- | ------------------ | ---------- | ---------- | ------ | ------------------------------------------ | ------- | ------- | ---- | ------ | -------- | --------------- |
| 1   | PRIMARY            | e1         |            | ALL    |                                            |         |         |      | 300030 | 100.0    | Using where     |
| 2   | DEPENDENT SUBQUERY | e2         |            | eq_ref | PRIMARY,ix_firstname,ix_lastname_firstname | PRIMARY | 4       | func | 1      | 5.0      | Using where     |
| 3   | DEPENDENT UNION    | e3         |            | eq_ref | PRIMARY,ix_lastname_firstname              | PRIMARY | 4       | func | 1      | 5.0      | Using where     |
| 4   | UNION RESULT       | <union2,3> |            | ALL    |                                            |         |         |      |        |          | Using temporary |

- e2, e3을 UNION한 결과가 UNION RESULT 타입으로 표시된다
- 내부적으로 e1.emp_no = e2.emp_no, e1.emp_no = e3.emp_no 조건이 추가됨
- 외부에 정의된 e1 테이블의 영향을 받았기 때문에 DEPENDENT UNION 타입으로 표시됨

<br/>

### UNION RESULT

- UNION 처리에 대한 결과를 담아두는 테이블
- UNION (UNION DISTINCT)는 여전히 임시 테이블에 결과를 버퍼함
- `<union1, 2>`에서 1, 2는 값이 1인 단위 쿼리의 조회 결과와 id가 2인 단위 쿼리의 조회 결과를 조합했다는걸 의미함

```sql
explain
select emp_no from salaries where salary > 100000
union DISTINCT
select emp_no from dept_emp where from_Date > '2001-01-01';
```

| id  | select_type  | table      | partitions | type  | possible_keys                 | key         | key_len | ref | rows   | filtered | Extra                    |
| --- | ------------ | ---------- | ---------- | ----- | ----------------------------- | ----------- | ------- | --- | ------ | -------- | ------------------------ |
| 1   | PRIMARY      | salaries   |            | range | ix_salary                     | ix_salary   | 4       |     | 188518 | 100.0    | Using where; Using index |
| 2   | UNION        | dept_emp   |            | range | ix_fromdate,ix_empno_fromdate | ix_fromdate | 3       |     | 5325   | 100.0    | Using where; Using index |
| 3   | UNION RESULT | <union1,2> |            | ALL   |                               |             |         |     |        |          | Using temporary          |

<br/>

### SUBQUERY

- FROM에서 사용된 서브쿼리는 DERIVED로 표시되고, 그 외의 서브쿼리는 모두 SUBQUERY 타입으로 표시됨
- 서브쿼리는 사용되는 위치에 따라서 각각 다른 이름을 지님
  - 중첩쿼리(Nested Query) : SELECT 되는 컬럼에 사용되는 서브쿼리
  - 서브쿼리(Subquery) : WHERE에 사용하는 쿼리는 일반적으로 그냥 서브쿼리라고 부름
  - 파생테이블(Derived Table) : FROM 절에 사용된 서브쿼리

```sql
EXPLAIN
SELECT e.first_name,
  (
    SELECT (COUNT(*))
    FROM dept_emp de, dept_manager dm
    WHERE dm.dept_no = de.dept_no
  ) AS cnt
FROM employees e
WHERE e.emp_no = 10001;
```

| id  | select_type | table | partitions | type  | possible_keys | key     | key_len | ref                  | rows  | filtered | Extra       |
| --- | ----------- | ----- | ---------- | ----- | ------------- | ------- | ------- | -------------------- | ----- | -------- | ----------- |
| 1   | PRIMARY     | e     |            | const | PRIMARY       | PRIMARY | 4       | const                | 1     | 100.0    |             |
| 2   | SUBQUERY    | dm    |            | index | PRIMARY       | PRIMARY | 20      |                      | 24    | 100.0    | Using index |
| 2   | SUBQUERY    | de    |            | ref   | PRIMARY       | PRIMARY | 16      | realmysql.dm.dept_no | 41392 | 100.0    | Using index |

<br/>

### DEPENDENT SUBQUERY

- 서브쿼리가 바깥쪽 SELECT 쿼리에서 정의된 컬럼을 사용하는 경우 DEPENDENT SUBQUERY 타입으로 표시됨
- 아래 쿼리에서는 SELECT의 서브쿼리가 FROM 절에 사용된 employees를 참조하고있음
- DEPENDENT SUBQUERY는 외부쿼리가 먼저 실행되고나서 내부 쿼리가 실행되야해서 일반 서브쿼리보다 느릴때가 많음

```sql
EXPLAIN
SELECT e.first_name,
  (
    SELECT (COUNT(*))
    FROM dept_emp de, dept_manager dm
    WHERE dm.dept_no = de.dept_no AND de.emp_no = e.emp_no
  ) AS cnt
FROM employees e
WHERE e.first_name = 'Matt';
```

| id  | select_type        | table | partitions | type | possible_keys                      | key               | key_len | ref                  | rows | filtered | Extra       |
| --- | ------------------ | ----- | ---------- | ---- | ---------------------------------- | ----------------- | ------- | -------------------- | ---- | -------- | ----------- |
| 1   | PRIMARY            | e     |            | ref  | ix_firstname,ix_lastname_firstname | ix_firstname      | 58      | const                | 233  | 100.0    | Using index |
| 2   | DEPENDENT SUBQUERY | de    |            | ref  | PRIMARY,ix_empno_fromdate          | ix_empno_fromdate | 4       | realmysql.e.emp_no   | 1    | 100.0    | Using index |
| 2   | DEPENDENT SUBQUERY | dm    |            | ref  | PRIMARY                            | PRIMARY           | 16      | realmysql.de.dept_no | 2    | 100.0    | Using index |

<br/>

### DERIVED

- SELECT 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블을 생성하는것
- DERIVED인 경우 생성되는 임시 테이블을 파생테이블이라고 부름
- 가능하면 DERIVED 타입으로 표시되도록 최적화를 하고, 더 좋은건 가능하면 서브쿼리는 조인으로 바꾸는것임

```sql
explain
select *
from (select de.emp_no from dept_emp de group by de.emp_no) tb, employees e
where e.emp_no = tb.emp_no;
```

| id  | select_type | table      | partitions | type   | possible_keys                         | key               | key_len | ref       | rows   | filtered | Extra       |
| --- | ----------- | ---------- | ---------- | ------ | ------------------------------------- | ----------------- | ------- | --------- | ------ | -------- | ----------- |
| 1   | PRIMARY     | <derived2> |            | ALL    |                                       |                   |         |           | 331143 | 100.0    |             |
| 1   | PRIMARY     | e          |            | eq_ref | PRIMARY                               | PRIMARY           | 4       | tb.emp_no | 1      | 100.0    |             |
| 2   | DERIVED     | de         |            | index  | PRIMARY,ix_fromdate,ix_empno_fromdate | ix_empno_fromdate | 7       |           | 331143 | 100.0    | Using index |

<br/>

### DEPENDENT DERIVED

- 8 버전 부터 레터럴 조인이 추가되면서 FROM 절의 서브쿼리에서도 외부 컬럼 참조가 가능해짐
- DEPENDENT DERIVED는 해당 테이블이 레터럴 조인으로 사용됬다는걸 표시함

```sql
explain
select *
from employees e
left join lateral
	(
		select *
		from salaries s
		where s.emp_no = e.emp_no
		order by s.from_date desc limit 2
	) as s2
on s2.emp_no = e.emp_no;
```

| id  | select_type       | table      | partitions | type | possible_keys | key         | key_len | ref                | rows   | filtered | Extra                      |
| --- | ----------------- | ---------- | ---------- | ---- | ------------- | ----------- | ------- | ------------------ | ------ | -------- | -------------------------- |
| 1   | PRIMARY           | e          |            | ALL  |               |             |         |                    | 300030 | 100.0    | Rematerialize (<derived2>) |
| 1   | PRIMARY           | <derived2> |            | ref  | <auto_key0>   | <auto_key0> | 4       | realmysql.e.emp_no | 2      | 100.0    |                            |
| 2   | DEPENDENT DERIVED | s          |            | ref  | PRIMARY       | PRIMARY     | 4       | realmysql.e.emp_no | 9      | 100.0    | Using filesort             |

<br/>

### UNCACHEABLE SUBQUERY

- 동일한 서브쿼리가 재사용될 경우 다시 쿼리를 실행하는게 아닌 캐싱된 결과를 사용한다
- 이 때 쿼리 캐시나 파생 테이블과는 전혀 무관하다
  - SUBQUERY는 바깥쪽의 영향을 받지 않아서 처음 한번만 실행해서 그 결과를 캐싱하고 필요할 때 사용한다
  - DEPENDENT SUBQUERY는 의존하는 바깥쪽 쿼리의 칼럼의 값 단위로 캐싱해서 사용한다
- SUBQUERY, UNCACHEABLE SUBQUERY 차이는 캐싱 가능여부의 차이다
- 사용자 변수가 서브쿼리에 사용, 스토어드 루틴, 랜덤값 등 일부 요소에서는 캐싱 사용이 불가능하다

```sql
explain
select *
from employees e
where e.emp_no = (
	select @status
	from dept_emp de
	where de.dept_no='d005'
);
```

| id  | select_type          | table | partitions | type | possible_keys                         | key     | key_len | ref   | rows   | filtered | Extra       |
| --- | -------------------- | ----- | ---------- | ---- | ------------------------------------- | ------- | ------- | ----- | ------ | -------- | ----------- |
| 1   | PRIMARY              | e     |            | ALL  |                                       |         |         |       | 300030 | 100.0    | Using where |
| 2   | UNCACHEABLE SUBQUERY | de    |            | ref  | PRIMARY,ix_fromdate,ix_empno_fromdate | PRIMARY | 16      | const | 165571 | 100.0    | Using index |

<br/>

### UNCACHEABLE UNION

- 유니온 연산에 대해서 캐싱할 수 없다는 뜻

<br/>

### MATERIALIZED

- 주로 FROM 절이나 IN(subquery) 형태의 쿼리에 사용된 서브쿼리의 최적화를 위해 사용
- 서브쿼리의 내용을 임시 테이블로 구체화 시키고나서 조인하는 형태로 진행됨

```sql
explain
select *
from employees e
where e.emp_no in (
	select emp_no
	from salaries s
	where salary BETWEEN 100 AND 200
);
```

| id  | select_type  | table       | partitions | type   | possible_keys     | key       | key_len | ref                | rows | filtered | Extra                    |
| --- | ------------ | ----------- | ---------- | ------ | ----------------- | --------- | ------- | ------------------ | ---- | -------- | ------------------------ |
| 1   | SIMPLE       | <subquery2> |            | ALL    |                   |           |         |                    |      | 100.0    |                          |
| 1   | SIMPLE       | e           |            | eq_ref | PRIMARY           | PRIMARY   | 4       | <subquery2>.emp_no | 1    | 100.0    |                          |
| 2   | MATERIALIZED | s           |            | range  | PRIMARY,ix_salary | ix_salary | 4       |                    | 1    | 100.0    | Using where; Using index |

<br/>

# Table 컬럼

- MySQL의 실행계획은 단위 SELECT 쿼리 기준이 아닌 테이블 기준으로 표시됨
- 만약 별도의 테이블을 사용하지 않는 쿼리의 경우는 NULL이 표시된다
- `<>`는 임시 테이블을 의미하며 내부에 표시되는 숫자는 단위 SELECT 쿼리의 id 값을 지칭함
  - ex) `<derived2>` : 단위 SELECT 쿼리의 id 값이 2인 실헹계획으로부터 마늘어진 파생테이블

### NULL인 경우

```sql
explain select now();
```

| id  | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra          |
| --- | ----------- | ----- | ---------- | ---- | ------------- | --- | ------- | --- | ---- | -------- | -------------- |
| 1   | SIMPLE      |       |            |      |               |     |         |     |      |          | No tables used |

<br/>

### <derived2> 인 경우

```sql
explain
select *
from (
	select de.emp_no
	from dept_emp de
	group by de.emp_no
) tb, employees e
where e.emp_no = tb.emp_no;
```

| id  | select_type | table      | partitions | type   | possible_keys                         | key               | key_len | ref       | rows   | filtered | Extra       |
| --- | ----------- | ---------- | ---------- | ------ | ------------------------------------- | ----------------- | ------- | --------- | ------ | -------- | ----------- |
| 1   | PRIMARY     | <derived2> |            | ALL    |                                       |                   |         |           | 331143 | 100.0    |             |
| 1   | PRIMARY     | e          |            | eq_ref | PRIMARY                               | PRIMARY           | 4       | tb.emp_no | 1      | 100.0    |             |
| 2   | DERIVED     | de         |            | index  | PRIMARY,ix_fromdate,ix_empno_fromdate | ix_empno_fromdate | 7       |           | 331143 | 100.0    | Using index |

<br/>

# partitions 컬럼

- 파티션 프루닝을 할때 어떤 파티션에서 데이터를 가져올지 보여주는 컬럼
  - 파티션 프루닝 : 파티션이 여러개인 테이블에서 불필요한 파티션을 빼고 쿼리를 수행하기 위해 접근해야할것으로 판단되는 테이블만 골라내는 작업
- `type`이 ALL인 이유는 대부분 RDBMS의 파티션은 테이블처럼 개별의 공간을 가지기때문에 특정 공간에 풀스캔을 통해 레코드를 가져온다

```sql
CREATE TABLE employees_2 (
    emp_no INT NOT NULL,
    birth_date DATE NOT NULL,
    first_name VARCHAR(14) NOT NULL,
    last_name VARCHAR(16) NOT NULL,
    gender ENUM('M', 'F') NOT NULL,
    hire_date DATE NOT NULL,
    PRIMARY KEY (emp_no, hire_date)
) PARTITION BY RANGE COLUMNS(hire_date) (
    PARTITION p1986_1990 VALUES LESS THAN ('1990-01-01'),
    PARTITION p1991_1995 VALUES LESS THAN ('1996-01-01'),
    PARTITION p1996_2000 VALUES LESS THAN ('2000-01-01'),
    PARTITION p2001_2005 VALUES LESS THAN ('2006-01-01')
);

insert into employees_2 select * from employees;

explain
select *
from employees_2
where hire_date BETWEEN '1999-11-15' and '2000-01-15';
```

| id  | select_type | table       | partitions            | type | possible_keys | key | key_len | ref | rows  | filtered | Extra       |
| --- | ----------- | ----------- | --------------------- | ---- | ------------- | --- | ------- | --- | ----- | -------- | ----------- |
| 1   | SIMPLE      | employees_2 | p1996_2000,p2001_2005 | ALL  |               |     |         |     | 22317 | 11.11    | Using where |

<br/>

# type 컬럼

- type 이후의 컬럼은 MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽엇는지 나타냄
- type은 실행계획에서 반드시 체크해야하는 정보임
- 여러가지 방법 중 ALL을 제외한 나머지 방법들은 모두 인덱스를 통한 접근방법임

<br/>

### system

- 레코드가 1건만 존재하거나 아에 없는 테이블을 참조하는 형태의 접근방법
- InnoDB엔 나타나지 않고, MyISAM, MEMORY에만 사용되는 방법임

<br/>

### const

- 쿼리가 기본키나 유니크 키 컬럼을 이용하는 WHERE을 사용하고, 반드시 1건을 반환하는 쿼리의 처리 방식
- 다른 DBMS에선 이를 유니크 인덱스 스캔이라고도 부름

```sql
explain
select * from employees where emp_no = 10001;
```

| id  | select_type | table     | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
| --- | ----------- | --------- | ---------- | ----- | ------------- | ------- | ------- | ----- | ---- | -------- | ----- |
| 1   | SIMPLE      | employees |            | const | PRIMARY       | PRIMARY | 4       | const | 1    | 100.0    |       |

<br/>

#### 내부적인 처리 방법

- 쿼리를 최적화하는 단계에서 쿼리를 먼저 실행하고, 해당 결과를 통째로 상수화함
- 옵티마이저에 의해 상수화된 다음 쿼리로 전달되기 때문에 접근 방법이 const로 보여짐

```sql
explain
select count(*)
from employees e1
where first_name=(select first_name from employees e2 where emp_no=10001);

-- where first_name='dongwoo'
```

| id  | select_type | table | partitions | type  | possible_keys                      | key          | key_len | ref   | rows | filtered | Extra       |
| --- | ----------- | ----- | ---------- | ----- | ---------------------------------- | ------------ | ------- | ----- | ---- | -------- | ----------- |
| 1   | PRIMARY     | e1    |            | ref   | ix_firstname,ix_lastname_firstname | ix_firstname | 58      | const | 252  | 100.0    | Using index |
| 2   | SUBQUERY    | e2    |            | const | PRIMARY                            | PRIMARY      | 4       | const | 1    | 100.0    |             |

<br/>

### eq_ref

- 여러 테이블이 조인되는 쿼리의 실행 계획에서 표시
- 조인에서 두번쨰 이후에 읽는 테이블에서 반드시 1건의 레코드만 존재한다는 보장이 있어야 사용가능한 방법

```sql
explain
select * from dept_emp de , employees e
where e.emp_no = de.emp_no and de.dept_no = 'd005';
```

| id  | select_type | table | partitions | type   | possible_keys             | key     | key_len | ref                 | rows   | filtered | Extra |
| --- | ----------- | ----- | ---------- | ------ | ------------------------- | ------- | ------- | ------------------- | ------ | -------- | ----- |
| 1   | SIMPLE      | de    |            | ref    | PRIMARY,ix_empno_fromdate | PRIMARY | 16      | const               | 165571 | 100.0    |       |
| 1   | SIMPLE      | e     |            | eq_ref | PRIMARY                   | PRIMARY | 4       | realmysql.de.emp_no | 1      | 100.0    |       |

<br/>

### ref

- 인덱스의 종류와 관계없이 동등(Equal) 조건으로 검색할때 사용되는 방법
- 동등한 조건으로만 검색되므로 매우 빠른 조회방법

```sql
explain
select * from dept_emp where dept_no = 'd005';
```

| id  | select_type | table    | partitions | type | possible_keys | key     | key_len | ref   | rows   | filtered | Extra |
| --- | ----------- | -------- | ---------- | ---- | ------------- | ------- | ------- | ----- | ------ | -------- | ----- |
| 1   | SIMPLE      | dept_emp |            | ref  | PRIMARY       | PRIMARY | 16      | const | 165571 | 100.0    |       |

<br/>

### fulltext

- 일반적으로 전문검색 문법을 사용하면 무조건 전문검색 인덱스를 사용함
- 전문 검색 인덱스는 통계정보가 관리되지 않고, 전혀 다른 SQL 문법(MATCH ... AGAINST ...)을 사용해야함
- 하지만 대부분의 경우는 일반 인덱스를 통한 레인지 스캔이 더 빠른경우가 많았음

<br/>

### ref_or_null

- ref 방식 또는 NULL을 비교 접근 방법을 의미함
- 많이 사용되지는 않지만 사용한다고 했을때 나쁘지 않은 정도다

```sql
explain
select * from titles t
where to_date = '1985-03-01' or to_date is null;
```

| id  | select_type | table | partitions | type        | possible_keys | key       | key_len | ref   | rows | filtered | Extra                    |
| --- | ----------- | ----- | ---------- | ----------- | ------------- | --------- | ------- | ----- | ---- | -------- | ------------------------ |
| 1   | SIMPLE      | t     |            | ref_or_null | ix_todate     | ix_todate | 4       | const | 2    | 100.0    | Using where; Using index |

<br/>

### unique_subquery

- WHERE 조건절에서 사용될 수 있는 IN(subquery) 형태의 쿼리를 위한 접근방법
- 서브쿼리에서 중복되지 않는 유니크한 값만 반환할때 이 접근 방법을 사용함
- 8 버전 이후부터는 세미 조인 최적화에 의해서 다른 계획이 산출됨

```sql
explain
select * from departments d
where d.dept_no in (
	select dept_no de
	from dept_emp de
	where emp_no=10001
);
```

| id  | select_type | table | partitions | type   | possible_keys             | key               | key_len | ref                  | rows | filtered | Extra       |
| --- | ----------- | ----- | ---------- | ------ | ------------------------- | ----------------- | ------- | -------------------- | ---- | -------- | ----------- |
| 1   | SIMPLE      | de    |            | ref    | PRIMARY,ix_empno_fromdate | ix_empno_fromdate | 4       | const                | 1    | 100.0    | Using index |
| 1   | SIMPLE      | d     |            | eq_ref | PRIMARY                   | PRIMARY           | 16      | realmysql.de.dept_no | 1    | 100.0    |             |

<br/>

### index_subquery

- 서브쿼리 결과의 중복된 값을 인덱스응 이용해서 제거할 수 있을때의 방법
- unique_subquery랑 다르게 중복된 값이 있지만 인덱스를 활용해서 제거할수 있을때 나오니 주의해야함

<br/>

### range

- 인덱스 레인지 스캔을 통한 접근을 사용하는 방법
- 주로 <, >, IS NULL, BETWEEN, IN, LIKE 등의 연산자를 이용해서 인덱스 검색시 사용됨
- 모든 쿼리가 이 방법만 사용해도 최적의 성능이 보장된다고 생각하면됨

```sql
explain
select *
from employees e
where emp_no BETWEEN 10001 AND 10004;
```

| id  | select_type | table | partitions | type  | possible_keys | key     | key_len | ref | rows | filtered | Extra       |
| --- | ----------- | ----- | ---------- | ----- | ------------- | ------- | ------- | --- | ---- | -------- | ----------- |
| 1   | SIMPLE      | e     |            | range | PRIMARY       | PRIMARY | 4       |     | 4    | 100.0    | Using where |

<br/>

### index_merge

- 2개 이상의 인덱스를 사용해 각각의 검색 결과를 만들고, 그 결과를 병합해서 처리하는 방식
- 이름만큼 효율적으로 동작하진 않음
  - 여러개의 인덱스를 읽어야 해서 레인지 접근 방법보다 효율성이 떨어짐
  - 전문 검색 인덱스의 경우 해당 방법 사용이 불가능함
  - 항상 2개 이상의 집합이 되기 때문에, 그 두 집합의 집합 또는 중복제거 같은 부가적인 작업이 필요함

```sql
-- BETWEEN 조건은 테이블의 기본키를 통한 레인지 접근
-- OR의 first_name은 ix_firstname 인덱스를 통해 접근
-- 이후의 각 결과를 병합하고 중복을 제거하는 방식
explain
select * from employees e
where emp_no BETWEEN 10001 AND 11000 or first_name='smith';
```

| id  | select_type | table | partitions | type        | possible_keys        | key                  | key_len | ref | rows | filtered | Extra                                          |
| --- | ----------- | ----- | ---------- | ----------- | -------------------- | -------------------- | ------- | --- | ---- | -------- | ---------------------------------------------- |
| 1   | SIMPLE      | e     |            | index_merge | PRIMARY,ix_firstname | PRIMARY,ix_firstname | 4,58    |     | 1001 | 100.0    | Using union(PRIMARY,ix_firstname); Using where |

<br/>

### index

- 이름만 보면 되게 좋아보이지만 해당 방법은 인덱스 풀 스캔을 의미함
- 아래 상황에서 주로 사용됨
  - range, const, ref 사용 불가
  - 인덱스에 포함된 컬럼만으로 처리가 가능할때
  - 인덱스를 이용해 정렬이나 그룹핑이 가능할때

```sql
explain
select dept_name from departments d
order by dept_name desc limit 10;
```

| id  | select_type | table | partitions | type  | possible_keys | key         | key_len | ref | rows | filtered | Extra                            |
| --- | ----------- | ----- | ---------- | ----- | ------------- | ----------- | ------- | --- | ---- | -------- | -------------------------------- |
| 1   | SIMPLE      | d     |            | index |               | ux_deptname | 162     |     | 9    | 100.0    | Backward index scan; Using index |

<br/>

### ALL

- 풀 테이블 스캔을 의미함
- 어떤 방식으로도 인덱스를 통해서 처리가 불가능한 경우 선택하는 매우 비효율적인 방법
- 다행히 InnoDB에선 read ahead 처럼 풀스캔시 한번에 많은 페이지를 읽는 최적화 방법을 제공해줌

<br/>

# possible_keys 컬럼

- 최적의 실행계획을 만들기 위해서 후보로 선정했던 접근 방법에서사용되는 인덱스의 목록
- 말 그대로 사용될뻔한 인덱스 목록을 보여주므로 특별한 경우를 제외하곤 그냥 무시하면됨

<br/>

# key 컬럼

- 실행계획 분석에서 최종 선택된 인덱스를 뜻함
- 쿼리튜닝을 할때는 key 컬럼에 의도한 인덱스가 존재하는지 확인하는게 중요함

<br/>

# key_len 컬럼

- 다중 컬럼으로 구성된 인덱스에서 몇 개의 컬럼까지 사용했는지를 나타냄

### len 계산 방법

- 아래 예제는 ix_dept_no 인덱스를 사용하는 경우임
- dept_no는 char(4) 자료형인 컬럼이다
- key가 16인 이유는 `utf8mb4에서 1자당 4바이트`를 차지하므로 `char(4) \* 4`로 16으로 나오는것이다

```sql
explain
select * from dept_emp where dept_no='d0005';
```

| id  | select_type | table    | partitions | type | possible_keys | key     | key_len | ref   | rows  | filtered | Extra       |
| --- | ----------- | -------- | ---------- | ---- | ------------- | ------- | ------- | ----- | ----- | -------- | ----------- |
| 1   | SIMPLE      | dept_emp |            | ref  | PRIMARY       | PRIMARY | 16      | const | 41392 | 100.0    | Using where |

<br/>

### 다중 인덱스를 사용하는 경우

- 여러개의 인덱스를 사용하는 경우 해당 인덱스의 길이 만큼 합산된다
- 아래 쿼리는 인덱스를 2개 사용해서 인덱스의 길이 2개가 합산된다
  - INT 타입은 4 바이트를 사용함
- 추가로 NOT NULL 컬럼의 경우 현재 값이 NULL 인지 판단하기 위해서 1 바이트를 추가로 사용함
  - ex) DATE 컬럼은 3 바이트를 차지하는데 NOT NULL인 경우 3 + 1로 총 4 바이트를 사용함

```sql
explain
select * from dept_emp where dept_no='d005' and emp_no = 10001;
```

| id  | select_type | table    | partitions | type  | possible_keys             | key     | key_len | ref         | rows | filtered | Extra |
| --- | ----------- | -------- | ---------- | ----- | ------------------------- | ------- | ------- | ----------- | ---- | -------- | ----- |
| 1   | SIMPLE      | dept_emp |            | const | PRIMARY,ix_empno_fromdate | PRIMARY | 20      | const,const | 1    | 100.0    |       |

<br/>

# ref 컬럼

- 참조(Equal 비교 조건)으로 어떤 값이 제공됬는지 알려줌
- const, func 등 일부 조건을 제외하면 컬럼명이 표시됨

### const

상수를 참조할떄 표시됨

```sql
explain
select *
from employees e, dept_emp de
where e.emp_no = de.emp_no;
```

| id  | select_type | table    | partitions | type  | possible_keys             | key     | key_len | ref         | rows | filtered | Extra |
| --- | ----------- | -------- | ---------- | ----- | ------------------------- | ------- | ------- | ----------- | ---- | -------- | ----- |
| 1   | SIMPLE      | dept_emp |            | const | PRIMARY,ix_empno_fromdate | PRIMARY | 20      | const,const | 1    | 100.0    |       |

<br/>

### func

- 함수의 줄임말로 참조용으로 사용되는 값을 그대로 사용한것이 아닌, 콜레이션 변환/값 자체 연산을 거쳐서 참조됬다는것을 의미함
- 가능하면 이런 변환을 하지 않아도 되도록 조인 컬럼의 타입은 일치시키는 편이 좋음

```sql
	explain
	select *
	from employees e, dept_emp de
	where e.emp_no = (de.emp_no - 1);
```

| id  | select_type | table | partitions | type   | possible_keys | key     | key_len | ref  | rows   | filtered | Extra       |
| --- | ----------- | ----- | ---------- | ------ | ------------- | ------- | ------- | ---- | ------ | -------- | ----------- |
| 1   | SIMPLE      | de    |            | ALL    |               |         |         |      | 331143 | 100.0    |             |
| 1   | SIMPLE      | e     |            | eq_ref | PRIMARY       | PRIMARY | 4       | func | 1      | 100.0    | Using where |

<br/>

# rows 컬럼

- 실행 계획의 효율성 판단을 위해서 예측했던 레코드 수를 보여줌
- 각 스토리지 엔진별로 갖고있는 통계 정보를 통해 만들어낸 값이라 정확하지는 않음

### 레코드가 많을때

- 33만건을 모두 풀스캔으로 처리했다
- 이는 인덱스만으로는 처리가 불가능해서 풀스캔을 통해 조건부를 처리해야된다고 판단했다
- 이는 예측 수치일 뿐이며 정확한 값이 아니다. 정확도를 위해서는 히스토그램을 사용하자

```sql
explain
select *
from dept_emp where from_date >= '1985-01-01';
```

| id  | select_type | table    | partitions | type | possible_keys | key | key_len | ref | rows   | filtered | Extra       |
| --- | ----------- | -------- | ---------- | ---- | ------------- | --- | ------- | --- | ------ | -------- | ----------- |
| 1   | SIMPLE      | dept_emp |            | ALL  | ix_fromdate   |     |         |     | 331143 | 50.0     | Using where |

<br/>

### 레코드가 적을때

- 범위를 좁혀서 적은 개수의 레코드만 스캔해도 된다고 판단했다
- 총 292개의 레코드를 읽었다

```sql
explain
select *
from dept_emp where from_date >= '2002-07-01';
```

| id  | select_type | table    | partitions | type  | possible_keys | key         | key_len | ref | rows | filtered | Extra                 |
| --- | ----------- | -------- | ---------- | ----- | ------------- | ----------- | ------- | --- | ---- | -------- | --------------------- |
| 1   | SIMPLE      | dept_emp |            | range | ix_fromdate   | ix_fromdate | 3       |     | 292  | 100.0    | Using index condition |

<br/>

# filtered 컬럼

- 값이 필터링되어 버려지는 레코드의 비율이 아닌, 필터링 되고 남은 레코드의 비율을 의미
- 해당 컬럼에 표시되는 값이 얼마나 정확히 예측이 가능한지에 따라 조인 성능이 달라짐
- 8 버전 부터는 히스토그램을 통해서 좀 더 정확히 예측이 가능해졌음

```sql
explain
select *
from employees e , salaries s
where e.first_name = 'Matt'
and e.hire_date BETWEEN '1990-01-01' AND '1991-01-01'
and s.emp_no = e.emp_no
and s.from_date between '1990-01-01' and '1991-01-01'
and s.salary BETWEEN 50000 AND 60000;
```

| id  | select_type | table | partitions | type | possible_keys                    | key          | key_len | ref                | rows | filtered | Extra       |
| --- | ----------- | ----- | ---------- | ---- | -------------------------------- | ------------ | ------- | ------------------ | ---- | -------- | ----------- |
| 1   | SIMPLE      | e     |            | ref  | PRIMARY,ix_hiredate,ix_firstname | ix_firstname | 58      | const              | 233  | 16.65    | Using where |
| 1   | SIMPLE      | s     |            | ref  | PRIMARY,ix_salary                | PRIMARY      | 4       | realmysql.e.emp_no | 9    | 4.77     | Using where |

<br/>

# Extra 컬럼

- 주로 내부적인 처리 알고리즘에 대해서 좀 더 깊이있는 내용을 보여줌
- 이ㅁ과는 다르게 성능에 관련된 중요한 내용이 자주 나오니 중요시해야함

### const row not found

- const 접근 방법으로 레코드를 읽었지만, 실제로 존재하지 않을떄 표시됨

<br/>

### Deleting all rows

- WHERE 조건절이 없는 DELETE 쿼리에서 자주 표시됨
- 이전에는 각 레코드를 하나씩 지웠지만 해당 기능은 한번에 제거한것을 의미함
- 현재는 더이상 표시되지 않는 컬럼임
- 모든 레코드를 지워야할때는 DELETE 대신 TRUNCATE 쿼리를 사용하는걸 추천함

<br/>

### Distinct

- 아래 쿼리는 dept_emp, departments 테이블에 서로 존재하는 데이터를 읽는 쿼리가
- 최종 반환값에는 DISTINCT를 처리하기 위해 필요한것만 조인했고, 필요한 레코드만 읽은걸 의미한다

```sql
explain
select DISTINCT d.dept_no
from departments d, dept_emp de
where de.dept_no = d.dept_no;
```

| id  | select_type | table | partitions | type  | possible_keys       | key         | key_len | ref                 | rows  | filtered | Extra                        |
| --- | ----------- | ----- | ---------- | ----- | ------------------- | ----------- | ------- | ------------------- | ----- | -------- | ---------------------------- |
| 1   | SIMPLE      | d     |            | index | PRIMARY,ux_deptname | ux_deptname | 162     |                     | 9     | 100.0    | Using index; Using temporary |
| 1   | SIMPLE      | de    |            | ref   | PRIMARY             | PRIMARY     | 16      | realmysql.d.dept_no | 41392 | 100.0    | Using index; Distinct        |

<br/>

### FirstMatch

- 세미조인의 최적화 전략 중 FirstMatch 방식을 사용하면 표시됨
- employees 테이블을 기준으로 titles 테이블에서 첫번째로 일치하는 한건만 검색함

```sql
explain
select * from employees e
where e.first_name = 'Matt'
and e.emp_no in (
	select t.emp_no
	from titles t
	where t.from_date BETWEEN '1995-01-01' AND '1995-01-30'
);
```

| id  | select_type | table | partitions | type | possible_keys        | key          | key_len | ref                | rows | filtered | Extra                                   |
| --- | ----------- | ----- | ---------- | ---- | -------------------- | ------------ | ------- | ------------------ | ---- | -------- | --------------------------------------- |
| 1   | SIMPLE      | e     |            | ref  | PRIMARY,ix_firstname | ix_firstname | 58      | const              | 233  | 100.0    |                                         |
| 1   | SIMPLE      | t     |            | ref  | PRIMARY              | PRIMARY      | 4       | realmysql.e.emp_no | 1    | 11.11    | Using where; Using index; FirstMatch(e) |

<br/>

### Full scan on NULL key

- `col1 IN (SELECT col2 FROM ...)` 조건 쿼리에서 col1이 NULL인 경우 테이블 풀스캔이 요구됨
- 해당 키워드는 쿼리 실행도중 만약 COL1에 NULL이 있다면 서브쿼리 테이블에 대해서 풀스캔을 할꺼라는 사실을 알려주는 키워드
- 만약 NULL 규칙을 무시해도 된다면 `WHERE col1 IS NOT NULL` 조건을 알려주면된다
- 만약 해당 계획이 표시되도 실제로 NULL이 없다면 풀스캔은 되지 않으니 안심해도된다

```sql
explain
select d.dept_no, NULL IN (select d2.dept_name from departments d2)
from departments d;
```

| id  | select_type | table | partitions | type           | possible_keys | key         | key_len | ref  | rows | filtered | Extra                                           |
| --- | ----------- | ----- | ---------- | -------------- | ------------- | ----------- | ------- | ---- | ---- | -------- | ----------------------------------------------- |
| 1   | PRIMARY     | d     |            | index          |               | ux_deptname | 162     |      | 9    | 100.0    | Using index                                     |
| 2   | SUBQUERY    | d2    |            | index_subquery | ux_deptname   | ux_deptname | 162     | func | 1    | 100.0    | Using where; Using index; Full scan on NULL key |

<br/>

### Impossible HAVING

- GROUP BY ~ HAVING 절에 조건을 만족하는 레코드가 없을때 표시됨
- 해당 메세지가 표현되는 경우는 쿼리가 잘못된 경우니 다시 확인하는게 좋다

```sql
explain
select e.emp_no, COUNT(*) as cnt
from employees e
where e.emp_no = 10001
GROUP BY e.emp_no
HAVING e.emp_no is null
```

| id  | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra             |
| --- | ----------- | ----- | ---------- | ---- | ------------- | --- | ------- | --- | ---- | -------- | ----------------- |
| 1   | SIMPLE      |       |            |      |               |     |         |     |      |          | Impossible HAVING |

<br/>

### Loose Scan

- 세미조인 최적화 중 Loose Scan 방식을 사용하면 표시됨

```sql
explain
select * from departments d where d.dept_no IN (
	select de.dept_no from dept_emp de
);
```

| id  | select_type | table | partitions | type  | possible_keys | key     | key_len | ref | rows   | filtered | Extra                                      |
| --- | ----------- | ----- | ---------- | ----- | ------------- | ------- | ------- | --- | ------ | -------- | ------------------------------------------ |
| 1   | SIMPLE      | de    |            | index | PRIMARY       | PRIMARY | 20      |     | 331143 | 0.0      | Using index; LooseScan                     |
| 1   | SIMPLE      | d     |            | ALL   | PRIMARY       |         |         |     | 9      | 11.11    | Using where; Using join buffer (hash join) |

<br/>

### No matching min/max row

- MIN, MAX 같은 집합 함수가 있는 쿼리의 조건절에 일치하는 레코드가 한건도 없을때 나옴
- 또한 결과값으로 NULL이 반환됨

```sql
explain
select min(dept_no), max(dept_no)
from dept_emp de
where dept_no='';
```

| id  | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra                   |
| --- | ----------- | ----- | ---------- | ---- | ------------- | --- | ------- | --- | ---- | -------- | ----------------------- |
| 1   | SIMPLE      |       |            |      |               |     |         |     |      |          | No matching min/max row |

<br/>

### no matching row in const table

- const 방법으로 접근할때 일치하는 레코드가 없는 경우 표시됨
- Impossible WHERE 처럼 실행 계획을 만들기 위한 자료가 없다는 의미임

```sql
explain
select *
from dept_emp de, (
	select emp_no
	from employees e
	where emp_no = 0
) tb1
where tb1.emp_no = de.emp_no and de.dept_no = 'd005';
```

| id  | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra                          |
| --- | ----------- | ----- | ---------- | ---- | ------------- | --- | ------- | --- | ---- | -------- | ------------------------------ |
| 1   | SIMPLE      |       |            |      |               |     |         |     |      |          | no matching row in const table |

<br/>

### No matching rows after partition pruning

- UPDATE, DELETE 쿼리에서 표시될 수 있는 메세지
- 해당 파티션에서 수정이나 삭제할 대상 레코드가 없다는것을 의미함

<br/>

### No tables used

- FROM 절이 없는 쿼리나 DUAL 테이블을 사용하는 경우 나옴

<br/>

### Not exists

- 프로그램을 개발하다보면 A 테이블에는 있지만 B 테이블에는 없는 데이터를 조회할일이 생김
- 보통 안티조인 형태의 `NOT IN (subquery)` 또는 `NOT EXISTS` 연산자를 주로 사용하게됨
- 가능하면 똑같은 형태의 LEFT OUTER JOIN 형태로 쿼리를 처리하는게 좋음
- 해당 메세지는 조인 조건에 일치하는 레코드가 여러건이 있다고 해도 딱 1건만 조회해보고 처리를 완료하는걸 의미함

```sql
explain
select *
from dept_emp de
left join departments d on de.dept_no = d.dept_no
where d.dept_no is null
```

| id  | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows   | filtered | Extra                                                  |
| --- | ----------- | ----- | ---------- | ---- | ------------- | --- | ------- | --- | ------ | -------- | ------------------------------------------------------ |
| 1   | SIMPLE      | de    |            | ALL  |               |     |         |     | 331143 | 100.0    |                                                        |
| 1   | SIMPLE      | d     |            | ALL  | PRIMARY       |     |         |     | 9      | 11.11    | Using where; Not exists; Using join buffer (hash join) |

<br/>

### Plan isn't ready yet

- MySQL의 경우 다른 커넥션에서 실행중인 쿼리에 대한 실행계획 확인이 가능함
  - `EXPLAIN FOR CONNECTION <connection_id>`
- 해당 메세지는 특정 커넥션에서 아직 쿼리의 실행계획을 수립하지 못한상태를 의미함

<br/>

### Range checked for each record(index map: N)

- 해당 내용은 하나의 레코드마다 인덱스 레인지 스캔을 수행한다는것을 의미함
- `index map: N`의 경우 사용할지 말지를 판단하는 후보 인덱스의 순서를 의미함
  - 첫번째 인덱스의 경우 `SHOW CREATE TABLE <table_name>`에서 나오는 인덱스 생성순서를 의미함
- type이 ALL인 이유는 인덱스 사용여부를 검토하고, 별로 도움이 안되면 풀스캔을 한다고 알려주는것임

```sql
explain
select *
from employees e1, employees e2
where e2.emp_no > e1.emp_no;
```

| id  | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows   | filtered | Extra                                          |
| --- | ----------- | ----- | ---------- | ---- | ------------- | --- | ------- | --- | ------ | -------- | ---------------------------------------------- |
| 1   | SIMPLE      | e1    |            | ALL  | PRIMARY       |     |         |     | 300252 | 100.0    |                                                |
| 1   | SIMPLE      | e2    |            | ALL  | PRIMARY       |     |         |     | 300252 | 33.33    | Range checked for each record (index map: 0x1) |

#### 상세 메세지 파악하기

- 메세지가 `(index map: 0x19)`인 경우를 가정한다
- 16진수 `0x19`를 2진수로 변환하면 `11001`이 된다
- 아래 인덱스 구조를 기준으로 사용할지 말지 판단하는 인덱스는 아래와 같다
  - PRIMARY KEY
  - ix_firstname
  - ix_gender_birthdate

```sql
CREATE TABLE `employees` (
  `emp_no` int NOT NULL,
  `birth_date` date NOT NULL,
  `first_name` varchar(14) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `last_name` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `gender` enum('M','F') CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `hire_date` date NOT NULL,
  PRIMARY KEY (`emp_no`),
  KEY `ix_hiredate` (`hire_date`),
  KEY `ix_gender_birthdate` (`gender`,`birth_date`),
  KEY `ix_firstname` (`first_name`),
  KEY `ix_gender_birthdata` (`gender`,`birth_date`),
  KEY `ix_lastname_firstname` (`last_name`,`first_name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci STATS_PERSISTENT=0
```

<br/>

### Recursive

- CTE(Common Table Expression)를 이용한 재귀쿼리 함수에 표시된다
- WITH와 CTE만 사용했다고 나오는게 아니라 실제 재귀쿼리인 경우만 표시됨

```sql
explain
with recursive cte (n) AS (
	select 1
	union all
	select n + 1 from cte where n < 5
)
select * from cte;
```

| id  | select_type | table      | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra                  |
| --- | ----------- | ---------- | ---------- | ---- | ------------- | --- | ------- | --- | ---- | -------- | ---------------------- |
| 1   | PRIMARY     | <derived2> |            | ALL  |               |     |         |     | 3    | 100.0    |                        |
| 2   | DERIVED     |            |            |      |               |     |         |     |      |          | No tables used         |
| 3   | UNION       | cte        |            | ALL  |               |     |         |     | 2    | 50.0     | Recursive; Using where |

<br/>

### Rematerialize

- 레터럴 조인으로 테이블은 선행 테이블의 레코드별로 서브쿼리를 실행해서 임시테이블로 저장하는데 이런 과정을 Rematerialize 메세지로 표시함
- 매번 임시 테이블이 새로 생성되는 경우 표시됨

```sql
explain
select * from employees e
left join lateral (
	select *
	from salaries s
	where s.emp_no = e.emp_no
	order by s.from_date desc limit 2
) s2
on s2.emp_no = e.emp_no
where e.first_name = 'Matt';
```

| id  | select_type       | table      | partitions | type | possible_keys | key          | key_len | ref                | rows | filtered | Extra                      |
| --- | ----------------- | ---------- | ---------- | ---- | ------------- | ------------ | ------- | ------------------ | ---- | -------- | -------------------------- |
| 1   | PRIMARY           | e          |            | ref  | ix_firstname  | ix_firstname | 58      | const              | 233  | 100.0    | Rematerialize (<derived2>) |
| 1   | PRIMARY           | <derived2> |            | ref  | <auto_key0>   | <auto_key0>  | 4       | realmysql.e.emp_no | 2    | 100.0    |                            |
| 2   | DEPENDENT DERIVED | s          |            | ref  | PRIMARY       | PRIMARY      | 4       | realmysql.e.emp_no | 9    | 100.0    | Using filesort             |

<br/>

### Select tables optimized away

- MIN, MAX만 SELECT에 사용되는 경우
- GROUP BY로 MIN, MAX를 조회하는 쿼리가 인덱스를 오름, 내림 차순으로 1건만 읽는 형태의 최적화
- 위 2가지 과정에서 표시됨

<br/>

### Start temporary, End temporary

- 세미조인 최적화 중 Duplicate Weed-out 전략이 사용되면 표시됨
- 해당 조건은 중복건 제거를 위해서 내부에 임시 테이블을 사용하는데, 해당 테이블 식별이 가능하게 표시해줌

<br/>

### unique row not found

- 두개의 테이블이 각각 유니크 컬럼으로 아우터 조인을 수행하는 쿼리에서 아우터 테이블에 일치하는 레코드가 없을때 표시
  - 유니크 컬럼에는 기본키도 포함됨

<br/>

### Using Filesort

- ORDER BY 처리시 인덱스를 통한 처리가 불가능하면 소트버퍼로 CPU 연산을 통해 처리됨
- 이런 경우 출력되며, 가능하면 인덱스를 통해 처리가 가능하도록 쿼리튜닝 / 인덱스 생성을 권장함

<br/>

### Using Index(커버링 인덱스)

- 레코드를 전혀 읽지 않고 인덱스만 읽어서 쿼리를 모두 처리가능한 경우 표시됨
- 하지만 특정 상황에서는 풀스캔 처리가 효율이 좋은경우도 존재함
- InnoDB의 경우 클러스터링 인덱스 특성으로 인해서 대부분 커버링 인덱스로 처리되는 경우가 많음
- type 컬럼에 index와는 다르므로 주의해야함

<br/>

### Using index condition

- 인덱스 컨디션 푸시다운 최적화가 적용된 경우 표시됨
- 해당 최적화는 인덱스를 통해서 어느정도 읽어야되는 범위를 먼저 만들고 이후에 스토리지 엔진을 통해 읽는 방법임

<br/>

### Using index for group-by

- group by 처리가 인덱스를 이용할때 표시됨, 즉 루스 인덱스 스캔인 경우임

#### 타이트 인덱스 스캔을 통한 group by

- SUM, AVG 처럼 조회하려는 값이 모든 인덱스를 다 읽어야하는 경우
- 이런 경우는 루스 인덱스 스캔이 아니므로 표시되지 않음

#### 루스 인덱스 스캔을 통한 group by

- 그루핑 컬럼 외에는 아무것도 조회하지 않는 쿼리에서 사용이 가능함
- 또한 MIN, MAX 처럼 인덱스의 처음이나 마지막만 읽어야하는 경우 사용이 가능함
- 하지만 이 때 WHERE 절의 조건에 따라서도 GROUP BY 처리시 인덱스 사용여부에 영향을 미침

<br/>

### Using index for skip scan

- 인덱스 스킵 스캔 최적화를 사용하는 경우 표시됨
- 루스 인덱스 스캔을 확장한 기능이며 아직 부족한 부분이 많음, 하지만 잘 알아둬야함

<br/>

### Using join buffer(<JOIN_ALGORITHM>)

- 조인 버퍼가 사용되는 경우 표시됨

<br/>

### Using MRR

- 스토리지 엔진 레벨에서 최적화를 개선하기 위해 도입된 기능이다
- 해당 기능이 사용되는 경우 표시됨

<br/>

### Using sort_union, Using_union, Using intersect

- 인덱스 머지 방법을 사용할때 2개의 인덱스로 검색한 결과를 어떻게 병합했는지 힌트를 표시함
- 해당 힌트에 위 메세지가 출력됨

<br/>

### Using Temporary

- 임시 테이블을 사용한것을 의미함
- 대표적으로 GROUP BY 쿼리에서 인덱스를 사용하지 못하는 경우 표시됨

<br/>

### Using where

- MySQL 엔진 레이어에서 별도의 가공을 해서 필터링 작업을 처리한 경우 표시됨
- 작업 범위 결정 조건은 스토리지 엔진 레벨에서 처리되지만, 체크 조건은 MySQL 엔진 레이어에서 처리됨

<br/>

### Zero Limit

- 때로는 실제 레코드가 아닌 쿼리 결과값에 메타데이터만 필요한 경우가 존재함
- 실제 레코드를 전혀 읽지 않고, 메타데이터 정보만 반환하는 경우 표시됨
