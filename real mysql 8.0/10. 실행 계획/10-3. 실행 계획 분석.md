# 실행 계획 분석

- 표의 각 라인은 쿼레엇 사용한 테이블의 개수만큼 출력됨
- 위에 있을수록 쿼리의 바깥 부분이거나 먼저 접근한 테이블이다
- 아래에 있을수록 쿼리의 안쪽 부분이나 나중에 접근한 테이블에 해당된다

<br/>

# ID 컬럼

- id 컬럼은 단위 SELECT 쿼리별로 부여되는 식별자 값이다
- SELECT가 한개이고, 여러개의 테이블이 조인되면 id값이 증가하지 않고 같은값이 부여된다
- N개의 단위 SELECT 쿼리로 구성하는 경우 id값이 서로 다른 값을 가진다
- id 컬럼은 테이블의 접근순서를 의미하진 않는다. 순서는 EXPLAIN ANALYZE로 확인하자

<br/>

# select_type 컬럼

각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시하는 컬럼

<br/>

### SIMPLE

- UNION, 서브쿼리를 사용하지 않은 단순한 쿼리다
- 일반적으로 제일 바깥의 SELECT 쿼리에서 표시된다

<br/>

### PRIMARY

- UNION, 서브쿼리를 가지는 SELECT 쿼리의 실행계획에서 제일 바깥쪽에 있는 단위 쿼리에 표시된다
- PRIMARY 단위의 쿼리는 하나만 존재하고, 제일 바깥쪽에 있는 SELECT 단위 쿼리에 표시된다

<br/>

### UNION

- UNION으로 결합하는 단위 SELECT 쿼리 카운데 첫 번째를 제외한 두번째 이후 단위 SELECT 쿼리에 표시됨
- 첫번쨰 단위 SELECT에는 DERIVED로 표시되는데, 이는 UNION되는 결과들을 모아서 저장하는 임시테이블을 뜻한다

#### 실행계획

```sql
explain
select * from (
	(
		select emp_no from employees e1 LIMIT 10
	) UNION ALL
	(
		select emp_no from employees e2 LIMIT 10
	) UNION ALL
	(
		select emp_no from employees e3 LIMIT 10
	)
) tb;

```

| id  | select_type | table      | partitions | type  | possible_keys | key         | key_len | ref | rows   | filtered | Extra       |
| --- | ----------- | ---------- | ---------- | ----- | ------------- | ----------- | ------- | --- | ------ | -------- | ----------- |
| 1   | PRIMARY     | <derived2> |            | ALL   |               |             |         |     | 30     | 100.0    |             |
| 2   | DERIVED     | e1         |            | index |               | ix_hiredate | 3       |     | 300030 | 100.0    | Using index |
| 3   | UNION       | e2         |            | index |               | ix_hiredate | 3       |     | 300030 | 100.0    | Using index |
| 4   | UNION       | e3         |            | index |               | ix_hiredate | 3       |     | 300030 | 100.0    | Using index |

- e1 테이블은 조인 결과를 모아서 처리하는 임시테이블로 DERIVED 타입으로 표시된다
- 그 외 나머지 테이블은 UNION 이라고 표시됬다

<br/>

### DEPENDENT UNION

- UNION이랑 마찬가지로 UNION, UNION ALL로 집합을 결합하는 쿼리에서 표시됨
- DEPENDENT는 결합된 단위 쿼리가 외부 쿼리에 의해서 영향을 받는 것을 의미함
- 즉 내부 쿼리가 외부의 값을 참조해서 처리될 때 DEPENDENT 타입으로 표시된다

#### 실행계획

```sql
explain
SELECT *
FROM employees e1 WHERE e1.emp_no IN (
	SELECT e2.emp_no FROM employees e2 WHERE e2.first_name = 'Matt'
	UNION
	SELECT e3.emp_no FROM employees e3 WHERE e3.last_name = 'Matt'
);
```

| id  | select_type        | table      | partitions | type   | possible_keys                              | key     | key_len | ref  | rows   | filtered | Extra           |
| --- | ------------------ | ---------- | ---------- | ------ | ------------------------------------------ | ------- | ------- | ---- | ------ | -------- | --------------- |
| 1   | PRIMARY            | e1         |            | ALL    |                                            |         |         |      | 300030 | 100.0    | Using where     |
| 2   | DEPENDENT SUBQUERY | e2         |            | eq_ref | PRIMARY,ix_firstname,ix_lastname_firstname | PRIMARY | 4       | func | 1      | 5.0      | Using where     |
| 3   | DEPENDENT UNION    | e3         |            | eq_ref | PRIMARY,ix_lastname_firstname              | PRIMARY | 4       | func | 1      | 5.0      | Using where     |
| 4   | UNION RESULT       | <union2,3> |            | ALL    |                                            |         |         |      |        |          | Using temporary |

- e2, e3을 UNION한 결과가 UNION RESULT 타입으로 표시된다
- 내부적으로 e1.emp_no = e2.emp_no, e1.emp_no = e3.emp_no 조건이 추가됨
- 외부에 정의된 e1 테이블의 영향을 받았기 때문에 DEPENDENT UNION 타입으로 표시됨

<br/>

### UNION RESULT

- UNION 처리에 대한 결과를 담아두는 테이블
- UNION (UNION DISTINCT)는 여전히 임시 테이블에 결과를 버퍼함
- `<union1, 2>`에서 1, 2는 값이 1인 단위 쿼리의 조회 결과와 id가 2인 단위 쿼리의 조회 결과를 조합했다는걸 의미함

```sql
explain
select emp_no from salaries where salary > 100000
union DISTINCT
select emp_no from dept_emp where from_Date > '2001-01-01';
```

| id  | select_type  | table      | partitions | type  | possible_keys                 | key         | key_len | ref | rows   | filtered | Extra                    |
| --- | ------------ | ---------- | ---------- | ----- | ----------------------------- | ----------- | ------- | --- | ------ | -------- | ------------------------ |
| 1   | PRIMARY      | salaries   |            | range | ix_salary                     | ix_salary   | 4       |     | 188518 | 100.0    | Using where; Using index |
| 2   | UNION        | dept_emp   |            | range | ix_fromdate,ix_empno_fromdate | ix_fromdate | 3       |     | 5325   | 100.0    | Using where; Using index |
| 3   | UNION RESULT | <union1,2> |            | ALL   |                               |             |         |     |        |          | Using temporary          |

<br/>

### SUBQUERY

- FROM에서 사용된 서브쿼리는 DERIVED로 표시되고, 그 외의 서브쿼리는 모두 SUBQUERY 타입으로 표시됨
- 서브쿼리는 사용되는 위치에 따라서 각각 다른 이름을 지님
  - 중첩쿼리(Nested Query) : SELECT 되는 컬럼에 사용되는 서브쿼리
  - 서브쿼리(Subquery) : WHERE에 사용하는 쿼리는 일반적으로 그냥 서브쿼리라고 부름
  - 파생테이블(Derived Table) : FROM 절에 사용된 서브쿼리

```sql
EXPLAIN
SELECT e.first_name,
  (
    SELECT (COUNT(*))
    FROM dept_emp de, dept_manager dm
    WHERE dm.dept_no = de.dept_no
  ) AS cnt
FROM employees e
WHERE e.emp_no = 10001;
```

| id  | select_type | table | partitions | type  | possible_keys | key     | key_len | ref                  | rows  | filtered | Extra       |
| --- | ----------- | ----- | ---------- | ----- | ------------- | ------- | ------- | -------------------- | ----- | -------- | ----------- |
| 1   | PRIMARY     | e     |            | const | PRIMARY       | PRIMARY | 4       | const                | 1     | 100.0    |             |
| 2   | SUBQUERY    | dm    |            | index | PRIMARY       | PRIMARY | 20      |                      | 24    | 100.0    | Using index |
| 2   | SUBQUERY    | de    |            | ref   | PRIMARY       | PRIMARY | 16      | realmysql.dm.dept_no | 41392 | 100.0    | Using index |

<br/>

### DEPENDENT SUBQUERY

- 서브쿼리가 바깥쪽 SELECT 쿼리에서 정의된 컬럼을 사용하는 경우 DEPENDENT SUBQUERY 타입으로 표시됨
- 아래 쿼리에서는 SELECT의 서브쿼리가 FROM 절에 사용된 employees를 참조하고있음
- DEPENDENT SUBQUERY는 외부쿼리가 먼저 실행되고나서 내부 쿼리가 실행되야해서 일반 서브쿼리보다 느릴때가 많음

```sql
EXPLAIN
SELECT e.first_name,
  (
    SELECT (COUNT(*))
    FROM dept_emp de, dept_manager dm
    WHERE dm.dept_no = de.dept_no AND de.emp_no = e.emp_no
  ) AS cnt
FROM employees e
WHERE e.first_name = 'Matt';
```

| id  | select_type        | table | partitions | type | possible_keys                      | key               | key_len | ref                  | rows | filtered | Extra       |
| --- | ------------------ | ----- | ---------- | ---- | ---------------------------------- | ----------------- | ------- | -------------------- | ---- | -------- | ----------- |
| 1   | PRIMARY            | e     |            | ref  | ix_firstname,ix_lastname_firstname | ix_firstname      | 58      | const                | 233  | 100.0    | Using index |
| 2   | DEPENDENT SUBQUERY | de    |            | ref  | PRIMARY,ix_empno_fromdate          | ix_empno_fromdate | 4       | realmysql.e.emp_no   | 1    | 100.0    | Using index |
| 2   | DEPENDENT SUBQUERY | dm    |            | ref  | PRIMARY                            | PRIMARY           | 16      | realmysql.de.dept_no | 2    | 100.0    | Using index |

<br/>

### DERIVED

- SELECT 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블을 생성하는것
- DERIVED인 경우 생성되는 임시 테이블을 파생테이블이라고 부름
- 가능하면 DERIVED 타입으로 표시되도록 최적화를 하고, 더 좋은건 가능하면 서브쿼리는 조인으로 바꾸는것임

```sql
explain
select *
from (select de.emp_no from dept_emp de group by de.emp_no) tb, employees e
where e.emp_no = tb.emp_no;
```

| id  | select_type | table      | partitions | type   | possible_keys                         | key               | key_len | ref       | rows   | filtered | Extra       |
| --- | ----------- | ---------- | ---------- | ------ | ------------------------------------- | ----------------- | ------- | --------- | ------ | -------- | ----------- |
| 1   | PRIMARY     | <derived2> |            | ALL    |                                       |                   |         |           | 331143 | 100.0    |             |
| 1   | PRIMARY     | e          |            | eq_ref | PRIMARY                               | PRIMARY           | 4       | tb.emp_no | 1      | 100.0    |             |
| 2   | DERIVED     | de         |            | index  | PRIMARY,ix_fromdate,ix_empno_fromdate | ix_empno_fromdate | 7       |           | 331143 | 100.0    | Using index |

<br/>

### DEPENDENT DERIVED

- 8 버전 부터 레터럴 조인이 추가되면서 FROM 절의 서브쿼리에서도 외부 컬럼 참조가 가능해짐
- DEPENDENT DERIVED는 해당 테이블이 레터럴 조인으로 사용됬다는걸 표시함

```sql
explain
select *
from employees e
left join lateral
	(
		select *
		from salaries s
		where s.emp_no = e.emp_no
		order by s.from_date desc limit 2
	) as s2
on s2.emp_no = e.emp_no;
```

| id  | select_type       | table      | partitions | type | possible_keys | key         | key_len | ref                | rows   | filtered | Extra                      |
| --- | ----------------- | ---------- | ---------- | ---- | ------------- | ----------- | ------- | ------------------ | ------ | -------- | -------------------------- |
| 1   | PRIMARY           | e          |            | ALL  |               |             |         |                    | 300030 | 100.0    | Rematerialize (<derived2>) |
| 1   | PRIMARY           | <derived2> |            | ref  | <auto_key0>   | <auto_key0> | 4       | realmysql.e.emp_no | 2      | 100.0    |                            |
| 2   | DEPENDENT DERIVED | s          |            | ref  | PRIMARY       | PRIMARY     | 4       | realmysql.e.emp_no | 9      | 100.0    | Using filesort             |

<br/>

### UNCACHEABLE SUBQUERY

- 동일한 서브쿼리가 재사용될 경우 다시 쿼리를 실행하는게 아닌 캐싱된 결과를 사용한다
- 이 때 쿼리 캐시나 파생 테이블과는 전혀 무관하다
  - SUBQUERY는 바깥쪽의 영향을 받지 않아서 처음 한번만 실행해서 그 결과를 캐싱하고 필요할 때 사용한다
  - DEPENDENT SUBQUERY는 의존하는 바깥쪽 쿼리의 칼럼의 값 단위로 캐싱해서 사용한다
- SUBQUERY, UNCACHEABLE SUBQUERY 차이는 캐싱 가능여부의 차이다
- 사용자 변수가 서브쿼리에 사용, 스토어드 루틴, 랜덤값 등 일부 요소에서는 캐싱 사용이 불가능하다

```sql
explain
select *
from employees e
where e.emp_no = (
	select @status
	from dept_emp de
	where de.dept_no='d005'
);
```

| id  | select_type          | table | partitions | type | possible_keys                         | key     | key_len | ref   | rows   | filtered | Extra       |
| --- | -------------------- | ----- | ---------- | ---- | ------------------------------------- | ------- | ------- | ----- | ------ | -------- | ----------- |
| 1   | PRIMARY              | e     |            | ALL  |                                       |         |         |       | 300030 | 100.0    | Using where |
| 2   | UNCACHEABLE SUBQUERY | de    |            | ref  | PRIMARY,ix_fromdate,ix_empno_fromdate | PRIMARY | 16      | const | 165571 | 100.0    | Using index |

<br/>

### UNCACHEABLE UNION

- 유니온 연산에 대해서 캐싱할 수 없다는 뜻

<br/>

### MATERIALIZED

- 주로 FROM 절이나 IN(subquery) 형태의 쿼리에 사용된 서브쿼리의 최적화를 위해 사용
- 서브쿼리의 내용을 임시 테이블로 구체화 시키고나서 조인하는 형태로 진행됨

```sql
explain
select *
from employees e
where e.emp_no in (
	select emp_no
	from salaries s
	where salary BETWEEN 100 AND 200
);
```

| id  | select_type  | table       | partitions | type   | possible_keys     | key       | key_len | ref                | rows | filtered | Extra                    |
| --- | ------------ | ----------- | ---------- | ------ | ----------------- | --------- | ------- | ------------------ | ---- | -------- | ------------------------ |
| 1   | SIMPLE       | <subquery2> |            | ALL    |                   |           |         |                    |      | 100.0    |                          |
| 1   | SIMPLE       | e           |            | eq_ref | PRIMARY           | PRIMARY   | 4       | <subquery2>.emp_no | 1    | 100.0    |                          |
| 2   | MATERIALIZED | s           |            | range  | PRIMARY,ix_salary | ix_salary | 4       |                    | 1    | 100.0    | Using where; Using index |

<br/>

# Table 컬럼

- MySQL의 실행계획은 단위 SELECT 쿼리 기준이 아닌 테이블 기준으로 표시됨
- 만약 별도의 테이블을 사용하지 않는 쿼리의 경우는 NULL이 표시된다
- `<>`는 임시 테이블을 의미하며 내부에 표시되는 숫자는 단위 SELECT 쿼리의 id 값을 지칭함
  - ex) `<derived2>` : 단위 SELECT 쿼리의 id 값이 2인 실헹계획으로부터 마늘어진 파생테이블

### NULL인 경우

```sql
explain select now();
```

| id  | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra          |
| --- | ----------- | ----- | ---------- | ---- | ------------- | --- | ------- | --- | ---- | -------- | -------------- |
| 1   | SIMPLE      |       |            |      |               |     |         |     |      |          | No tables used |

<br/>

### <derived2> 인 경우

```sql
explain
select *
from (
	select de.emp_no
	from dept_emp de
	group by de.emp_no
) tb, employees e
where e.emp_no = tb.emp_no;
```

| id  | select_type | table      | partitions | type   | possible_keys                         | key               | key_len | ref       | rows   | filtered | Extra       |
| --- | ----------- | ---------- | ---------- | ------ | ------------------------------------- | ----------------- | ------- | --------- | ------ | -------- | ----------- |
| 1   | PRIMARY     | <derived2> |            | ALL    |                                       |                   |         |           | 331143 | 100.0    |             |
| 1   | PRIMARY     | e          |            | eq_ref | PRIMARY                               | PRIMARY           | 4       | tb.emp_no | 1      | 100.0    |             |
| 2   | DERIVED     | de         |            | index  | PRIMARY,ix_fromdate,ix_empno_fromdate | ix_empno_fromdate | 7       |           | 331143 | 100.0    | Using index |

<br/>

# partitions 컬럼

- 파티션 프루닝을 할때 어떤 파티션에서 데이터를 가져올지 보여주는 컬럼
  - 파티션 프루닝 : 파티션이 여러개인 테이블에서 불필요한 파티션을 빼고 쿼리를 수행하기 위해 접근해야할것으로 판단되는 테이블만 골라내는 작업
- `type`이 ALL인 이유는 대부분 RDBMS의 파티션은 테이블처럼 개별의 공간을 가지기때문에 특정 공간에 풀스캔을 통해 레코드를 가져온다

```sql
CREATE TABLE employees_2 (
    emp_no INT NOT NULL,
    birth_date DATE NOT NULL,
    first_name VARCHAR(14) NOT NULL,
    last_name VARCHAR(16) NOT NULL,
    gender ENUM('M', 'F') NOT NULL,
    hire_date DATE NOT NULL,
    PRIMARY KEY (emp_no, hire_date)
) PARTITION BY RANGE COLUMNS(hire_date) (
    PARTITION p1986_1990 VALUES LESS THAN ('1990-01-01'),
    PARTITION p1991_1995 VALUES LESS THAN ('1996-01-01'),
    PARTITION p1996_2000 VALUES LESS THAN ('2000-01-01'),
    PARTITION p2001_2005 VALUES LESS THAN ('2006-01-01')
);

insert into employees_2 select * from employees;

explain
select *
from employees_2
where hire_date BETWEEN '1999-11-15' and '2000-01-15';
```

| id  | select_type | table       | partitions            | type | possible_keys | key | key_len | ref | rows  | filtered | Extra       |
| --- | ----------- | ----------- | --------------------- | ---- | ------------- | --- | ------- | --- | ----- | -------- | ----------- |
| 1   | SIMPLE      | employees_2 | p1996_2000,p2001_2005 | ALL  |               |     |         |     | 22317 | 11.11    | Using where |

<br/>

# type 컬럼

- type 이후의 컬럼은 MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽엇는지 나타냄
- type은 실행계획에서 반드시 체크해야하는 정보임
- 여러가지 방법 중 ALL을 제외한 나머지 방법들은 모두 인덱스를 통한 접근방법임

<br/>

### system

- 레코드가 1건만 존재하거나 아에 없는 테이블을 참조하는 형태의 접근방법
- InnoDB엔 나타나지 않고, MyISAM, MEMORY에만 사용되는 방법임

<br/>

### const

- 쿼리가 기본키나 유니크 키 컬럼을 이용하는 WHERE을 사용하고, 반드시 1건을 반환하는 쿼리의 처리 방식
- 다른 DBMS에선 이를 유니크 인덱스 스캔이라고도 부름

```sql
explain
select * from employees where emp_no = 10001;
```

| id  | select_type | table     | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
| --- | ----------- | --------- | ---------- | ----- | ------------- | ------- | ------- | ----- | ---- | -------- | ----- |
| 1   | SIMPLE      | employees |            | const | PRIMARY       | PRIMARY | 4       | const | 1    | 100.0    |       |

<br/>

#### 내부적인 처리 방법

- 쿼리를 최적화하는 단계에서 쿼리를 먼저 실행하고, 해당 결과를 통째로 상수화함
- 옵티마이저에 의해 상수화된 다음 쿼리로 전달되기 때문에 접근 방법이 const로 보여짐

```sql
explain
select count(*)
from employees e1
where first_name=(select first_name from employees e2 where emp_no=10001);

-- where first_name='dongwoo'
```

| id  | select_type | table | partitions | type  | possible_keys                      | key          | key_len | ref   | rows | filtered | Extra       |
| --- | ----------- | ----- | ---------- | ----- | ---------------------------------- | ------------ | ------- | ----- | ---- | -------- | ----------- |
| 1   | PRIMARY     | e1    |            | ref   | ix_firstname,ix_lastname_firstname | ix_firstname | 58      | const | 252  | 100.0    | Using index |
| 2   | SUBQUERY    | e2    |            | const | PRIMARY                            | PRIMARY      | 4       | const | 1    | 100.0    |             |

<br/>

### eq_ref

- 여러 테이블이 조인되는 쿼리의 실행 계획에서 표시
- 조인에서 두번쨰 이후에 읽는 테이블에서 반드시 1건의 레코드만 존재한다는 보장이 있어야 사용가능한 방법

```sql
explain
select * from dept_emp de , employees e
where e.emp_no = de.emp_no and de.dept_no = 'd005';
```

| id  | select_type | table | partitions | type   | possible_keys             | key     | key_len | ref                 | rows   | filtered | Extra |
| --- | ----------- | ----- | ---------- | ------ | ------------------------- | ------- | ------- | ------------------- | ------ | -------- | ----- |
| 1   | SIMPLE      | de    |            | ref    | PRIMARY,ix_empno_fromdate | PRIMARY | 16      | const               | 165571 | 100.0    |       |
| 1   | SIMPLE      | e     |            | eq_ref | PRIMARY                   | PRIMARY | 4       | realmysql.de.emp_no | 1      | 100.0    |       |

<br/>

### ref

- 인덱스의 종류와 관계없이 동등(Equal) 조건으로 검색할때 사용되는 방법
- 동등한 조건으로만 검색되므로 매우 빠른 조회방법

```sql
explain
select * from dept_emp where dept_no = 'd005';
```

| id  | select_type | table    | partitions | type | possible_keys | key     | key_len | ref   | rows   | filtered | Extra |
| --- | ----------- | -------- | ---------- | ---- | ------------- | ------- | ------- | ----- | ------ | -------- | ----- |
| 1   | SIMPLE      | dept_emp |            | ref  | PRIMARY       | PRIMARY | 16      | const | 165571 | 100.0    |       |

<br/>

### fulltext

- 일반적으로 전문검색 문법을 사용하면 무조건 전문검색 인덱스를 사용함
- 전문 검색 인덱스는 통계정보가 관리되지 않고, 전혀 다른 SQL 문법(MATCH ... AGAINST ...)을 사용해야함
- 하지만 대부분의 경우는 일반 인덱스를 통한 레인지 스캔이 더 빠른경우가 많았음

<br/>

### ref_or_null

- ref 방식 또는 NULL을 비교 접근 방법을 의미함
- 많이 사용되지는 않지만 사용한다고 했을때 나쁘지 않은 정도다

```sql
explain
select * from titles t
where to_date = '1985-03-01' or to_date is null;
```

| id  | select_type | table | partitions | type        | possible_keys | key       | key_len | ref   | rows | filtered | Extra                    |
| --- | ----------- | ----- | ---------- | ----------- | ------------- | --------- | ------- | ----- | ---- | -------- | ------------------------ |
| 1   | SIMPLE      | t     |            | ref_or_null | ix_todate     | ix_todate | 4       | const | 2    | 100.0    | Using where; Using index |

<br/>

### unique_subquery

- WHERE 조건절에서 사용될 수 있는 IN(subquery) 형태의 쿼리를 위한 접근방법
- 서브쿼리에서 중복되지 않는 유니크한 값만 반환할때 이 접근 방법을 사용함
- 8 버전 이후부터는 세미 조인 최적화에 의해서 다른 계획이 산출됨

```sql
explain
select * from departments d
where d.dept_no in (
	select dept_no de
	from dept_emp de
	where emp_no=10001
);
```

| id  | select_type | table | partitions | type   | possible_keys             | key               | key_len | ref                  | rows | filtered | Extra       |
| --- | ----------- | ----- | ---------- | ------ | ------------------------- | ----------------- | ------- | -------------------- | ---- | -------- | ----------- |
| 1   | SIMPLE      | de    |            | ref    | PRIMARY,ix_empno_fromdate | ix_empno_fromdate | 4       | const                | 1    | 100.0    | Using index |
| 1   | SIMPLE      | d     |            | eq_ref | PRIMARY                   | PRIMARY           | 16      | realmysql.de.dept_no | 1    | 100.0    |             |

<br/>

### index_subquery

- 서브쿼리 결과의 중복된 값을 인덱스응 이용해서 제거할 수 있을때의 방법
- unique_subquery랑 다르게 중복된 값이 있지만 인덱스를 활용해서 제거할수 있을때 나오니 주의해야함

<br/>

### range

- 인덱스 레인지 스캔을 통한 접근을 사용하는 방법
- 주로 <, >, IS NULL, BETWEEN, IN, LIKE 등의 연산자를 이용해서 인덱스 검색시 사용됨
- 모든 쿼리가 이 방법만 사용해도 최적의 성능이 보장된다고 생각하면됨

```sql
explain
select *
from employees e
where emp_no BETWEEN 10001 AND 10004;
```

| id  | select_type | table | partitions | type  | possible_keys | key     | key_len | ref | rows | filtered | Extra       |
| --- | ----------- | ----- | ---------- | ----- | ------------- | ------- | ------- | --- | ---- | -------- | ----------- |
| 1   | SIMPLE      | e     |            | range | PRIMARY       | PRIMARY | 4       |     | 4    | 100.0    | Using where |

<br/>

### index_merge

- 2개 이상의 인덱스를 사용해 각각의 검색 결과를 만들고, 그 결과를 병합해서 처리하는 방식
- 이름만큼 효율적으로 동작하진 않음
  - 여러개의 인덱스를 읽어야 해서 레인지 접근 방법보다 효율성이 떨어짐
  - 전문 검색 인덱스의 경우 해당 방법 사용이 불가능함
  - 항상 2개 이상의 집합이 되기 때문에, 그 두 집합의 집합 또는 중복제거 같은 부가적인 작업이 필요함

```sql
-- BETWEEN 조건은 테이블의 기본키를 통한 레인지 접근
-- OR의 first_name은 ix_firstname 인덱스를 통해 접근
-- 이후의 각 결과를 병합하고 중복을 제거하는 방식
explain
select * from employees e
where emp_no BETWEEN 10001 AND 11000 or first_name='smith';
```

| id  | select_type | table | partitions | type        | possible_keys        | key                  | key_len | ref | rows | filtered | Extra                                          |
| --- | ----------- | ----- | ---------- | ----------- | -------------------- | -------------------- | ------- | --- | ---- | -------- | ---------------------------------------------- |
| 1   | SIMPLE      | e     |            | index_merge | PRIMARY,ix_firstname | PRIMARY,ix_firstname | 4,58    |     | 1001 | 100.0    | Using union(PRIMARY,ix_firstname); Using where |

<br/>

### index

- 이름만 보면 되게 좋아보이지만 해당 방법은 인덱스 풀 스캔을 의미함
- 아래 상황에서 주로 사용됨
  - range, const, ref 사용 불가
  - 인덱스에 포함된 컬럼만으로 처리가 가능할때
  - 인덱스를 이용해 정렬이나 그룹핑이 가능할때

```sql
explain
select dept_name from departments d
order by dept_name desc limit 10;
```

| id  | select_type | table | partitions | type  | possible_keys | key         | key_len | ref | rows | filtered | Extra                            |
| --- | ----------- | ----- | ---------- | ----- | ------------- | ----------- | ------- | --- | ---- | -------- | -------------------------------- |
| 1   | SIMPLE      | d     |            | index |               | ux_deptname | 162     |     | 9    | 100.0    | Backward index scan; Using index |

<br/>

### ALL

- 풀 테이블 스캔을 의미함
- 어떤 방식으로도 인덱스를 통해서 처리가 불가능한 경우 선택하는 매우 비효율적인 방법
- 다행히 InnoDB에선 read ahead 처럼 풀스캔시 한번에 많은 페이지를 읽는 최적화 방법을 제공해줌

<br/>

# possible_keys 컬럼

- 최적의 실행계획을 만들기 위해서 후보로 선정했던 접근 방법에서사용되는 인덱스의 목록
- 말 그대로 사용될뻔한 인덱스 목록을 보여주므로 특별한 경우를 제외하곤 그냥 무시하면됨

<br/>

# key 컬럼

- 실행계획 분석에서 최종 선택된 인덱스를 뜻함
- 쿼리튜닝을 할때는 key 컬럼에 의도한 인덱스가 존재하는지 확인하는게 중요함

<br/>

# key_len 컬럼

- 다중 컬럼으로 구성된 인덱스에서 몇 개의 컬럼까지 사용했는지를 나타냄

### len 계산 방법

- 아래 예제는 ix_dept_no 인덱스를 사용하는 경우임
- dept_no는 char(4) 자료형인 컬럼이다
- key가 16인 이유는 `utf8mb4에서 1자당 4바이트`를 차지하므로 `char(4) \* 4`로 16으로 나오는것이다

```sql
explain
select * from dept_emp where dept_no='d0005';
```

| id  | select_type | table    | partitions | type | possible_keys | key     | key_len | ref   | rows  | filtered | Extra       |
| --- | ----------- | -------- | ---------- | ---- | ------------- | ------- | ------- | ----- | ----- | -------- | ----------- |
| 1   | SIMPLE      | dept_emp |            | ref  | PRIMARY       | PRIMARY | 16      | const | 41392 | 100.0    | Using where |

<br/>

### 다중 인덱스를 사용하는 경우

- 여러개의 인덱스를 사용하는 경우 해당 인덱스의 길이 만큼 합산된다
- 아래 쿼리는 인덱스를 2개 사용해서 인덱스의 길이 2개가 합산된다
  - INT 타입은 4 바이트를 사용함
- 추가로 NOT NULL 컬럼의 경우 현재 값이 NULL 인지 판단하기 위해서 1 바이트를 추가로 사용함
  - ex) DATE 컬럼은 3 바이트를 차지하는데 NOT NULL인 경우 3 + 1로 총 4 바이트를 사용함

```sql
explain
select * from dept_emp where dept_no='d005' and emp_no = 10001;
```

| id  | select_type | table    | partitions | type  | possible_keys             | key     | key_len | ref         | rows | filtered | Extra |
| --- | ----------- | -------- | ---------- | ----- | ------------------------- | ------- | ------- | ----------- | ---- | -------- | ----- |
| 1   | SIMPLE      | dept_emp |            | const | PRIMARY,ix_empno_fromdate | PRIMARY | 20      | const,const | 1    | 100.0    |       |

<br/>

# ref 컬럼

- 참조(Equal 비교 조건)으로 어떤 값이 제공됬는지 알려줌
- const, func 등 일부 조건을 제외하면 컬럼명이 표시됨

### const

상수를 참조할떄 표시됨

```sql
explain
select *
from employees e, dept_emp de
where e.emp_no = de.emp_no;
```

| id  | select_type | table    | partitions | type  | possible_keys             | key     | key_len | ref         | rows | filtered | Extra |
| --- | ----------- | -------- | ---------- | ----- | ------------------------- | ------- | ------- | ----------- | ---- | -------- | ----- |
| 1   | SIMPLE      | dept_emp |            | const | PRIMARY,ix_empno_fromdate | PRIMARY | 20      | const,const | 1    | 100.0    |       |

<br/>

### func

- 함수의 줄임말로 참조용으로 사용되는 값을 그대로 사용한것이 아닌, 콜레이션 변환/값 자체 연산을 거쳐서 참조됬다는것을 의미함
- 가능하면 이런 변환을 하지 않아도 되도록 조인 컬럼의 타입은 일치시키는 편이 좋음

```sql
	explain
	select *
	from employees e, dept_emp de
	where e.emp_no = (de.emp_no - 1);
```

| id  | select_type | table | partitions | type   | possible_keys | key     | key_len | ref  | rows   | filtered | Extra       |
| --- | ----------- | ----- | ---------- | ------ | ------------- | ------- | ------- | ---- | ------ | -------- | ----------- |
| 1   | SIMPLE      | de    |            | ALL    |               |         |         |      | 331143 | 100.0    |             |
| 1   | SIMPLE      | e     |            | eq_ref | PRIMARY       | PRIMARY | 4       | func | 1      | 100.0    | Using where |

<br/>

# rows 컬럼

- 실행 계획의 효율성 판단을 위해서 예측했던 레코드 수를 보여줌
- 각 스토리지 엔진별로 갖고있는 통계 정보를 통해 만들어낸 값이라 정확하지는 않음

### 레코드가 많을때

- 33만건을 모두 풀스캔으로 처리했다
- 이는 인덱스만으로는 처리가 불가능해서 풀스캔을 통해 조건부를 처리해야된다고 판단했다
- 이는 예측 수치일 뿐이며 정확한 값이 아니다. 정확도를 위해서는 히스토그램을 사용하자

```sql
explain
select *
from dept_emp where from_date >= '1985-01-01';
```

| id  | select_type | table    | partitions | type | possible_keys | key | key_len | ref | rows   | filtered | Extra       |
| --- | ----------- | -------- | ---------- | ---- | ------------- | --- | ------- | --- | ------ | -------- | ----------- |
| 1   | SIMPLE      | dept_emp |            | ALL  | ix_fromdate   |     |         |     | 331143 | 50.0     | Using where |

<br/>

### 레코드가 적을때

- 범위를 좁혀서 적은 개수의 레코드만 스캔해도 된다고 판단했다
- 총 292개의 레코드를 읽었다

```sql
explain
select *
from dept_emp where from_date >= '2002-07-01';
```

| id  | select_type | table    | partitions | type  | possible_keys | key         | key_len | ref | rows | filtered | Extra                 |
| --- | ----------- | -------- | ---------- | ----- | ------------- | ----------- | ------- | --- | ---- | -------- | --------------------- |
| 1   | SIMPLE      | dept_emp |            | range | ix_fromdate   | ix_fromdate | 3       |     | 292  | 100.0    | Using index condition |
