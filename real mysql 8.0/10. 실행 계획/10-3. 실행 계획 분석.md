# 실행 계획 분석

- 표의 각 라인은 쿼레엇 사용한 테이블의 개수만큼 출력됨
- 위에 있을수록 쿼리의 바깥 부분이거나 먼저 접근한 테이블이다
- 아래에 있을수록 쿼리의 안쪽 부분이나 나중에 접근한 테이블에 해당된다

<br/>

# ID 컬럼

- id 컬럼은 단위 SELECT 쿼리별로 부여되는 식별자 값이다
- SELECT가 한개이고, 여러개의 테이블이 조인되면 id값이 증가하지 않고 같은값이 부여된다
- N개의 단위 SELECT 쿼리로 구성하는 경우 id값이 서로 다른 값을 가진다
- id 컬럼은 테이블의 접근순서를 의미하진 않는다. 순서는 EXPLAIN ANALYZE로 확인하자

<br/>

# select_type 컬럼

각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시하는 컬럼

<br/>

### SIMPLE

- UNION, 서브쿼리를 사용하지 않은 단순한 쿼리다
- 일반적으로 제일 바깥의 SELECT 쿼리에서 표시된다

<br/>

### PRIMARY

- UNION, 서브쿼리를 가지는 SELECT 쿼리의 실행계획에서 제일 바깥쪽에 있는 단위 쿼리에 표시된다
- PRIMARY 단위의 쿼리는 하나만 존재하고, 제일 바깥쪽에 있는 SELECT 단위 쿼리에 표시된다

<br/>

### UNION

- UNION으로 결합하는 단위 SELECT 쿼리 카운데 첫 번째를 제외한 두번째 이후 단위 SELECT 쿼리에 표시됨
- 첫번쨰 단위 SELECT에는 DERIVED로 표시되는데, 이는 UNION되는 결과들을 모아서 저장하는 임시테이블을 뜻한다

#### 실행계획

```sql
explain
select * from (
	(
		select emp_no from employees e1 LIMIT 10
	) UNION ALL
	(
		select emp_no from employees e2 LIMIT 10
	) UNION ALL
	(
		select emp_no from employees e3 LIMIT 10
	)
) tb;

```

| id  | select_type | table      | partitions | type  | possible_keys | key         | key_len | ref | rows   | filtered | Extra       |
| --- | ----------- | ---------- | ---------- | ----- | ------------- | ----------- | ------- | --- | ------ | -------- | ----------- |
| 1   | PRIMARY     | <derived2> |            | ALL   |               |             |         |     | 30     | 100.0    |             |
| 2   | DERIVED     | e1         |            | index |               | ix_hiredate | 3       |     | 300030 | 100.0    | Using index |
| 3   | UNION       | e2         |            | index |               | ix_hiredate | 3       |     | 300030 | 100.0    | Using index |
| 4   | UNION       | e3         |            | index |               | ix_hiredate | 3       |     | 300030 | 100.0    | Using index |

- e1 테이블은 조인 결과를 모아서 처리하는 임시테이블로 DERIVED 타입으로 표시된다
- 그 외 나머지 테이블은 UNION 이라고 표시됬다

<br/>

### DEPENDENT UNION

- UNION이랑 마찬가지로 UNION, UNION ALL로 집합을 결합하는 쿼리에서 표시됨
- DEPENDENT는 결합된 단위 쿼리가 외부 쿼리에 의해서 영향을 받는 것을 의미함
- 즉 내부 쿼리가 외부의 값을 참조해서 처리될 때 DEPENDENT 타입으로 표시된다

#### 실행계획

```sql
explain
SELECT *
FROM employees e1 WHERE e1.emp_no IN (
	SELECT e2.emp_no FROM employees e2 WHERE e2.first_name = 'Matt'
	UNION
	SELECT e3.emp_no FROM employees e3 WHERE e3.last_name = 'Matt'
);
```

| id  | select_type        | table      | partitions | type   | possible_keys                              | key     | key_len | ref  | rows   | filtered | Extra           |
| --- | ------------------ | ---------- | ---------- | ------ | ------------------------------------------ | ------- | ------- | ---- | ------ | -------- | --------------- |
| 1   | PRIMARY            | e1         |            | ALL    |                                            |         |         |      | 300030 | 100.0    | Using where     |
| 2   | DEPENDENT SUBQUERY | e2         |            | eq_ref | PRIMARY,ix_firstname,ix_lastname_firstname | PRIMARY | 4       | func | 1      | 5.0      | Using where     |
| 3   | DEPENDENT UNION    | e3         |            | eq_ref | PRIMARY,ix_lastname_firstname              | PRIMARY | 4       | func | 1      | 5.0      | Using where     |
| 4   | UNION RESULT       | <union2,3> |            | ALL    |                                            |         |         |      |        |          | Using temporary |

- e2, e3을 UNION한 결과가 UNION RESULT 타입으로 표시된다
- 내부적으로 e1.emp_no = e2.emp_no, e1.emp_no = e3.emp_no 조건이 추가됨
- 외부에 정의된 e1 테이블의 영향을 받았기 때문에 DEPENDENT UNION 타입으로 표시됨
