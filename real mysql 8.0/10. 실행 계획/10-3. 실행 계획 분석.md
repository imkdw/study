# 실행 계획 분석

- 표의 각 라인은 쿼레엇 사용한 테이블의 개수만큼 출력됨
- 위에 있을수록 쿼리의 바깥 부분이거나 먼저 접근한 테이블이다
- 아래에 있을수록 쿼리의 안쪽 부분이나 나중에 접근한 테이블에 해당된다

<br/>

# ID 컬럼

- id 컬럼은 단위 SELECT 쿼리별로 부여되는 식별자 값이다
- SELECT가 한개이고, 여러개의 테이블이 조인되면 id값이 증가하지 않고 같은값이 부여된다
- N개의 단위 SELECT 쿼리로 구성하는 경우 id값이 서로 다른 값을 가진다
- id 컬럼은 테이블의 접근순서를 의미하진 않는다. 순서는 EXPLAIN ANALYZE로 확인하자

<br/>

# select_type 컬럼

각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시하는 컬럼

<br/>

### SIMPLE

- UNION, 서브쿼리를 사용하지 않은 단순한 쿼리다
- 일반적으로 제일 바깥의 SELECT 쿼리에서 표시된다

<br/>

### PRIMARY

- UNION, 서브쿼리를 가지는 SELECT 쿼리의 실행계획에서 제일 바깥쪽에 있는 단위 쿼리에 표시된다
- PRIMARY 단위의 쿼리는 하나만 존재하고, 제일 바깥쪽에 있는 SELECT 단위 쿼리에 표시된다

<br/>

### UNION

- UNION으로 결합하는 단위 SELECT 쿼리 카운데 첫 번째를 제외한 두번째 이후 단위 SELECT 쿼리에 표시됨
- 첫번쨰 단위 SELECT에는 DERIVED로 표시되는데, 이는 UNION되는 결과들을 모아서 저장하는 임시테이블을 뜻한다

#### 실행계획

```sql
explain
select * from (
	(
		select emp_no from employees e1 LIMIT 10
	) UNION ALL
	(
		select emp_no from employees e2 LIMIT 10
	) UNION ALL
	(
		select emp_no from employees e3 LIMIT 10
	)
) tb;

```

| id  | select_type | table      | partitions | type  | possible_keys | key         | key_len | ref | rows   | filtered | Extra       |
| --- | ----------- | ---------- | ---------- | ----- | ------------- | ----------- | ------- | --- | ------ | -------- | ----------- |
| 1   | PRIMARY     | <derived2> |            | ALL   |               |             |         |     | 30     | 100.0    |             |
| 2   | DERIVED     | e1         |            | index |               | ix_hiredate | 3       |     | 300030 | 100.0    | Using index |
| 3   | UNION       | e2         |            | index |               | ix_hiredate | 3       |     | 300030 | 100.0    | Using index |
| 4   | UNION       | e3         |            | index |               | ix_hiredate | 3       |     | 300030 | 100.0    | Using index |

- e1 테이블은 조인 결과를 모아서 처리하는 임시테이블로 DERIVED 타입으로 표시된다
- 그 외 나머지 테이블은 UNION 이라고 표시됬다

<br/>

### DEPENDENT UNION

- UNION이랑 마찬가지로 UNION, UNION ALL로 집합을 결합하는 쿼리에서 표시됨
- DEPENDENT는 결합된 단위 쿼리가 외부 쿼리에 의해서 영향을 받는 것을 의미함
- 즉 내부 쿼리가 외부의 값을 참조해서 처리될 때 DEPENDENT 타입으로 표시된다

#### 실행계획

```sql
explain
SELECT *
FROM employees e1 WHERE e1.emp_no IN (
	SELECT e2.emp_no FROM employees e2 WHERE e2.first_name = 'Matt'
	UNION
	SELECT e3.emp_no FROM employees e3 WHERE e3.last_name = 'Matt'
);
```

| id  | select_type        | table      | partitions | type   | possible_keys                              | key     | key_len | ref  | rows   | filtered | Extra           |
| --- | ------------------ | ---------- | ---------- | ------ | ------------------------------------------ | ------- | ------- | ---- | ------ | -------- | --------------- |
| 1   | PRIMARY            | e1         |            | ALL    |                                            |         |         |      | 300030 | 100.0    | Using where     |
| 2   | DEPENDENT SUBQUERY | e2         |            | eq_ref | PRIMARY,ix_firstname,ix_lastname_firstname | PRIMARY | 4       | func | 1      | 5.0      | Using where     |
| 3   | DEPENDENT UNION    | e3         |            | eq_ref | PRIMARY,ix_lastname_firstname              | PRIMARY | 4       | func | 1      | 5.0      | Using where     |
| 4   | UNION RESULT       | <union2,3> |            | ALL    |                                            |         |         |      |        |          | Using temporary |

- e2, e3을 UNION한 결과가 UNION RESULT 타입으로 표시된다
- 내부적으로 e1.emp_no = e2.emp_no, e1.emp_no = e3.emp_no 조건이 추가됨
- 외부에 정의된 e1 테이블의 영향을 받았기 때문에 DEPENDENT UNION 타입으로 표시됨

<br/>

### UNION RESULT

- UNION 처리에 대한 결과를 담아두는 테이블
- UNION (UNION DISTINCT)는 여전히 임시 테이블에 결과를 버퍼함
- `<union1, 2>`에서 1, 2는 값이 1인 단위 쿼리의 조회 결과와 id가 2인 단위 쿼리의 조회 결과를 조합했다는걸 의미함

```sql
explain
select emp_no from salaries where salary > 100000
union DISTINCT
select emp_no from dept_emp where from_Date > '2001-01-01';
```

| id  | select_type  | table      | partitions | type  | possible_keys                 | key         | key_len | ref | rows   | filtered | Extra                    |
| --- | ------------ | ---------- | ---------- | ----- | ----------------------------- | ----------- | ------- | --- | ------ | -------- | ------------------------ |
| 1   | PRIMARY      | salaries   |            | range | ix_salary                     | ix_salary   | 4       |     | 188518 | 100.0    | Using where; Using index |
| 2   | UNION        | dept_emp   |            | range | ix_fromdate,ix_empno_fromdate | ix_fromdate | 3       |     | 5325   | 100.0    | Using where; Using index |
| 3   | UNION RESULT | <union1,2> |            | ALL   |                               |             |         |     |        |          | Using temporary          |

<br/>

### SUBQUERY

- FROM에서 사용된 서브쿼리는 DERIVED로 표시되고, 그 외의 서브쿼리는 모두 SUBQUERY 타입으로 표시됨
- 서브쿼리는 사용되는 위치에 따라서 각각 다른 이름을 지님
  - 중첩쿼리(Nested Query) : SELECT 되는 컬럼에 사용되는 서브쿼리
  - 서브쿼리(Subquery) : WHERE에 사용하는 쿼리는 일반적으로 그냥 서브쿼리라고 부름
  - 파생테이블(Derived Table) : FROM 절에 사용된 서브쿼리

```sql
EXPLAIN
SELECT e.first_name,
  (
    SELECT (COUNT(*))
    FROM dept_emp de, dept_manager dm
    WHERE dm.dept_no = de.dept_no
  ) AS cnt
FROM employees e
WHERE e.emp_no = 10001;
```

| id  | select_type | table | partitions | type  | possible_keys | key     | key_len | ref                  | rows  | filtered | Extra       |
| --- | ----------- | ----- | ---------- | ----- | ------------- | ------- | ------- | -------------------- | ----- | -------- | ----------- |
| 1   | PRIMARY     | e     |            | const | PRIMARY       | PRIMARY | 4       | const                | 1     | 100.0    |             |
| 2   | SUBQUERY    | dm    |            | index | PRIMARY       | PRIMARY | 20      |                      | 24    | 100.0    | Using index |
| 2   | SUBQUERY    | de    |            | ref   | PRIMARY       | PRIMARY | 16      | realmysql.dm.dept_no | 41392 | 100.0    | Using index |

<br/>

### DEPENDENT SUBQUERY

- 서브쿼리가 바깥쪽 SELECT 쿼리에서 정의된 컬럼을 사용하는 경우 DEPENDENT SUBQUERY 타입으로 표시됨
- 아래 쿼리에서는 SELECT의 서브쿼리가 FROM 절에 사용된 employees를 참조하고있음
- DEPENDENT SUBQUERY는 외부쿼리가 먼저 실행되고나서 내부 쿼리가 실행되야해서 일반 서브쿼리보다 느릴때가 많음

```sql
EXPLAIN
SELECT e.first_name,
  (
    SELECT (COUNT(*))
    FROM dept_emp de, dept_manager dm
    WHERE dm.dept_no = de.dept_no AND de.emp_no = e.emp_no
  ) AS cnt
FROM employees e
WHERE e.first_name = 'Matt';
```

| id  | select_type        | table | partitions | type | possible_keys                      | key               | key_len | ref                  | rows | filtered | Extra       |
| --- | ------------------ | ----- | ---------- | ---- | ---------------------------------- | ----------------- | ------- | -------------------- | ---- | -------- | ----------- |
| 1   | PRIMARY            | e     |            | ref  | ix_firstname,ix_lastname_firstname | ix_firstname      | 58      | const                | 233  | 100.0    | Using index |
| 2   | DEPENDENT SUBQUERY | de    |            | ref  | PRIMARY,ix_empno_fromdate          | ix_empno_fromdate | 4       | realmysql.e.emp_no   | 1    | 100.0    | Using index |
| 2   | DEPENDENT SUBQUERY | dm    |            | ref  | PRIMARY                            | PRIMARY           | 16      | realmysql.de.dept_no | 2    | 100.0    | Using index |

<br/>

### DERIVED

- SELECT 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블을 생성하는것
- DERIVED인 경우 생성되는 임시 테이블을 파생테이블이라고 부름
- 가능하면 DERIVED 타입으로 표시되도록 최적화를 하고, 더 좋은건 가능하면 서브쿼리는 조인으로 바꾸는것임

```sql
explain
select *
from (select de.emp_no from dept_emp de group by de.emp_no) tb, employees e
where e.emp_no = tb.emp_no;
```

| id  | select_type | table      | partitions | type   | possible_keys                         | key               | key_len | ref       | rows   | filtered | Extra       |
| --- | ----------- | ---------- | ---------- | ------ | ------------------------------------- | ----------------- | ------- | --------- | ------ | -------- | ----------- |
| 1   | PRIMARY     | <derived2> |            | ALL    |                                       |                   |         |           | 331143 | 100.0    |             |
| 1   | PRIMARY     | e          |            | eq_ref | PRIMARY                               | PRIMARY           | 4       | tb.emp_no | 1      | 100.0    |             |
| 2   | DERIVED     | de         |            | index  | PRIMARY,ix_fromdate,ix_empno_fromdate | ix_empno_fromdate | 7       |           | 331143 | 100.0    | Using index |

<br/>

### DEPENDENT DERIVED

- 8 버전 부터 레터럴 조인이 추가되면서 FROM 절의 서브쿼리에서도 외부 컬럼 참조가 가능해짐
- DEPENDENT DERIVED는 해당 테이블이 레터럴 조인으로 사용됬다는걸 표시함

```sql
explain
select *
from employees e
left join lateral
	(
		select *
		from salaries s
		where s.emp_no = e.emp_no
		order by s.from_date desc limit 2
	) as s2
on s2.emp_no = e.emp_no;
```

| id  | select_type       | table      | partitions | type | possible_keys | key         | key_len | ref                | rows   | filtered | Extra                      |
| --- | ----------------- | ---------- | ---------- | ---- | ------------- | ----------- | ------- | ------------------ | ------ | -------- | -------------------------- |
| 1   | PRIMARY           | e          |            | ALL  |               |             |         |                    | 300030 | 100.0    | Rematerialize (<derived2>) |
| 1   | PRIMARY           | <derived2> |            | ref  | <auto_key0>   | <auto_key0> | 4       | realmysql.e.emp_no | 2      | 100.0    |                            |
| 2   | DEPENDENT DERIVED | s          |            | ref  | PRIMARY       | PRIMARY     | 4       | realmysql.e.emp_no | 9      | 100.0    | Using filesort             |

<br/>

### UNCACHEABLE SUBQUERY

- 동일한 서브쿼리가 재사용될 경우 다시 쿼리를 실행하는게 아닌 캐싱된 결과를 사용한다
- 이 때 쿼리 캐시나 파생 테이블과는 전혀 무관하다
  - SUBQUERY는 바깥쪽의 영향을 받지 않아서 처음 한번만 실행해서 그 결과를 캐싱하고 필요할 때 사용한다
  - DEPENDENT SUBQUERY는 의존하는 바깥쪽 쿼리의 칼럼의 값 단위로 캐싱해서 사용한다
- SUBQUERY, UNCACHEABLE SUBQUERY 차이는 캐싱 가능여부의 차이다
- 사용자 변수가 서브쿼리에 사용, 스토어드 루틴, 랜덤값 등 일부 요소에서는 캐싱 사용이 불가능하다

```sql
explain
select *
from employees e
where e.emp_no = (
	select @status
	from dept_emp de
	where de.dept_no='d005'
);
```

| id  | select_type          | table | partitions | type | possible_keys                         | key     | key_len | ref   | rows   | filtered | Extra       |
| --- | -------------------- | ----- | ---------- | ---- | ------------------------------------- | ------- | ------- | ----- | ------ | -------- | ----------- |
| 1   | PRIMARY              | e     |            | ALL  |                                       |         |         |       | 300030 | 100.0    | Using where |
| 2   | UNCACHEABLE SUBQUERY | de    |            | ref  | PRIMARY,ix_fromdate,ix_empno_fromdate | PRIMARY | 16      | const | 165571 | 100.0    | Using index |

<br/>

### UNCACHEABLE UNION

- 유니온 연산에 대해서 캐싱할 수 없다는 뜻

<br/>

### MATERIALIZED

- 주로 FROM 절이나 IN(subquery) 형태의 쿼리에 사용된 서브쿼리의 최적화를 위해 사용
- 서브쿼리의 내용을 임시 테이블로 구체화 시키고나서 조인하는 형태로 진행됨

```sql
explain
select *
from employees e
where e.emp_no in (
	select emp_no
	from salaries s
	where salary BETWEEN 100 AND 200
);
```

| id  | select_type  | table       | partitions | type   | possible_keys     | key       | key_len | ref                | rows | filtered | Extra                    |
| --- | ------------ | ----------- | ---------- | ------ | ----------------- | --------- | ------- | ------------------ | ---- | -------- | ------------------------ |
| 1   | SIMPLE       | <subquery2> |            | ALL    |                   |           |         |                    |      | 100.0    |                          |
| 1   | SIMPLE       | e           |            | eq_ref | PRIMARY           | PRIMARY   | 4       | <subquery2>.emp_no | 1    | 100.0    |                          |
| 2   | MATERIALIZED | s           |            | range  | PRIMARY,ix_salary | ix_salary | 4       |                    | 1    | 100.0    | Using where; Using index |

<br/>

# Table 컬럼

- MySQL의 실행계획은 단위 SELECT 쿼리 기준이 아닌 테이블 기준으로 표시됨
- 만약 별도의 테이블을 사용하지 않는 쿼리의 경우는 NULL이 표시된다
- `<>`는 임시 테이블을 의미하며 내부에 표시되는 숫자는 단위 SELECT 쿼리의 id 값을 지칭함
  - ex) `<derived2>` : 단위 SELECT 쿼리의 id 값이 2인 실헹계획으로부터 마늘어진 파생테이블

### NULL인 경우

```sql
explain select now();
```

| id  | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra          |
| --- | ----------- | ----- | ---------- | ---- | ------------- | --- | ------- | --- | ---- | -------- | -------------- |
| 1   | SIMPLE      |       |            |      |               |     |         |     |      |          | No tables used |

<br/>

### <derived2> 인 경우

```sql
explain
select *
from (
	select de.emp_no
	from dept_emp de
	group by de.emp_no
) tb, employees e
where e.emp_no = tb.emp_no;
```

| id  | select_type | table      | partitions | type   | possible_keys                         | key               | key_len | ref       | rows   | filtered | Extra       |
| --- | ----------- | ---------- | ---------- | ------ | ------------------------------------- | ----------------- | ------- | --------- | ------ | -------- | ----------- |
| 1   | PRIMARY     | <derived2> |            | ALL    |                                       |                   |         |           | 331143 | 100.0    |             |
| 1   | PRIMARY     | e          |            | eq_ref | PRIMARY                               | PRIMARY           | 4       | tb.emp_no | 1      | 100.0    |             |
| 2   | DERIVED     | de         |            | index  | PRIMARY,ix_fromdate,ix_empno_fromdate | ix_empno_fromdate | 7       |           | 331143 | 100.0    | Using index |

<br/>

# partitions 컬럼

- 파티션 프루닝을 할때 어떤 파티션에서 데이터를 가져올지 보여주는 컬럼
  - 파티션 프루닝 : 파티션이 여러개인 테이블에서 불필요한 파티션을 빼고 쿼리를 수행하기 위해 접근해야할것으로 판단되는 테이블만 골라내는 작업
- `type`이 ALL인 이유는 대부분 RDBMS의 파티션은 테이블처럼 개별의 공간을 가지기때문에 특정 공간에 풀스캔을 통해 레코드를 가져온다

```sql
CREATE TABLE employees_2 (
    emp_no INT NOT NULL,
    birth_date DATE NOT NULL,
    first_name VARCHAR(14) NOT NULL,
    last_name VARCHAR(16) NOT NULL,
    gender ENUM('M', 'F') NOT NULL,
    hire_date DATE NOT NULL,
    PRIMARY KEY (emp_no, hire_date)
) PARTITION BY RANGE COLUMNS(hire_date) (
    PARTITION p1986_1990 VALUES LESS THAN ('1990-01-01'),
    PARTITION p1991_1995 VALUES LESS THAN ('1996-01-01'),
    PARTITION p1996_2000 VALUES LESS THAN ('2000-01-01'),
    PARTITION p2001_2005 VALUES LESS THAN ('2006-01-01')
);

insert into employees_2 select * from employees;

explain
select *
from employees_2
where hire_date BETWEEN '1999-11-15' and '2000-01-15';
```

| id  | select_type | table       | partitions            | type | possible_keys | key | key_len | ref | rows  | filtered | Extra       |
| --- | ----------- | ----------- | --------------------- | ---- | ------------- | --- | ------- | --- | ----- | -------- | ----------- |
| 1   | SIMPLE      | employees_2 | p1996_2000,p2001_2005 | ALL  |               |     |         |     | 22317 | 11.11    | Using where |

<br/>
