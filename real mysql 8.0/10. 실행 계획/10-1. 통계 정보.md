# 통계 정보

- 5.7 버전까진 테이블과 인덱스에 대한 개괄적인 정보를 가지고 실행계획을 수립했음
- 8 버전 부터는 인덱스되지 않은 컬럼에 대해서도 데이터 분포도를 수집해서 저장하는 히스토그램이 도입됨

<br>

# 테이블 및 인덱스 통계 정보

- 비용 기반 최적화(Cost Based Optimization)에서 제일 중요한건 통계 정보다
- MySQL은 다른 DBMS에 비해 통계정보의 수집 정확도가 높지않고 휘발성이 강했음
- 그래서 쿼리의 실행계획 수립시 실제 테이블에 데이터를 일부 분석해서 통계정보를 보완함

<br/>

### MySQL 서버의 통계 정보

- InnoDB를 사용하는 테이블에 대한 통계 정보를 영구적으로 관리할 수 있게 개선됨
- 해당 정보는 `innodb_index_stats`, `innodb_table_stats` 테이블제 저장됨
- 영구적으로 관리할 수 있게 개선되면서 서버 재시작시에도 기존 통계정보 유지가 가능해짐
- 만약 자동 통계수집을 사용하지 않으면, 서버 점검/사용량이 적은 시간대에 더 정확한 통계정보 수집도 가능함

#### STATS_PERSISTENT

- 테이블 단위로 영구적인 통계 정보 보관여부를 결정하는 옵션
- `CREATE TABLE`, `ALTER TABLE`에 사용이 가능함
- 기본적으로 활성화가 되어있으며 비활성화시 통계정보가 메모리에 반영됨

```sql
create table test (
	id int primary key,
	c1 varchar(255)
)
ENGINE = INNODB
STATS_PERSISTENT = { DEFAULT | 0 | 1 }

alter table test STATS_PERSISTENT = { DEFAULT | 0 | 1 };
```

#### 통계 정보 확인

```sql
select * from mysql.innodb_index_stats
where DATABASE_NAME='realmysql'
and TABLE_NAME like '%employees%';
```

```json
{
  "select * from mysql.innodb_index_stats\nwhere DATABASE_NAME='realmysql'\nand TABLE_NAME like '%employees%'": [
    {
      "database_name": "realmysql",
      "table_name": "employees_comp4k",
      "index_name": "PRIMARY",
      "last_update": "2024-09-18 13:13:07",
      "stat_name": "n_diff_pfx01",
      "stat_value": 297901,
      "sample_size": 20,
      "stat_description": "emp_no"
    },
    {
      "database_name": "realmysql",
      "table_name": "employees_comp4k",
      "index_name": "PRIMARY",
      "last_update": "2024-09-18 13:13:07",
      "stat_name": "n_leaf_pages",
      "stat_value": 2577,
      "sample_size": null,
      "stat_description": "Number of leaf pages in the index"
    }
  ]
  // ...
}
```

---

```sql
select * from mysql.innodb_table_stats
where database_name='realmysql'
and table_name like "%employees%";
```

```json
{
  "select * from mysql.innodb_table_stats\nwhere database_name='realmysql'\nand table_name like \"%employees%\"": [
    {
      "database_name": "realmysql",
      "table_name": "employees_comp4k",
      "last_update": "2024-09-18 13:13:07",
      "n_rows": 297901,
      "clustered_index_size": 2599,
      "sum_of_other_index_sizes": 1352
    },
    {
      "database_name": "realmysql",
      "table_name": "employees_comp8k",
      "last_update": "2024-09-18 13:13:17",
      "n_rows": 299226,
      "clustered_index_size": 1251,
      "sum_of_other_index_sizes": 962
    }
  ]
}
```

<br/>

#### 통계정보 자동 수집 여부

- `STATS_AUTO_RECALC` 옵션으로 자동 수집 여부 제어가 가능함
- 해당 옵션은 테이블 생성시 지정이 가능함

#### `innodb_stats_transient_sample_pages`

- 기본값은 8로, 자동 통계 수집 정보가 저장될 때 N개의 페이지로 샘플링, 분석 및 활용함을 의미

#### `innodb_stats_persistent_sample_pages`

- 기본값은 20으로, ANALYZE 실행시 자동 통계 수집 정보가 저장될 때 N개의 페이지로 샘플링, 분석 및 활용함을 의미, 이는 영구적인 통계 정보 페이지에 저장됨

<br/>

# 히스토그램

- 8 버전에서 도입된 컬럼의 데이터 분포도를 참조할 수 있는 정보

### 히스토그램 정보 수집 및 삭제

- 정보는 컬럼 단위로 관리되고, 자동으로 수집되지 않고 수동으로 수집 및 관리함
- 시스템 딕셔너리 내부에 저장되고, 서버 시작시 `information_schema.column_statistics` 테이블에 로드함

```sql
-- gender, hire_date 컬럼의 히스토그램 정보 수집
analyze table employees
update histogram on gender, hire_date;

-- gender, hire_date 컬럼의 히스토그램 정보 조회
select * from information_schema.column_statistics
where schema_name='realmysql'
and table_name='employees';
```

```json
{
  "select * from information_schema.column_statistics\nwhere schema_name='realmysql'\nand table_name='employees'": [
    {
      "SCHEMA_NAME": "realmysql",
      "TABLE_NAME": "employees",
      "COLUMN_NAME": "gender",
      "HISTOGRAM": "{\"buckets\": [[1, 0.5998618770077537], [2, 1.0]], \"data-type\": \"enum\", \"auto-update\": false, \"null-values\": 0.0, \"collation-id\": 45, \"last-updated\": \"2024-09-22 07:00:59.804754\", \"sampling-rate\": 0.347187503471875, \"histogram-type\": \"singleton\", \"number-of-buckets-specified\": 100}"
    },
    {
      "SCHEMA_NAME": "realmysql",
      "TABLE_NAME": "employees",
      "COLUMN_NAME": "hire_date",
      "HISTOGRAM": "{\"buckets\": [[\"1985-02-01\", \"1985-03-01\", 0.009961597622610315, 29], [\"1985-03-02\", \"1985-03-28\", 0.01987087592997583, 27], [\"1985-03-29\", \"1985-04-25\", 0.029842937415635103, 28], [\"1985-04-26\", \"1985-05-23\", 0.03979407117519646, 28], [\"1985-05-24\", \"1985-06-20\", 0.04967195789341509, 28], [\"1985-06-21\", \"1985-07-19\", 0.05962309165297645, 29], [\"1985-07-20\", \"1985-08-16\", 0.06955329768643988, 28], [\"1985-08-17\", \"1985-09-14\", 0.07959860621344188, 29], [\"1985-09-15\", \"1985-10-13\", 0.08952881224690531, 29], [\"1985-10-14\", \"1985-11-12\", 0.09945901828036875, 30], [\"1985-11-13\", \"1985-12-12\", 0.10945200749212594, 30], [\"1985-12-13\", \"1986-01-11\", 0.1194554605669321, 30], [\"1986-01-12\", \"1986-02-10\", 0.1295007690939341, 30], [\"1986-02-11\", \"1986-03-11\", 0.13934726422300586, 29], [\"1986-03-12\", \"1986-04-11\", 0.14945535592830161, 31], [\"1986-04-12\", \"1986-05-10\", 0.1596053030857932, 29], [\"1986-05-11\", \"1986-06-11\", 0.16974478638023585, 32], [\"1986-06-12\", \"1986-07-11\", 0.1798110226333358, 30], [\"1986-07-12\", \"1986-08-09\", 0.18962612617326063, 29], [\"1986-08-10\", \"1986-09-09\", 0.19967143470026263, 31], [\"1986-09-10\", \"1986-10-07\", 0.2095493214184813, 28], [\"1986-10-08\", \"1986-11-08\", 0.21967834084987495, 32], [\"1986-11-09\", \"1986-12-09\", 0.22959808302028942, 31], [\"1986-12-10\", \"1987-01-09\", 0.23938179497106743, 31], [\"1987-01-10\", \"1987-02-11\", 0.24953174212855903, 33], [\"1987-02-12\", \"1987-03-14\", 0.25952473134031623, 31], [\"1987-03-15\", \"1987-04-17\", 0.2695805037303672, 34], [\"1987-04-18\", \"1987-05-20\", 0.27953163748992854, 33], [\"1987-05-21\", \"1987-06-21\", 0.2893990603450982, 32], [\"1987-06-22\", \"1987-07-24\", 0.29945483273514917, 33], [\"1987-07-25\", \"1987-08-27\", 0.3094582858099553, 34], [\"1987-08-28\", \"1987-09-30\", 0.3194303472956146, 34], [\"1987-10-01\", \"1987-11-02\", 0.32940240878127386, 33], [\"1987-11-03\", \"1987-12-05\", 0.3393953979930311, 33], [\"1987-12-06\", \"1988-01-07\", 0.34941977879393515, 33], [\"1988-01-08\", \"1988-02-10\", 0.35932905710130064, 34], [\"1988-02-11\", \"1988-03-13\", 0.3693011185869599, 32], [\"1988-03-14\", \"1988-04-15\", 0.3791685414421296, 33], [\"1988-04-16\", \"1988-05-19\", 0.3892347776952295, 34], [\"1988-05-20\", \"1988-06-23\", 0.3991754475917419, 35], [\"1988-06-24\", \"1988-07-28\", 0.40907426203605846, 35], [\"1988-07-29\", \"1988-09-01\", 0.418973076480375, 35], [\"1988-09-02\", \"1988-10-08\", 0.42890328251383847, 37], [\"1988-10-09\", \"1988-11-10\", 0.43874977764291023, 33], [\"1988-11-11\", \"1988-12-14\", 0.448857869348206, 34], [\"1988-12-15\", \"1989-01-20\", 0.45893456946435485, 37], [\"1989-01-21\", \"1989-02-26\", 0.46879152845647554, 37], [\"1989-02-27\", \"1989-04-04\", 0.4788786924356734, 37], [\"1989-04-05\", \"1989-05-11\", 0.48886121778438163, 37], [\"1989-05-12\", \"1989-06-17\", 0.4986867851873555, 37], [\"1989-06-18\", \"1989-07-25\", 0.508596063494721, 38], [\"1989-07-26\", \"1989-09-01\", 0.5187250829261146, 38], [\"1989-09-02\", \"1989-10-13\", 0.5287285360009208, 42], [\"1989-10-14\", \"1989-11-20\", 0.5386482781713353, 38], [\"1989-11-21\", \"1989-12-30\", 0.548756369876631, 40], [\"1989-12-31\", \"1990-02-10\", 0.5587807506775352, 42], [\"1990-02-11\", \"1990-03-24\", 0.568857450793684, 42], [\"1990-03-25\", \"1990-05-04\", 0.5788818315945881, 41], [\"1990-05-05\", \"1990-06-16\", 0.5890317787520797, 43], [\"1990-06-17\", \"1990-07-28\", 0.5990352318268859, 42], [\"1990-07-29\", \"1990-09-10\", 0.6091014680799858, 44], [\"1990-09-11\", \"1990-10-23\", 0.6191363127439388, 43], [\"1990-10-24\", \"1990-12-05\", 0.629129301955696, 43], [\"1990-12-06\", \"1991-01-18\", 0.6391118273044042, 44], [\"1991-01-19\", \"1991-03-04\", 0.6491466719683573, 45], [\"1991-03-05\", \"1991-04-17\", 0.6591291973170655, 44], [\"1991-04-18\", \"1991-06-04\", 0.6690803310766269, 48], [\"1991-06-05\", \"1991-07-26\", 0.6792198143710695, 52], [\"1991-07-27\", \"1991-09-11\", 0.6892337313089246, 47], [\"1991-09-12\", \"1991-11-01\", 0.6991953289315349, 51], [\"1991-11-02\", \"1991-12-22\", 0.7092720290476838, 51], [\"1991-12-23\", \"1992-02-13\", 0.7193591930268817, 53], [\"1992-02-14\", \"1992-04-08\", 0.7293835738277857, 55], [\"1992-04-09\", \"1992-06-03\", 0.7392928521351513, 56], [\"1992-06-04\", \"1992-07-28\", 0.7494218715665449, 55], [\"1992-07-29\", \"1992-09-19\", 0.7595299632718407, 53], [\"1992-09-20\", \"1992-11-13\", 0.7696066633879896, 55], [\"1992-11-14\", \"1993-01-08\", 0.7795159416953551, 56], [\"1993-01-09\", \"1993-03-08\", 0.7896135695376019, 59], [\"1993-03-09\", \"1993-05-05\", 0.7995856310232612, 58], [\"1993-05-06\", \"1993-07-05\", 0.809672795002459, 61], [\"1993-07-06\", \"1993-09-08\", 0.8197390312555589, 65], [\"1993-09-09\", \"1993-11-11\", 0.8298157313717078, 64], [\"1993-11-12\", \"1994-01-11\", 0.8399028953509057, 61], [\"1994-01-12\", \"1994-03-27\", 0.8498958845626629, 75], [\"1994-03-28\", \"1994-06-08\", 0.8600353678571054, 73], [\"1994-06-09\", \"1994-08-21\", 0.8701434595624012, 74], [\"1994-08-22\", \"1994-11-04\", 0.8802201596785502, 75], [\"1994-11-05\", \"1995-01-23\", 0.890307323657748, 80], [\"1995-01-24\", \"1995-04-21\", 0.9004258792260927, 88], [\"1995-04-22\", \"1995-07-25\", 0.9105758263835843, 95], [\"1995-07-26\", \"1995-10-28\", 0.9206525264997332, 95], [\"1995-10-29\", \"1996-02-03\", 0.9307815459311268, 98], [\"1996-02-04\", \"1996-05-18\", 0.9408582460472757, 105], [\"1996-05-19\", \"1996-09-08\", 0.9509663377525714, 113], [\"1996-09-09\", \"1997-01-18\", 0.9610639655948183, 133], [\"1997-01-19\", \"1997-06-25\", 0.97121391275231, 161], [\"1997-06-26\", \"1997-12-22\", 0.9813429321837036, 180], [\"1997-12-23\", \"1998-08-22\", 0.9914719516150973, 254], [\"1998-08-24\", \"2000-01-08\", 1.0, 463]], \"data-type\": \"date\", \"auto-update\": false, \"null-values\": 0.0, \"collation-id\": 8, \"last-updated\": \"2024-09-22 07:00:59.805767\", \"sampling-rate\": 0.347187503471875, \"histogram-type\": \"equi-height\", \"number-of-buckets-specified\": 100}"
    }
  ]
}
```

<br/>

### 히스토그램의 타입

> 주의 : 8.0.19 미만에서는 풀 스캔을 통해서 데이터를 샘플링 후 히스토그램을 작성함

#### 싱글톤(Singleton) 히스토그램

- 컬럼값 개별로 레코드 건수를 관리하는 히스토그램
- 주로 코드같이 유니크한 값의 개수가 상대적으로 적은 경우 사용

#### 높이 균형 (Equi-height) 히스토그램

- 컬럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램

#### `sample-rate` 옵션

- 히스토그램 정보를 수집하기 위해 스캔할 페이지의 비율
- 0.35라면 데이터 페이지의 약 35%를 스캔한것임
- 메모리 크기에 맞춰서 샘플링을 진행하는데 기본값은 20MB로 설정되어있음

#### `histogram-type` 옵션

- `singleton` 옵션은 싱글톤 히스토그램을 수집하는 것이다
- `equi-height` 옵션은 높이 균형 히스토그램을 수집하는 것이다

#### `number-of-buckets-specified` 옵션

- 히스토그램 생성할 때 설정했던 버킷의 개수를 저장
- 별도의 값을 지정하지 않으면 100개가 사용되고 최대값은 1024개다
- 보통 100개만 해도 충분하다고한다

<br/>

### 히스토그램 삭제

- 히스토그램 삭제는 다른 테이블 데이터를 참조하지 않아서 바로 삭제된다
- 이는 다른 쿼리에 영향을 주지 않지만, 쿼리의 실행계획이 달라질 수 있으니 조심해야한다

```sql
analyze table employees
drop histogram on gender, hire_date
```

<br/>

### 옵티마이저에서 히스토그램 비활성화

- 히스토그램을 삭제하지 않고 실행계획 수립 시 사용하지 못하게 할 수 있음

```sql
set {GLOBAL | SESSION } optimizer_switch='condition_fanout_filter=off';

select /*+ SET_VAR(optimizer_switch='condition_fanout_filter=off') */
from ...
```

<br/>

### 히스토그램의 용도

- 이전에는 예를 들어 레코드 1000개, 유니크 100개 -> 동등 비교 검색시 약 10개 일치로 판단함
- 실제 데이터는 항상 균등한 분포도를 가지지 않아서 정확한 예측이 불가능했음
- 히스토그램은 각 범위 별로 레코드 건수와 유니크한 값의 개수 정보를 가져서 훨씬 정확한 예측이 가능함

<br/>

### 히스토그램과 인덱스

> 인덱스 다이브 : 옵티마이저가 조건절에 일치하는 데이터를 예측하기 위해 B-Tree 샘플링해서 확인

- 인덱스된 컬럼을 검색조건으로 사용하면, 히스토그램은 사용하지 않고 인덱스 다이브를 통해 얻은 정보로 처리함
  - 실제 검색조건에 대해서 샘플링을 실행하는거라 히스토그램보다 정확한 결과 기대가 가능함
- 히스토그램은 주로 인덱스되지 않은 컬럼에 대한 데이터 분포도를 참조하는 용도로 사용됨

<br/>

# 코스트 모델(Cost Model)

- 전체 쿼리의 비용을 계산하는 데 필요한 단위 작업들의 비용을 코스트 모델 이라고 부름
- 8 버전 부터 관련된 작업들의 비율을 직접 커스텀이 가능하도록 변경되었음

<br/>

### server_cost, engine_cost 테이블

- server_cost : 인덱스를 찾고 레코드를 비교하고 임시 테이블 처리에 대한 비용관리
- engine_cost : 레코드를 가진 데이터 페이지를 가져오는데 필요한 비용 관리
- 공통적으로 가지는 컬럼
  - cost_name : 코스트 모델의 각 단위 작업
  - default_value: 각 단위 작업의 비용
  - cost_value : 관리자가 설정한 값, null이면 기본값
  - last_updated, comment : 수정 시간, 설명으로 실제 영향을 안미침
- engine_cost에만 존재하는 컬럼
  - engine_name : 비용이 적용된 스토리지 엔진
  - device_type : 디스크의 타입, 아직까진 0만 사용 가능

### 각 실행계획의 계산된 비용 확인

- 직접 계산을 해보고 싶을수도 있지만 이는 쉽지 않다
  - 계산에 필요한 모든 정보가 사용자에게 모두 노출되지 않는다

```sql
mysql> explain format=tree
    -> select *
    -> from employees e
    -> where first_name = 'Matt';

| -> Index lookup on e using ix_firstname (first_name='Matt')  (cost=`81.5` rows=233)
1 row in set (0.00 sec)
```

---

```sql
mysql> explain format=json
    -> select *
    -> from employees e
    -> where first_name = 'Matt';

{
  "query_block": {
    "select_id": 1,
    "cost_info": {
      "query_cost": "81.55"
    },
    "table": {
      "table_name": "e",
      "access_type": "ref",
      "possible_keys": [
        "ix_fir
  -- ....
```

### 최적의 값?

- 해당 값을 커스텀하기 위해서는 전문적인 지식이 없다면 건들지 않는게 좋다
- 약 20년동안 기본값으로도 잘 써왔다
