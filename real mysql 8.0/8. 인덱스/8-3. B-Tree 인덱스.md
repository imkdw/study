# B-Tree 인덱스

- 가장 일반적으로 사용하고, 가장 먼저 도입된 알고리즘
- Binary가 아닌 Balanced를 의미함
- 컬럼의 원래 값을 변형시키자 않고, 인덱스 구조체 내에서는 항상 정렬된 값을 유지함
- 전문검색 같은 특수한 요건이 아니라면, 일반적으로 적합한 알고리즘임

<br/>

# 구조 및 특성

- 기본적으로 트리 구조를 띄고 있으며 루트 노드, 리프노드 그 사이에 브랜치 노드가 존재함
- 맨 뒷단에 존재하는 리프 노드의 경우는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가짐
- 인덱스의 키 값은 항상 정렬된 값을 유지하지만, 실제 레코드는 그렇지 않음

### MyISAM 인덱스

- 테이블의 생성 옵션에 따라서 레코드가 테이블에 추가된 순번이나, 데이터 파일 위치다
- 이 떄 사용되는게 ROWID 이다

### InnoDB 인덱스

- 인덱스에 저장된 PK 값을 통해서, 해당 키 인덱스의 리프페이지에 저장된 주소값으로 레코드를 읽음
- 반드시 PK를 저장하고 있는 B-Tree를 다시한번 검사하게됨

<br/>

# B-Tree 인덱스 키 추가 및 삭제

### 인덱스 키 추가

- 새로운 인덱스가 추가되면 바로 저장될수도 있지만, 적절한 위치를 찾아서 다시 저장해야될수도 있다
- 리프노드가 꽉 차서 저장이 불가능하면 리프 노드를 분리하게 되는데, 이래서 쓰기 작업의 경우는 상대적으로 비용이 많이 드는것으로 알려짐
- 간단하게 생각하면 읽기의 비용이 1이면, 쓰기의 비용은 1.5로 생각하면 된다
- 이는 CPU, RAM에 의해 발생하는 비용이 아닌 디스크로 부터 인덱스를 읽어야해서 발생하는 비용임
- 인덱스 키 추가 작업은 체인지 버퍼를 통해 지연처리가 가능하지만, PK나 유니크 인덱스의 경우는 중복 체크가 필요해서 즉시 B-Tree에 반영되어야함

<br/>

### 인덱스 키 삭제

- 해당 키 값이 저장된 노드를 찾아서 삭제 마크만 하면 작업이 완료됨
- 삭제된 노드는 재사용하거나 그대로 방치도 가능함
- InnoDB에서는 해당 작업도 체인지 버퍼를 통해 지연처리가 가능함

<br/>

### 인덱스 키 변경

- 키 변경은 먼저 해당 키 값을 삭제하고, 다시 새로운 키 값을 추가하는 방식으로 처리됨
- 마찬가지로 지연처리가 가능함

<br/>

### 인덱스 키 검색

- 위 같은 추가에 대한 비용을 지불하면서 인덱스를 사용하는 이유는 검색 성능 때문임
- SELECT 외에 UPDATE, DELETE에서 FROM 절에 조건을 사용할때도 사용됨
- B-Tree 인덱스의 경우 100% 일치하는 `=` 연산자나, 값의 앞부분만 일치하는 경우 사용이 가능함

#### 주의사항

- 넥스트 키 락이나 레코드 잠금의 경우 수행한 인덱스를 잡근후 테이블의 레코드를 잠그는 방식으로 구성됨
- 만약 인덱스를 잘못 설계한 경우 모든 테이블의 레코드를 잠궈서 성능저하로 이어질 수 있음

<br/>

# B-Tree 인덱스 사용에 영향을 미치는 요소

인덱스를 구성하는 컬럼의 크기, 레코드/유니크 인덱스 개수 등 에 의해 성능이 영향을 받음

### 인덱스 키 값의 크기

- 인덱스도 버퍼 풀 처럼 페이지 단위로 관리 되며, B-Tree는 자식 노드가 가변적인 구조다
- B-Tree의 자식 노드의 개수는 페이지 크기와 키 값에 따라서 결정된다

#### B-Tree 리프노드 개수 구하기

- 아래 예시는 페이지의 기본값인 16KB와, 인덱스의 키가 16Byte라고 가정한다
- 자식 노드의 경우 6~12Byte까지 가질수 있으며 예제에서는 12Byte라고 가정한다
- `16*1024/(16+12) = 585`로 최종적으로 자식노드를 585개 가질 수 있다
- 만약 페이지의 크기가 32KB라면 `16*1024/(32+12) = 1024`로 자식노드를 372개 가질 수 있다
- 결론적으로 인덱스를 구성하는 키의 크기가 클수록 디스크에 접근하는 회수가 느려지고, 속도도 느려진다는 뜻이다

<br/>

### B-Tree의 깊이

- B-Tree 인덱스의 깊이는 매우 중요하지만 직접 제어할 수 있는 방법은 없다
- 깊이는 결국 값을 검색할 때 몇 번이나 랜덤하게 디스크에서 값을 읽어야 하는지와 직결된다
- 가능하면 작게 만드는것이 좋다는걸 강조하기 위함이고, 사실 대용량 DB라고 해도 보통 5를 넘지 않는다

<br/>

### 선택도(기수성) - Selectivity(Cardinality)

- 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미함
- 값이 100개인데 유니크한 값이 10개라면 기수성은 10임
- 중복된 값이 많아질수록 기구성이 낮아지고, 동시에 선택도 또한 떨어짐
- 선택도가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리됨
- 유니크한 값의 개수는 인덱스나 쿼리 효율성의 큰 영향을 미침

#### 예시 1

> 총 컬럼은 10000건  
> CASE A: country 컬럼의 유니크한 값이 10개  
> CASE B: country 컬럼의 유니크한 값이 1000개

```sql
select * from test where country='KOREA' and city='SEOUL';
```

- A: 10000건 중 10건이 유니크 하므로 평균 1000건이 검색됨
  - 불필요한 데이터 999건이 쓸모없이 검색
- B: 10000건 중 1000건이 유니크 하므로 평균 1000건이 검색됨
  - 불필요한 데이터 9건이 쓸모없이 검색
- A의 경우 country 컬럼에 생성된 인덱스는 비효율적이다
- 필요한 만큼의 레코드만 읽으면 좋겠지만, 현실적으로 모든 조건을 만족하는 인덱스 생성은 불가능함

<br>

#### 예시 2

> 총 10000건의 레코드  
> 국가와 도시는 중복되서 저장되지 않음

```sql
select * from test where country='KOREA' and city='SEOUL';
```

- country 유니크 컬럼이 10개
  - 총 1000건이 검색됨
  - 이후에 SEOUL은 1개 이므로 불필요하게 999개 읽어짐
- country 유니크 컬럼이 1000개
  - 총 10건이 검색됨
  - 이후에 SEOUL은 1개 이므로 불필요하게 9개 읽어짐

<br/>

### 읽어야 하는 레코드의 건수

- 인덱스를 통한 검색은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는것보다 높은 비용이 소모됨
  - 옵티마이저는 그냥 가져오는것 보다 인덱스를 타서 가져오는걸 약 4~5배 비싸다고 예측함
- 예를 들면 100만건 중 50만건을 읽어야한다면 50만건을 버릴지, 인덱스를 통해 50만건만 읽을지 판단해야함
- 인덱스를 통해 읽어야 할 데이터의 개수가 전체 테이블 레코드의 `20~25%`를 넘어가면 인덱스를 쓰지 말고 모두 직접 읽어서 필요한 레코드만 필터링하는게 더 효율적임
- 이렇게 비효율적인 작업은 옵티마이저에 의해서 인덱스를 타지 않고 쿼리가 실행됨
  - 즉 저장공간만 낭비되는 현상이 발생함

<br/>

# B-Tree 인덱스를 통한 데이터 읽기

인덱스 사용 유도, 또는 미사용을 판단할려면 어떻게 인덱스를 경유해서 레코드를 조회하는지 알아야함

### 인덱스 레인지 스캔

- 인덱스 접근 방법중 가장 대표적인 접근 방식
- 검색해야 되는 인덱스의 범위가 정해져 있을때문 사용하는 방식
- 루트 노드에서 시작해서 브랜치노드를 거쳐 최종 리프노드까지 찾아서 가야 필요한 레코드 시작지점 확인이 가능함
- 문제는 이렇게 가져온 시작지점 부터 끝 지점까지 레코드 한 건 단위로 랜덤 I/O가 하나씩 발생함

```sql
select * from employees where first_name between 'Ebbe' and 'Gad';
```

#### 상세한 단계 구분

1. 인덱스 탐색을 통해서 조건을 만족하는 값이 저장된 위치를 찾음
2. 1번에서 탐색된 위치부터 필요한 인덱스 만큼 차례대로 쭉 읽음
3. 필요한 경우 2에서 읽은 인덱스 키와 레코드 주소로 레코드가 저장된 페이지를 읽고, 실제 레코드를 가져옴

> 3번은 안할수도 있는데 이를 커버링 인덱스라고 부름

#### 수행 개수 확인하기

```sql
mysql> show status like 'Handler_%';
+----------------------------+--------+
| Variable_name              | Value  |
+----------------------------+--------+
| Handler_commit             | 83     |
| Handler_delete             | 0      |
| Handler_discover           | 0      |
| Handler_external_lock      | 248    |
| Handler_mrr_init           | 0      |
| Handler_prepare            | 2      |
| Handler_read_first         | 5      |
| Handler_read_key           | 139    |
| Handler_read_last          | 0      |
| Handler_read_next          | 16302  |
| Handler_read_prev          | 0      |
| Handler_read_rnd           | 0      |
| Handler_read_rnd_next      | 300034 |
| Handler_rollback           | 0      |
| Handler_savepoint          | 0      |
| Handler_savepoint_rollback | 0      |
| Handler_update             | 1      |
| Handler_write              | 0      |
+----------------------------+--------+
18 rows in set (0.00 sec)
```

- Handler_read_key : 1번 단계가 실행된 횟수
- Handler_read_next/prev : 2번 단계로 읽은 레코드 개수
  - next : 인덱스를 정순으로 읽은 레코드 건수
  - prev : 인덱스를 역순으로 읽은 레코드 건수
- Handler_read_first/last : 인덱스의 첫번째 레코드와 마지막 레코드를 읽은 횟수

<br/>

### 인덱스 풀 스캔

- 인덱스를 처음부터 끝까지 다 읽는 방식
- 대표적으로 쿼리의 조인 조건절에 사용된 컬럼이 인덱스의 첫번째 컬럼이 아니면 풀스캔 방식이 사용됨
  - 인덱스를 정렬되어 있어 A, B, C 순인데 B나 C로 조인하는 경우임
- 일반적으로 인덱스의 크기는 테이블의 크기보다는 작아서 인덱스만 읽는게 효율적임
  - 만약 레코드까지 다 읽어야 한다면 절대 이 방식으로 사용하면 안됨
- 레인지 스캔보다는 느리지만, 테이블 풀 스캔보다는 효율적임
  - 인덱스의 크기는 테이블보다는 훨씬 작아서 풀스캔보다 적은 디스크 I/O로 처리가 가능함

<br/>

### 루스 인덱스 스캔

- 말 그대로 느슨하게 또는 듬성듬성하게 인덱스를 읽는것을 뜻함
- 스캔 도중 중간에 필요하지 않은 인덱스 키 값은 무시(SKIP)하고 다음으로 넘어가는 형태
- 보통 `GROUP BY` or `MAX()`, `MIN()` 함수에 대해서 처리할때 사용함

#### 예제

> (dept_no, emp_no) 컬럼으로 인덱스가 있다고 가정

```sql
select dept_no, MIN(emp_no)
from dept_emp
where dept_no between 'd002' and 'd004'
group by dept_no;
```

- dept_no는 이미 정렬이 되어있으므로 dept_no 그룹 별 emp_no만 읽으면 됨

<br/>

### 인덱스 스킵 스캔

- 기존 루스 인덱스 스캔과 비슷하지만 스킵 스캔의 경우 WHERE 조건절의 검색을 위해 사용이 가능하도록 범위가 넓어짐
- 하지만 인덱스의 선행 칼럼의 유니크한 값이 많다면 옵티마이저에서 더 느려질수도 있음
- 또한 쿼리가 인덱스에 존재하는 컬럼만으로 처리가 가능해야함(커버링 인덱스)
- 결국 인덱스 스킵 스캔은 선행 컬럼이 가진 유니크한 값이 소량일때만 적용 가능한 최적화임

```sql
-- gender + birth_date로 복합 인덱스 생
alter table employees add index ix_gender_birthdata (gender, birth_date);

-- 인덱스 사용 불가
select * from employees where birth_date >= '1965-02-01';

-- 인덱스 사용 가능
select * from employees where gender='M' and birth_date>='1965-02-01';
```

<br/>

# 다중 컬럼(Multi-Column) 인덱스

- 실제 서비스용 디비의 경우 2개 이상의 컬럼을 포함하는 인덱스가 더 많이 사용됨
- 인덱스의 두번째 컬럼은 첫번째 컬럼에 의존해서 정렬됨
  - 즉 두번째 컬럼의 정렬은 첫 번째 컬럼이 똑같은 레코드 에서만 의미가 있음
- 다중 컬럼 인덱스의 경우 각 컬럼의 위치(순서)가 상당히 중요함

<br/>

# B-Tree 인덱스의 정렬 및 스캔 방향

### 인덱스의 정렬

- 인덱스의 키는 항상 오름차순 또는 내림차순으로 정렬되어 저장된다
- 인덱스를 어느 방향으로 읽을지는 옵티마이저가 실시간으로 만들어내는 실행 계획에 따라 달라진다

<br/>

### 인덱스의 스캔 방향

- 인덱스는 생성 시점에 오름차순 또는 내림차순으로 결정됨
- 하지만 스캔 방향의 경우 쿼리가 그 인덱스를 읽는 방향에 따라서 결정됨

```sql
-- 인덱스 특성으로 인해 레코드를 찾으면 굳이 또 정렬을 할 필요가 없음
select * from employees where first_name >= 'Annke'
order by first_name limit 4;

-- 인덱스를 역순으로 스캔하면서 처음 5개의 레코드만 찾으면됨
select * from employees
order by first_name desc limit 5;
```

<br/>

### 내림차순 인덱스

- 만약 2개 이상의 컬럼으로 구성된 복합 인덱스에서 각 키의 순서가 혼합되면, 내림차순 인덱스로만 해결이 가능함

```sql
create index ix_a_b ON table (a ASC, b DESC);
```

#### 뭐가 더 성능이 좋을지

- 단순하게 역순으로 정렬하게 되는 경우 약 30% 정도 더 느리다
- 이는 인덱스 구조와도 연관이 있다
  - 페이지 락이 정순 스캔에 적합한 구조다
  - 페이지 내 인덱스 레코드가 단방향으로만 연결되어있다
- 앱에서 어떤 쿼리를 자주 쓰는지에 따라서 인덱스의 방향도 결정하면 좋다

<br/>

# B-Tree 인덱스의 가용성과 효율성

### 비교 조건의 종류와 효율성

- 다중 컬럼 인덱스에서 그 컬럼의 순서와 비교조건에 따라서 각 인덱스 컬럼의 활용 형태가 달라짐
- 작업 범위를 결정하는 조건은 많을수록 쿼리의 처리 성능을 높이지만, 체크 조건은 많다고해서 쿼리의 처리 성능을 높이지는 못함

#### 예시

> CASE A: INDEX(dept_no, emp_no)  
> CASE B: INDEX(emp_no, dept_no)

```sql
select * from dept_emp
where dept_no='d002' and emp_no >= 10114;
```

- CASE A
  - dept_no='d002' AND emp_no>=10144인 레코드를 찾음
  - 그 이후에는 dept_no='d002'가 아닐때까지 쭉 스캔하면됨
  - 5개의 값을 찾는다면 5번의 비교 작업만 해서 효율적임
- CASE B
  - emp_no>=10144 AND dept_no='d002'인 레코드를 찾음
  - 그 이후에는 모든 레코드에 대해서 dept_no가 d002인지 비교하는 과정이 필요함
  - 5개의 값을 찾는다면 비교하는 과정으로 인해 그 이상의 비용이 소모됨

<br/>

### 인덱스의 가용성

- 인덱스의 키 값의 정렬 특성은 빠른 검색을 위한 전제 조건이다
- 다중 컬럼의 경우 왼쪽 컬럼의 값을 모른다면, 인덱스 레인지 스캔이 불가능함
- 이런 조건은 WHERE 말고도 ORDER BY, GROUP BY도 동일하게 적용됨

#### 예제 1

```sql
select * from employees where first_name like '%mer';
```

- 인덱스가 정렬되서 저장될 때 앞 단어를 기준으로 정렬되서 저장된다
- 앞쪽에 like를 사용하는 경우는 인덱스의 효과를 얻을 수 없다

#### 예제 2

> INDEX(dept_no, emp_no)로 가정

```sql
select * from dept_emp where emp_no>=10144;
```

- 선행 컬럼인 dept_no 없이 emp_no만 사용한다면 인덱스를 효율적으로 사용이 불가능함
- 인덱스는 dept_no를 기준으로 먼저 정렬하고, 다시 emp_no를 기준으로 정렬되어 저장됨

<br/>

### 가용성과 효율성 판단

- 아래 목록은 작업 범위 결정 조건으로 사용이 불가능한 조건들임
- 경우에 따라서 체크 조건으로 인덱스를 사용할 수 있음

#### NOT-EQUAL로 비교된 경우("<>", "NOT IN", "NOT BETWEEN", "IS NOT NULL")

- WHERE COLUMN <> 'N'
- WHERE column NOT IN ('N1', 'N2')
- WHERE column NOT BETWEEN 'N1' AND 'N2'

#### LIKE'%??' (앞쪽에 라이크를 사용한 경우)

- WHERE column LIKE '%승환'
- WHERE column LIKE '\_승환'
- WHERE column LIKE '%승%'

#### 스토어드 함수나 다른 연산자로 인덱스 컬럼이 변형된 후 비교된 경우

- WHERE SUBSTRING(column, 1, 1) = 'X'
- WHERE DAYOFMONTH(column) = 1

#### NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우

- WHERE column = deterministic_function()

#### 데이터 타입이 서로 다른 비교 (인덱스 컬럼의 형변한이 필요한 경우)

- WHERE char_column = 10

#### 문자열 데이터 타입의 콜레이션이 다른 경우

- WHERE utf8_bin_char_column = euckr_char_column

#### 인덱스 사용 가능 조건 비교

> INDEX(col1, col2, col3)

- 작업 범위 결정 조건으로 인덱스를 만족하지 못한 경우
  - col1 컬럼에 대한 조건이 없을때
  - col1 컬럼의 비교 조건의 위 인덱스 사용불가 조건 중 하나일때
- 작업 범위 결정 조건으로 인덱스를 사용하는 경우
  - col1 ~ col(i-1) 컬럼까지 동등 비교 형태("=" or "IN")
  - col1 컬럼에 대해서 아래 연산자 중 하나로 비교
    - 동등 비교("=" or "IN")
    - 크고 작다 형태(">" or "<")
    - 뒷라이크 일치 패턴(LIKE "승환%")
