# 테이블 압축

- 페이지 압축과 다르게 제약사항이 없어서 일반적으로 활용도가 더 높은편임
- 디스크에 저장되는 데이터 파일의 크기를 줄일수 있어서 그만큼의 이득은 있지만 단점도 존재함
  - 버퍼 풀 공간 활용율 낮음
  - 쿼리 처리 성능 낮음
  - 빈번한 데이터 변경시 압축률이 떨어짐

<br/>

# 압축 테이블 생성

- 전제조건으로 압축을 사용하려는 테이블이 별도의 테이블 스페이스를 사용해야함
- `innodb_file_per_table` 옵션이 활성화된 상태에서만 사용이 가능함
- `ROW_FORMAT=COMPRESSED` 옵션을 사용해야 압축이 적용됨, 생략시 자동으로 들어감
- `KEY_BLOCK_SIZE`로 페이지의 목표를 명시해야함
  - 2n 즉 2 이상의 값만 사용이 가능함
  - 페이지 크기(`innodb_page_size`)가 16KB면 4, 8K만 설정이 가능함
  - 페이지 크기가 32KB, 64KB 인 경우는 테이블 압축 사용이 불가능함

```sql
set global innodb_file_per_table = ON;

create table compresseed_table (
	id int auto_increment primary key
)
KEY_BLOCK_SIZE=8;*
```

<br/>

### 압축 과정

> 압축 과정에선 InnoDB 스토리지 엔진은 아무런 역할이 없음

- 페이지 크기가 16KB 이며, 블록 크기가 8KB인 경우를 가정함
- 16KB인 데이터 페이지를 압축함
  - 8KB 이하면 그대로 디스크에 저장 -> 압축완료
  - 8KB 초과면 원본 페이지를 쪼개서 2개의 페이지에 8KB씩 저장
- 쪼개진 페이지에 대해서 1번 과정을 계속해서 수행

<br/>

# KEY_BLOCK_SIZE 설정

- 가장 중요한 부분이 해당 사이즈를 설정하는 것임
- 4 or 8KB로 생성하고 샘플데이터를 저장해보고 적절한지 판단하면됨
- `information_schema.INNODB_CMP_PER_INDEX` 테이블을 통해서 확인이 가능함

<br/>

# 압축된 페이지의 버퍼 풀 적재 및 사용

- 압축된 테이블의 데이터 페이지를 버퍼 풀에 적재하면 압축전, 압축후 2개의 버전을 관리함
  - LRU 리스트 : 디스크에서 읽은 그대로의 데이터 페이지 목록
  - Unzip_LRU 리스트 : 압축 해제 버전
- 동시에 2개의 버전을 관리하느라 버퍼 풀의 공간을 이중으로 사용해서 메모리를 낭비하는 효과를 가짐
- 또한 압축된 페이지에서 데이터를 읽거나 변경하면 해제가 필요한데 이는 CPU를 많이 사용함

<br/>

### 어댑티브 알고리즘

> 단점을 보완하기 위해서 Unzip_LRU를 별도로 보관하다가 유입되는 요청 패턴에 의해 적절하게 처리함

- 버퍼 풀의 공간이 필요하면 LRU 리스트는 유지하고, Unzip_LRU는 제거해서 공간 확보
- 압축된 데이터의 페이지가 자주 사용되면 Unzip_LRU에서 유지하면서 CPU 사용률 최소화
- 페이지 미사용으로 인해 LRU 리스트에서 제거되면 Unzip_LRU에서도 같이 제거
- CPU 사용률이 높은 상태면 압축, 해제를 피하기 위해서 Unzip_LRU의 비율을 높여서 사용
- Disk I/O가 높은 서버는 Unzip_LRU의 비율을 낮춰서 버퍼 풀 공간을 더 확보

<br/>

# 테이블 압축 관련 설정

- `innodb_cmp_per_index_enabled`
  - 테이블 압축이 사용된 테이블의 모든 인덱스별 압축 성공 및 실행횟수를 수집하도록 설정
  - `information_schema.INNODB_CMP_PER_INDEX, INNODB_CMP` 테이블을 통해서 확인이 가능함
- `innodb_compression_level`
  - 압축률을 설정할 수 있음. 0~9 중에서 선택 가능. 기본값은 6이다

그 외 다양한 옵션이 존재함
