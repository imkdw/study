# MySQL 엔진 아키텍쳐

- MySQL 서버는 2가지로 구분이 가능함
  - MySQL 엔진 : 사람의 머리 역할을 담당
  - 스토리지 엔진 : 사람의 손, 발 역할을 담당

<br/>

### MySQL 엔진

- 커넥션 핸들러 : 클라이언트의 접속 및 쿼리 요청을 처리
- SQL 파서 및 전처리기
- 옵티마이저 : 쿼리의 최적화된 실행

<br/>

### 스토리지 엔진

- 디스크에 데이터를 저장하거나 데이터를 읽어오는 부분을 담당
- MySQL 엔진은 1개이지만, 스토리지 엔진은 여러개 사용이 가능함
- 테이블 생성시 사용할 스토리이 엔진 지정이 가능함
- 각 스토리지 엔진은 키 캐시, 버퍼 풀 등의 기능을 내장하고 있음

```
mysql> create table test_table (fd1 INT, fd2 INT) ENGINE=INNODB;
Query OK, 0 rows affected (0.01 sec)
```

<br/>

### 핸들러 API

- 스토리지 엔진에 쓰기 또는 읽기를 요청하는걸 핸들러 API라고 부름
- `SHOW GLOBAL STATUS LIKE 'Handler%'` 명령어로 정보 확인이 가능함

<br/>

# MySQL 스레딩 구조

- MySQL 서버는 프로세스가 아닌 스레드 기반으로 작동
- 크게 포그라운드, 백그라운드로 구분이 가능함

<br/>

### 포그라운드 스레드(클라이언트 스레드)

- MySQL 서버에 접속된 클라이언트의 수 만큼 존재하고 클라이언트에서 요청하는 쿼리 문장을 처리
- 커넥션이 종료되면 다시 스레드 캐시로 돌아가고, 캐시가 충분히 있다면 스레드를 종료시킴
  - `thread_cache_size` 시스템변수로 제어가 가능함
- 데이터를 데이터 버퍼나 캐시로 부터 가져오고, 없다면 직접 디스크, 인덱스에서 가져옴

#### MyISAM vs InnoDB

- MyISAM은 디스크 쓰기 작업도 포그라운드 스레드가 전부 수행
- InnoDB는 데이터 버퍼, 캐시까지만 포그라운드가 처리, 나머지 기록 작업은 백그라운드가 처리

<br/>

### 백그라운드 스레드

- InnoDB는 다양한 작업을 백그라운드 스레드에서 수행함
  - 로그를 디스크로 기록
  - 데이터를 버퍼로 읽어오기 등..
- innodb_write_io_threads, innodb_read_io_threads로 스레드 개수 설정이 가능함
  - 읽기 작업은 클라이언트 스레드에서 처리하지만, 쓰기는 대부분 백그라운드에서 처리함
  - 내장 디스크 사용시는 2~4개, DAS/SAN 같은걸 사용하면 최적으로 사용할 수 있는만큼
- 이런 특성으로 InnoDB는 쿼리로 데이터가 변경되는 경우 완전히 저장될 때 까지 기다리지 않음

<br/>

# 메모리 할당 및 사용 구조

- 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분됨
- 보통 2개의 영역은 MySQL 서버 내에서 많은 스레드 공유해서 사용하는 공간인지에 따라 구분

<br/>

### 글로벌 메모리 영역

- 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당됨
- 필요에 따라서 여러개를 받을수도 있지만, 여러개를 생성하더라도 모든 스레드에 의해 공유됨
- 테이블캐시, InnoDB 버퍼 풀 등이 이에 속함

<br/>

### 로컬 메모리(세션 메모리) 영역

- MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용하는 영역
- 각 클라이언트 스레드별로 독립적으로 할당되고, 절대 공유되어 사용되지 않는 특징이 있음
- 가능성은 희박하지만 메모리 부족으로 인해 장애가 발생할 수 있으니 적절한 공간설정이 중요함
- 정렬버퍼, 조인버퍼 등이 이에 속함

<br/>

# 플러그인 스토리지 엔진 모델

- 스토리지 엔진 외 직접 스토리지 엔진을 개발해서 사용하는것도 가능함
- MySQL은 대부분 작업은 자체 MySQL 엔진에서 처리되고, 데이터 읽기/쓰기만 스토리지 엔진에서 처리
- 스토리지 엔진은 데이터 읽기, 쓰기만 하고 대부분 복잡한 쿼리는 쿼리 실행기에 처리함
- 하나의 쿼리 작업은 여러 작업으로 나뉘는데 하위 작업이 어떤 영역에서 처리되는지 이해해야함

<br/>

### 핸들러

- 프로그래밍 언어에서 어떤 기능을 호출하기 위해서 사용하는 운전대의 역할
- MySQL 엔진이 스토리지 엔진을 제어할때도 핸들러 API가 사용됨

<br/>

# 컴포넌트

- 기존 플러그인의 단점을 개선하기 위해서 8 버전에서 도입된 개념
- 대표적으로 비밀번호 검증 플러그인(validate_password)가 컴포넌트로 변경됨

<br/>

# 쿼리 실행 구조

### 쿼리 파서

- 요청된 쿼리를 트리 형태의 구조로 만드렁 내는 작업
- 쿼리 문장의 기본 문법 오류가 해당 과정에서 식별됨

<br/>

### 전처리기

- 쿼리 파서의 결과물로 객체 존재여부, 접근권한 등 검증을 수행
- 존재하지 않거나, 권한이 없는 개체의 토큰은 해당 과정에서 걸러짐

<br/>

### 옵티마이저

- 요청된 쿼리를 어떻게 최소한의 비용으로 빠르게 처리할지 결정하는 과정
- DBMS의 두뇌에 해당하고, 옵티마이저의 역할은 중요하고 영향 범위도 매우 넓음

<br/>

### 실행 엔진

- 회사로 따지면 실행엔진은 중간 관리자의 역할에 속함. 옵티마이저는 경영진이다
- 만들어진 계획대로 각 핸들러에게 요청하고, 받은 결과를 또 다른 핸들러로 전달하는 역할을 수행

<br/>

### 핸들러(스토리지 엔진)

- 가장 밑단에서 데이터의 읽기/쓰기 작업을 담당함
- 핸들러는 결국 스토리지 엔진을 의미함

<br/>

# 쿼리 캐시

- 쿼리의 실행결과를 메모리에 캐시하고, 동일한 쿼리가 오면 해당 데이터를 그대로 주는 기능
- 하지만 캐시 갱신 과정에서 수많은 에러가 발생했고 성능저하의 원인이 됬음
- 8 버전 부터는 쿼리 캐시기능은 완전히 제거되었음

<br/>

# 스레드 풀

- 커뮤니티 버전에서는 따로 제공하지 않는 기능, Percona Server에서 제공하는 스레드 풀 기능으로 대체한다
- 스레드 풀의 목적은 CPU가 제한된 스레드 처리에만 집중하게 해서, 자원 소모를 줄이는 것이 목적
- 단순 설치로는 성능상 큰 변화가 없음

<br/>

### Percona Server

- 기본적으로 CPU 코어의 개수만큼 스레드 그룹을 생성
  - `thread_pool_size` 시스템 변수로 조정이 가능함
  - 하지만 대부분은 CPU 코어와 개수를 맞추는게 프로세서의 친화도를 맞추는데 좋음
- `thread_pool_oversubscribe` 시스템 변수로 추가 작업을 허용할 수 있음
  - 하지만 값이 너무 크면 스레드풀이 비효율적으로 동작할수도 있음
- `thread_pool_stall_limit`으로 새로운 스레드 추가 또는 대기를 지정할 수 있음
  - 지정한 시간동안 작업이 지연되면 새로운 스레드를 스레드 그룹에 추가함
  - 스레드 개수는 `thread_pool_max_thread`에 지정된 개수를 넘어갈 수 없음

<br/>

# 트랜잭션 지원 메타데이터

### 테이블 딕셔너리 / 메타데이터

- 테이블의 구조 정보, 스토어드 프로그램 등의 정보를 테이블 딕셔너리 / 메타데이터라고 부름
- 5 버전에서는 .FRM 파일에 저장하고 일바 스토어드 프로그램은 또 다른곳에 저장됨
- 파일 기반 시스템은 MySQL 비정상 종료시에 일관성이 보장되지 않는 문제가 있었음

<br/>

### 8 버전에서 개선한 방법

- 모든 데이터는 파일시스템이 아니라 InnoDB 테이블에 저장되도록 변경됨
- MySQL DB는 통째로 mysql.ibd라는 테이블 스페이스에 저장됨
- InnoDB 테이블은 트랜잭션을 기반으로 동작하므로 완전저장 또는 완전삭제가 되어서 일관성이 보장됨
