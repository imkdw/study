# InnoDB 스토리지 엔진 아키텍쳐

- 스토리지 엔진 중 거의 유일하게 레코드 기반 잠금을 제공
- 동시성 처리가 가능하고 안정적이며 성능이 좋음

<br/>

# 기본키에 의한 클러스터링

- 모든 테이블을 기본키를 기준으로 클러스터링 되어 저장
- 모든 세컨더리 인덱스는 레코드 주소 대신, 기본키의 값을 논리적인 주소로 사용
- 기본키를 통한 스캔은 매우 빠르게 처리됨
  - 쿼리 실행계획을 통해서 확인하면 비중이 다른 보조 인덱스보다 기본키가 선택될 확률이 높음
- MyISAM은 클러스터링 키를 지원하지 않음
  - 기본키와 세컨더리 인덱스는 구조적으로 아무런 차이가 없음

<br/>

# 외래 키 지원

- 스토리지 엔진 레벨에서 제공하는 기능으로 MyISAM 이나 MEMORY 테이블에선 사용이 불가능함
- 외래키가 걸린 테이블에서 데이터 변경시 자식 데이블에 데이터가 있는지 확인하는 과정이 필요함
  - 이 과정에서 잠금이 여러개의 테이블로 전파되어 데드락이 발생할수도 있으니 주의해야함

### 외래키 체크 비활성화

- `SET FOREIGN_KEY_CHECKS = 0` 을 통해서 비활성화가 가능함
- 일시적으로 ON/OFF 하는것을 권장하고 비활성화 되면 CASCADE도 모두 비활성화됨
- 기본적 명령어 입력시는 해당 세션에만 적용되고, 글로벌로 등록도 가능함

<br/>

# MVCC(Multi Version Concurrency Control)

- 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능으로 잠금을 사용하지 않는 일관된 읽기를 제공
- 멀티버전은 하나의 레코드에 대해서 여러 개의 버전이 동시에 관리된다는 의미
- 트랜잭션 격리 레벨에 따라서 어떻게 데이터를 읽을지 방식이 달라짐

<br/>

### 예시

- INSERT 문을 통해서 데이터를 삽입
  - 디스크 내부에 데이터가 저장되고 InnoDB 버퍼 풀에 해당 데이터가 추가됨
- UPDATE 문을 통해서 데이터를 수정
  - 디스크에 데이터가 바로 반영되지 않고 Undo Log 내부에 변경된 데이터가 저장됨
- `READ_UNCOMMITTED` 모드로 조회
  - InnoDB 버퍼풀에 있는 데이터를 읽어옴
- `READ_COMMITTED 또는 그 이상의 격리수준`
  - 실제 디스크에 저장된 데이터를 읽어옴
- 트랜잭션에 COMMIT이 실행되면 Undo Log에 데이터를 지우고 실제 디스크에 저장됨
  - 이 때 커밋을 한다고 무조건 삭제되는건 아니고 다른 트랜잭션에서 더이상 안쓸때 삭제됨

<br/>

### 단점

- 트랜잭션의 러닝타임이 길면 Undo Log에 데이터가 많이 저장될수도 있음

<br/>

# 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

- MVCC 기능으로 인해서 읽기 작업시 따로 잠금없이 읽기가 가능함
- 하지만 장시간 트랜잭션으로 인한 문제가 발생할 수 있으니 가능하면 빨리 롤백이나 커밋을 해야함

<br/>

# 자동 데드락 감지

- 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 목록을 그래프형태로 관리
  - 내부적으로 데드락 감지 스레드를 위한 별도의 스레드가 존재
  - 주기적으로 잠금 대기 그래프를 검사해서 교착 상태에 빠진 트랜잭션을 종료함
  - 트랜잭션의 종료 순쉬은 Undo Log의 양을 기준으로 선별함

<br/>

### MySQL 엔진에서 관리하는 테이블 잠금

- `LOCK TABLES` 명령어로 잠긴 테이블은 감지가 불가능함
- `innodb_table_locks` 시스테 변수로 제어가 가능하고 별다른 이유가 없으면 활성화를 권장

<br/>

### 데드락 감지 스레드의 부하

- 동시처리가 매우 많거나 잠금개수가 많아지면 데드락 감지 스레드도 느려짐
- 데드락 스레드는 잠금 목록이 저장된 리스트에 새로운 잠금을 걸고 데드락 스레드를 찾음
- `innodb_deadlock_detect`로 감지를 할지말지 제어가 가능함
  - 하지만 끄는 경우 데드락이 발생해도 중재가 불가능해서 무한대기가 발생할수도 있음
- `innodb_lock_wait_timeout` 로 데드락이 일정 시간이 지나면 에러를 반환하게 할수 있음
  - 만약 감지를 하지 않는 상황이라면 timeout을 기본값인 50초 보다 낮춰서 사용하는걸 권장

<br/>

# 자동화된 장애 복구

- 매커니즘을 사용해서 완료되지 못한 트랜잭션 등 일련의 복구 작업이 자동으로 진행됨
- 왠만해서는 에러가 발생하지 않지만 하드웨어 이슈 등으로 발생하면 복구하기가 쉽진 않음
  - 자동으로 복구가 불가능한 손상이 있다면 그냥 종료됨
- `innodb_force_recovery` 시스템 변수로 자동복구 레벨 제어가 가능함
  - 해당 값은 1~6까지 존재하고 값이 클수록 심각한 상황이고 복구 가능성이 적어짐
- 아래 모든 레벨로도 복구가 안되면 백업으로 DB를 재구축하는게 제일 좋음
- 자동화 복구보다는 풀백업인 바이너리 로그로 복구하는게 더 정확도가 높음

<br/>

### 1 - SRV_FORCE_IGNORE_CORRUPT

- 테이블스페이스의 데이터나 인덱스 페이지에서 손상된 부분이 발견되도 그냥 실행
- mysqldump 또는 SELECT INTO OUTFILE로 DB를 새로 구축하는게 좋음

<br/>

### 2 - SRV_FORCE_NO_BACKGROUND

- 여러개의 백그라운드 스레드 중 메인스레드 없이 서버를 실행
- 보통 Undo Log 내부 데이터를 삭제하다가 에러가 발생하면 해당 모드로 복구하면됨

<br/>

### 3 - SRV_FORCE_NO_TRX_UNDO

- 원래 서버를 시작하면 커밋되지 않은 트랜잭션을 모두 롤백하고 실행함
- 이 모드는 커밋되지 않은 트랜잭션을 롤백하지 않고 그대로 유지함
- 서버가 시작되면 mysqldump로 데이터를 백업해서 다시 구축하는게 좋음

<br/>

### 4 - SRV_FORCE_NO_IBUF_MERGE

- INSERT BUFFER의 손상이 감지되면 서버는 종료됨
- 해당 모드는 손상을 무시하고 그냥 서버를 시작시킴
- 다행히 실제 데이터에 대한 부분은 아니라 테이블 덤프 후 다시 DB를 구축하면됨

<br/>

### 5 - SRV_FORCE_NO_UNDO_LOG_SCAN

- 트랜잭션 진행중인 동안 장애 발생시 커넥션을 끊고 바로 작업을 종료함
- 원래는 UNDO RECORD로 장애상황 데이터를 재현하지만 해당 모드는 무시하고 실행함
  - 모두 커밋된거처럼 처리되지만 실제 DB에는 비정상 데이터가 존재함
- 데이터를 백업하고 DB를 재구축하는게 좋음

<br/>

### 6 - SRV_FORCE_NO_LOG_REDO

- REDO LOG가 손상되면 서버는 종료됨
- 실제 디스크 파일에 기록되지 않은것 모두 날라가고 마지막 시점의 데이터만 남게됨
- 데이터 백업하고 DB를 재구축하는게 좋음

<br/>

# InnoDB 버퍼 풀

- 디스크의 데이터 파일이나 이덱스 정보를 메모리에 캐시해두는 공간
- 일반적으로 CREATE, UPDATE 등을 수행하면 데이터 파일의 이곳저곳에 위치한 레코드를 변경시킴
  - 랜덤한 디스크 작업을 발생시키지만, 버퍼풀로 한곳에서 관리하면 디스크 작업 회수를 줄임

<br/>

### 버퍼 풀의 크기 설정

- 서버의 메모리 용량 기준으로 버퍼 풀의 크기를 조정하는게 좋음
- 램이 8GB 미만이라면 50% 4GB 정도가 권장됨
- 램이 그 이상이라면 50% 정도를 기반으로 천천히 늘려서 최적점을 찾는게 좋음
- `innodb_buffer_pool_size` 시스템 변수로 조정가능
  - 변경시 가능하면 DB에 부하가 제일 적은 시간에 하는게 좋음
  - 늘리는건 상관없지만 줄이는 작업은 서비스 영향도가 매우 높으니 지양하는게 좋음

<br/>

### 내부 잠금 경합

- 기존에는 버퍼 풀 전체를 관리하는 잠금으로 인해서 내부 잠금 경합이 많이 유발됬음
- 현재는 128MB 단위의 청크로 쪼개서 관리할 수 있음
- 기본적으로 8개의 인스턴스로 설정되지만 1GB 미만의 DB에선 1개로 초기화됨
- 메모리가 40GB 이하라면 기본값 8을 유지하고, 그 이상이면 인스턴스당 5GB 정도가 좋음

<br/>

### 버퍼 풀의 구조

- 버퍼 풀이라는 거대한 메모리 공간을 페이지 단위로 쪼개고, 스토리지 엔진이 데이터가 필요할때 읽어와서 각 조각에 저장함

#### 조각을 관리하기 위해서 사용하는 자료구조

- 프리 리스트
  - 버퍼 풀에서 실제 사용자의 데이터로 채워지지 않은 비워져있는 영역
  - 쿼리가 새롭게 디스크의 데이터를 읽어와야할때 사용함
- LRU(Least Recently Used)
  - 사실상 LRU와 MRU(Most Recently Used)가 합쳐져있는 구조임
  - 과정
    - 필요한 레코드가 데이터 페이지에 있는지 검사하고 읽어옴, 이 때 LRU에 포함
    - 이미 데이터 페이지에 있다면 MRU로 이동
    - 그렇게 계속 사용되지 않는건 제거되고, 오랬동안 사용 안되다가 다시 사용되면 MRU로 이동
    - 데이터가 자주 접근됬다면 해당 페이지의 인덱스 키가 어댑티브 해시 인덱스에 추가됨
- 플러시 리스트
  - 디스크와 동기화되지 않은 데이터를 가진 페이지의 변경시점 기준 페이지 목록을 관리
  - 한번 이상 변경이 발생했다면 플러시 리스트에서 관리됨
  - 변경이 발생하면 리두 로그에 반영되고 디스크에 기록됨
    - 여기서 페이지에 데이터가 디스크의 데이터도 기록됬다는걸 항상 보장하진 않음

<br/>

### 버퍼 풀과 리두 로드

- InnoDB의 버퍼 풀은 서버의 메모리가 허용하는 만큼 크게 설정하면 할수록 쿼리 성능이 좋아짐
- 버퍼 풀에는 데이터 캐시와 쓰기 버퍼링이 있는데 단순히 버퍼 풀만 올리는건 캐시기능만 올리는거임
- 버퍼 풀의 크기가 100GB 미만이라면 리두 로그 파이르이 크기를 5~10GB로 선택하고 필요하면 늘려나가면서 최적값을 찾는게 좋음
  <br/>

#### 클린페이지 / 더티페이지

- 클린 페이지
  - 디스크에서 읽은 상태로 전혀 변경되지 않는 데이터가 저장
- 더티페이지
  - 클린페이지에서 1회 이상 변경된 데이터가 저장
  - 버퍼풀과 디스크의 상태가 다르기때문에 언젠가는 디스크에 저장되어야함

<br/>

#### 리두 로그 파일

- 리두로그는 1개 이상의 고정 크기 파일을 연결해서 순환 고리처럼 사용함
- 리두 로그 파일에서 재사용 가능한 공간과 불가능한 공간을 나누는데 활성 리두 로그는 불가능한 공간임
- 계속 순횐돠므로 매번 기록될때마다 내부의 LSN(Log Sequence Number)이 1씩 증가함

<br/>

#### 체크포인트

- 주기적으로 체크포인트 이벤트를 발생시켜서 리두 로그랑, 버터 풀의 더티페이지를 디스크랑 동기화함
- 이 때 가장 최근 체크포인트의 LSN, 마지막 리두 로그 엔트리의 LSN의 차이가 체크포인트 에에지가 됨
- 결국 체크포인트 에이지는 활성 리두 로그 공간의 크기를 뜻함
- 이벤트가 발생하면 체크포인트 LSN보다 작은 더티페이지, 리두 로드 엔트리 모두 디스크로 동기화됨

<br/>

### 버퍼 풀 플러시

- 리두 로그 공간의 재활용을 위해서 주기적으로 오래된 리두 로그 엔트리가 사용하는 공간을 비워야함
- 리두 로그 공간을 지울려면 풀 버퍼의 더티페이지가 디스크로 동기화 되어야함
- 아직 디스크로 기록되지 않은 더티 페이지들을 성능상 악영향 없이 디스크에 동기화하기 위해서 2개의 플러시 기능을 백그라운드에서 수행함

<br/>

#### 플러시 리스트 플러시

- **클리너 스레드**
  - 더티 페이지를 디스크로 동기화 하는 스레드
  - `innodb_page_cleaners` 시스템 변수로 개수 조정 가능
  - 설정값이 버퍼 풀 인스턴스보다 크면 `innodb_buffer_pool_instances`으로 맞춰짐
  - 별 다른 문제가 없다면 2개의 시스템 변수를 같은 값으로 사용하면됨
- **더티 페이지의 최대 비율**
  - 일반적으로 버퍼 풀 내부에서 더티페이지는 90% 까지 점유가 가능함
  - `innodb_max_dirty_pages_pct`로 조정이 가능함
  - 하지만 비율이 너무 크면 한번에 많은 데이터 동기화를 위해 `Disk I/O Burst`가 발생할수도 있음
  - `innodb_max_dirty_pages_pct_lwm` 은 일정 수준 이상으로 더티 페이지 비율이 올라가면 조금씩 동기화를 하도록 도와줌. 기본값은 10%임
- **디스크 읽기/쓰기 속도 조정**
  - `innodb_io_capacity`, `innodb_io_capacity_max` 시스템 변수로 조정가능
  - 하지만 자체적인 알고리즘이 있어서 디스크가 1000 IOPS라고 해서 그대로 설정해도 그대로 동작하진 않음
  - 매번 서버마다 다른 디스크를 가진 환경에서 값을 조정하긴 힘들어서 어댑티브 플러시 기능을 제공
    함
  - 단순 비율이나 최대값 등에 의존하지 않고 자체적인 알고리즘으로 처리함
- **디스크에서 근접한 페이지를 묶어서 저장하기**
  - 이전 HDD의 경우 읽기/쓰기가 매우 무거운 작업이였음
  - 하지만 요즘은 대부분 SSD를 사용해서 크게 신경쓰지 않아도됨
  - 현재는 비활성화 되어있음

<br/>

#### LRU 리스트 플러시

- LRU 리스트에서 사용빈도가 낮은 페이지를 제거하기 위해서 LRU 리스트 플러시 함수를 호출
- LRU 리스트의 끝에서 부터 `innodb_lru_scan_depth` 까지 페이지를 스캔
- 더티 페이지는 디스크에 동기화 하고, 클린 페이지는 프리 리스트로 옳겨짐
- 실질적으로 버퍼 풀 인스턴스의 깊이 만큼 탐색하므로 실제 탐색하는 범위는 `innodb_lru_scan_depth * innodb_buffer_pool_instances` 임

<br/>

### 버퍼 풀 상태 백업 복구

- 디스크의 데이터가 버퍼 풀에 적재여부에 따라서 최초 성능이 매우 차이남
- 8 버전에서는 자동 워밍업 과정이 추가되었음

```sql
-- 서버 셧다운 전 버퍼 풀의 상태 백업
mysql> SET GLOBAL innodb_buffer_pool_dump_now = ON;
Query OK, 0 rows affected (0.00 sec)

-- 서버 재시작 후, 백업된 버퍼 풀의 상태 복구
mysql> SET GLOBAL innodb_buffer_pool_load_now = ON;
Query OK, 0 rows affected (0.00 sec)
```

<br/>

#### 백업은 어디에 저장될까

- 데이터 디렉터리 내부 `ib_buffer_pool` 이라는 이름으로 생성됨
- 버퍼 풀의 크기가 커도 파일은 매우 작은데 이는 적재된 페이지의 메타데이터만 저장하기 떄문임
- 하지만 복구 과정을 오래걸리는데 이는 각 테이블의 데이터 페이지를 다시 디스크에서 읽어야하기 때문임
- 그래서 가능하면 복구가 진행중일때는 서비스를 재개하지 않는 게 좋음

```sql
-- 현재 복구중인 과정 확인
mysql> SHOW STATUS LIKE 'Innodb_buffer_pool_size_dump_status'\G;
Empty set (0.01 sec)

-- 복구 취소
mysql> SET GLOBAL innodb_buffer_pool_load_abort=ON;
Query OK, 0 rows affected (0.00 sec)
```

<br/>

### 버퍼 풀의 적재내용 확인

- `information_schema.innodb_cached_indexes` 테이블에서 버퍼풀의 메모리에 어떤 페이지가 적재됬는지 확인이 가능함
- 정확한 확인은 힘들고 어느정도 적재됬는지 정도만 가능

<br/>

# Double Write Buffer

### Partial Page / Torn Page

- 리두 로그는 공간낭비를 방지하기 위해 페이지의 변경된 내용만 기록함
- 만약 더티페이지 -> 디스크 플러시 도중 일부만 기록되는 문제가 발생하면 내용복구가 힘듬
- 보통 하드웨어의 오작동과 시스템 비정상 종료로 인해서 발생함

<br/>

### Double Write 기법

- 위 문제를 막고, 데이터의 안정성을 위해서 주로 사용함
- 실제 디스크로 동기화 전 시스템 테이블스페이스의 Double Write Buffer에 기록함
- 이후에 스토리지 엔진은 각 더티 페이지를 적당한 위치에 하나씩 랜덤으로 쓰기를 실행함
- 내용의 목적은 실제 데티퍼 파일의 쓰기가 중간에 실패할 때만 원래의 내용 목적으로 사용함

<br/>

### 동작 방법

- A, B, C 중 A, B는 잘 기록됬지만 C가 이상하다고 가정한다
- 스토리지 엔진은 항상 재시작될때 Double Write Buffer, 데이터 파일의 페이지를 빅함
- 만약 다른 내용을 담고있다면 Double Write Buffer에 저장된 데이터를 기록함

<br/>

### HDD, SSD

- HDD처럼 자기 원판이 회전하면서 저장하는 시스템은 어짜피 한번의 순차 디스크 쓰기를 해서 큰 상관이 없음
- SSD처럼 랜덤I/O 또는 순차 I/O의 비용이 비슷한 저장 시스템에는 상당히 부담스러움

<br/>

### 써야할까 말하야할까

- 데이터의 무결성이 매우 중요한 서비스에선 사용하는게 좋음
- 하지만 성능을 위해 리두 로그 동기화 설정을 꺼둔 경우는 이것도 끄는게 좋음

<br/>

# 언두 로그

- 언두(Undo) 로그는 DML로 인해 변경되기 이전 버전의 데이터를 백업하는 로그다
- 트랜잭션 처리시 롤백 대비, 격리수준을 위한 동시성 제공을 위해서 주로 사용하게됨
- 이는 스토리지 엔진에서 매우 중요하지만, 관리비용도 많이 필요하게된다

<br/>

### 언두 로그 모니터링

- 트랜잭션이 장시간 유지되는건 성능상 좋지 않음, 모니터링을 하면서 안정적으로 관리하는게 좋음
- INSERT, UPDATE/DELETE의 언두 로그는 개별의 공간에 보관됨
  - UPDATE/DELETE는 MVCC 때문에 필요하지만, INSERT는 그렇지 않음

```sql
mysql> show engine innodb status \g
```

<br/>

### 언두 테이블 스페이스 관리

- 언두 테이블 스페이스는 언ㄷ 로그가 저장되는 공간을 뜻함
- 8 버전 부터 언두 로그는 항상 시스템 테이블스페이스 외부의 별도 로그 파일에서 관리됨
- 테이블 스페이스 1개, 128개 이하의 롤백 세그먼트, 롤백 세그먼트는 1개 이상의 언두슬롯 구성
- InnoDB의 페이지 크기가 기본값인 16KB라면 간략하게 최대 트랜잭션 수 계산이 가능함
  - `(InnoDB 페이지 크기) / 16 * (롤백 세그먼트 개수) * (언두 테이블스페이스 개수)` = 131072
- 딱히 기본값을 바꿀 이유는 없으며 가능하면 기본값을 유지하는게 좋음

<br/>

### 테이블 스페이스 조회, 추가, 삭제

- 8 버전 부터는 동적으로 관리가 가능해졌음

```sql
mysql> select TABLESPACE_NAME, FILE_NAME FROM information_schema.files where FILE_TYPE like 'UNDO LOG';
+-----------------+------------+
| TABLESPACE_NAME | FILE_NAME  |
+-----------------+------------+
| innodb_undo_001 | ./undo_001 |
| innodb_undo_002 | ./undo_002 |
+-----------------+------------+
2 rows in set (0.01 sec)
```

<br/>

### Undo Table Truncate

- 필요한 만큼만 남기고 불필요하게 과도하게 할당된 공간을 OS에게 반납하는것을 뜻함

#### 자동모드

- 퍼지 스레드는 주기적으로 언두 로그 공간에서 불필요한 로그를 삭제하는 작업을 진행
- `innodb_undo_log_truncate`로 ON/OFF가 가능함
- `innodb_purge_rseg_truncate_frequency`로 주기 설정 가능

#### 수동모드

- 자동화가 안되있을때 문제가 발생하면 언두 테이블 스페이스 자체를 비활성화 해서 사용하지 않도록 설정하면 퍼지 스레드는 비호라성화 상태의 언두 테이블을 찾아서 작업하게됨
- 최소 테이블 스페이스가 3개가 있어야 가능함

<br/>

# 체인지 버퍼

- 인덱스를 업데이트 하는 작업은 디스크를 읽어야해서 인덱스가 많다면 매우 무거움
- 이 때 체인지 버퍼를 통해서 버퍼 풀 내부를 먼저 업데이트하고 사용자에게 결과반환이 가능함
- 이후에 백그라운드 스레드에 의해서 병합되는데, 이를 체인지 버퍼 머지 스레드라고 부름
- INSERT, UPDATE 등 모두 가능하며 작업의 종류별로 활성화 여부를 제어가 가능함
- 사용 가능한 공간은 버퍼 풀로 설정된 메모리의 25%를 사용하도록 설정되어있고, 50% 까지 가능함
  - `innodb_change_buffer_max_size` 시스템 변수로 제어 가능

```sql
mysql> SELECT EVENT_NAME, CURRENT_NUMBER_OF_BYTES_USED
    -> FROM performance_schema.memory_summary_global_by_event_name
    -> WHERE EVENT_NAME='memory/innodb/ibuf0ibuf';
+-------------------------+------------------------------+
| EVENT_NAME              | CURRENT_NUMBER_OF_BYTES_USED |
+-------------------------+------------------------------+
| memory/innodb/ibuf0ibuf |                          136 |
+-------------------------+------------------------------+
1 row in set (0.01 sec)
```

<br/>

# 리두 로그 및 로그 버퍼

- 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안정장치
- 대부분 디비는 쓰기보다 읽기 성능을 고려한 자료구조를 가지고있음
  - 변경된 데이터를 파일에 기록할려면 상대적으로 큰 비용이 필요함
  - 그래서 쓰기 기록에 대해서 낮은 비용을 가진 리두 로그를 가지고있음

<br/>

### 리두 로그 관련 시스템 변수

- `innodb_flush_log_at_trx_commit`
  - 보통 1로 설정할것을 권장
  - 값 0
    - 1초에 한번씩 리두 로그를 디스크로 저장하고 동기화를 실행
    - 서버가 비정상적으로 죵료되면 1초 동안 트랜잭션은 커밋했어도 변경한 데이터 유실 가능
    - `innodb_flush_log_at_timeout`으로 동기화 시간 조정가능
  - 값 1
    - 트랜잭션이 커밋될 떄 마다 매번 디스크로 동기화까지 수행
  - 값 2
    - 트랜잭션이 커밋될때마다 디스크로 기록은 되지만 동기화는 1초에 한번 실행
    - 일단 커밋되면 변경내용이 운영체제의 메모리 버퍼로 기록되는건 보장됨
    - MySQL만 다운되면 복구가 가능하지만, 둘 다 다운되면 1초 동안 데이터는 유실 가능
    - `innodb_flush_log_at_timeout`으로 동기화 시간 조정가능

<br/>

### 로그 버퍼의 크기

- 리두 로그 파일들의 전체 크기는 버퍼 풀의 효율성을 결정하기 때문에 신중히 결정해야함
- `innodb_log_file_size`로 리두 로그 파일의 크기를 지정할 수 있음
- `innodb_log_files_in_group`로 리두 로그 파일의 개수를 지정할 수 있음
- 전체 리두 로그 파일의 크기는 위 2개의 변수의 곱이됨
- 권장값은 16MB이며, BLOB/TEXT 같은 큰 데잍를 자주 변경하면 더 크게 설정하는게 좋음

<br/>

### 리두 로그 아카이빙

- 엔터프라이즈 백업이나 Xtrabackup을 활용해서 리두 로그 아키이빙이 가능함
- 직접 폴더를 생성하고 mysql에서 `innodb_redo_log_archive_start` 사용자 정의 함수로 시작이 가능함
  - 이 때 폴더는 700 권한을 가져야함
- 도중에 중지할려면 `innodb_redo_log_archive_stop` 사용자 정의 함수를 호출하면됨
  - 이 때 진행중이던 파일이 삭제되진 않으니 직접 삭제가 필요함
- 아카이빙 도중에 세션 연결이 끊어지면 작업이 취소되고, 진행중이던 아카이빙 파일도 삭제됨

<br/>

### 리두 로그 활성화 및 비활성화

- 리두 로그는 트랜잭션 복구를 위해서 항상 활성화 되어있음
- 리두 로그의 경우는 항상 디스크로 기록됨

#### 리두 로그 비활성화

- 대용량 데이터를 적재하는 경우 시간 단축을 위해서 비활성화가 가능함
  - 무거운 작업이 끝나면 꼭 다시 활성화 해주는게 좋음
- 데이터 손실이 나도 된다면 리두 로그를 비활성화 하는것 보다, `inno_flush_log_at_trx_commit`을 0 또는 2로 설정하는게 좋음

```sql
mysql> alter instance disable innodb redo_log;
Query OK, 0 rows affected (0.00 sec)
```

<br>

# 어댑티브 해시 인덱스

- 스토리지 엔진에서 자주 요청하는 데이터에 대해서 자동으로 생성하는 인덱스
  - `innodb_adaptive_hash_index`로 ON/OFF가 가능함
- B-Tree 자료구조의 검색시간을 줄여주기 위해서 도입된 기능

<br/>

### 인덱스가 관리되는 방법

- 인덱스 키 값과 해당 인덱스 키 값이 저장된 데이터 페이지 주소(버퍼 풀에 로딩된 메모리의 주소)의 쌍으로 관리됨
- 인덱스 키 값은 B-Tree 인덱스의 고유번호와 B-Tree 인덱스의 실제 키 값 조합으로 생성됨

#### B-Tree 인덱스의 고유번호가 포함되는 이유?

- 스토리지 엔진에서 어댑티브 해시 인덱스는 하나만 존재함
- 모든 B-Tree 인덱스에 대한 어댑티브해시 인덱스가 하나의 해시 인덱스에 저장됨
- 특정 키 값이 어느 인덱스에 속한 것인지도 구분이 필요하기 떄문

<br/>

### 경합성

- 예전 버전까지는 하나의 메모리 객체인 이유로 경합성이매우 심했음
- 8 버전 부터는 어댑티브 해시 인덱스의 파티션 개수 지정이 가능해짐
- 기본값은 8이며, 어댑티브 해시 인덱스가 성능상 큰 도움이 된다면 더 많이 설정하는것도 좋음

<br/>

### 단점

- 데이터 페이지를 메모리에서 읽어올 때 도움이 되는 기능으로 실제 디스크에서 가져올때는 큰 도움이 되지 않음
- 일반 인덱스가 별도의 저장공간을 차지하는것 처럼 동일하게 메모리를 차지함
- 어댑티브 해시 인덱스가 활성화 되면 키의 유무에 상관없이 검색해봐야해서 효율이 없는 경우도 계속 해시 인덱스를 사용하게됨

<br/>

### 사용할지 어떻게 판단할까

정확한 판단이 가능한 방법은 디비 서버의 상태 값을을 보는것임

#### 사용 회수 확인

초당 3.67(1.03 + 2.64)번의 검색이 실행됬고, 1.03은 해시 인덱스를 사용함

```sql
mysql> SHOW ENGINE INNODB STATUS \G
...
Hash table size 34679, node heap has 0 buffer(s)
Hash table size 34679, node heap has 0 buffer(s)
Hash table size 34679, node heap has 0 buffer(s)
1.03 hash searches/s, 2.64 non-hash searches/s
```

#### 자원 사용율 확인

- 만약 CPU 사용율이 100% 일때 해시 인덱스가 28%를 차지한다면 효율적이라고 봄
- 하지만 CPU 사용율이 0% 인데 해시 인덱스가 28%를 차지한다면 비활성화 하는게 나음

```sql
mysql> SELECT EVENT_NAME, CURRENT_NUMBER_OF_BYTES_USED
    -> FROM performance_schema.memory_summary_global_by_event_name
    -> WHERE EVENT_NAME='memory/innodb/adaptive hash index';
+-----------------------------------+------------------------------+
| EVENT_NAME                        | CURRENT_NUMBER_OF_BYTES_USED |
+-----------------------------------+------------------------------+
| memory/innodb/adaptive hash index |                         1696 |
+-----------------------------------+------------------------------+
1 row in set (0.00 sec)
```

<br/>

# InnoDB, MyISAM, MEMORY 엔진 비교

- 8 버전을 기준으로 모든 스토리지 엔진이 InnoDB로 교체됨
- 쿼리 처리를 위해서 임시 테이블 사용시 MEMORY 엔진을 사용했으나 현재는 TempTable을 사용
  - `internal_tmp_mem_storage_engine`으로 임시 테이블에 어떤 엔진을 사용할지 설정 가능
  - 하지만 MEMORY의 경우 가변 길이 타입 컬럼 미지원으로 사용을 안하는 추세
