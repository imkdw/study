# INSERT

- INSERT 문장이 동시에 실행되는 경우 문장 자체보다는 테이블 구조가 성능에 영향을 미친다
- 대부분의 경우 INSERT + SELECT 문장의 성능을 동시에 빠르게 만들 수 있는 구조는 없다

<br/>

# 고급 옵션

### INSERT IGNORE

- 기본키나 유니크 인덱스 컬럼이 이미 테이블에 존재하는 경우
- 저장하는 레코드의 컬럼이 테이블의 컬럼과 호한되지 않는 경우
  - 만약 NOT NULL 컬럼에 NULL을 넣으면 숫자컬럼 기준 0이 들어간다
- 위 2가지 경우를 그냥 무시하고 다음 레코드를 처리할 수 있게 해준다
  - 에러를 발생시키지 않고 경고 수준의 메세지로 바꿔주고 이후 처리를 계속함
- 보통 여러개의 레코드를 하나의 INSERT 문장으로 처리하는 경우 유용함
- 중복을 무시하기 위해 사용한다면 데이터 중복 외 다른 문제 발생여부를 면밀히 확인하는걸 권장함

```sql
INSERT IGNORE INTO employees (emp_no, birth_date, first_name, last_name, gender, hire_date)
VALUES (10001, '1956-06-08', 'Margareta', 'Markovitch', 'M', '1985-01-01'),
	   (10002, '1959-10-28', 'Ebru', 'Alpin', 'M', '1985-01-01'),
	   (10003, '1953-06-24', 'Shirish', 'Ossenbruggen', 'F', '1985-01-01'),
	   (10004, '1956-06-08', 'Krassimir', 'Wegerle', 'F', '1985-01-01'),
	   (10005, '1959-10-28', 'Ebru', 'Alpin', 'M', '1985-01-01'),
	   (10006, '1953-06-24', 'Shirish', 'Ossenbruggen', 'F', '1985-01-01'),
	   (10007, '1956-06-08', 'Krassimir', 'Wegerle', 'F', '1985-01-01')
```

<br/>

### INSERT ... ON DUPLICATE KEY UPDATE

- 기본키나 유니크 인덱스 컬럼에 중복이 발생하면 UPDATE 문장의 역할을 하게 해줌
- REPLCAE 문장도 비슷한 역할을 하지만 내부적으로는 DELETE + INSERT 조합으로 작동함
- 예를 들면 일별로 집계되는 값을 관리할 때 편리하게 사용이 가능함

```sql
create table daily_statistic (
	target_date DATE NOT NULL,
	stat_name varchar(10) not null,
	stat_value bigint not null default 0,
	primary key (target_date, stat_name)
);

insert into daily_statistic (target_date, stat_name, stat_value)
	values(DATE(NOW()), 'VISIT', 1)
	ON DUPLICATE KEY UPDATE STAT_VALUE=stat_value+1;
```

<br/>

# LOAD DATA 명령 주의 사항

- 일반적으로 INSERT 보다 빠르다고 할 수 있지만 일부 단점이 존재함
- 테이블 간 복사를 하게되는 경우 해당 문장보다는 `INSERT ... SELECT` 문장으로 WHERE 절을 통해서 분할해서 추가하는걸 권장함
  - 이런 방식은 데이터를 분할해서 멀티스레드로 삽입하므로 훨씬 용이함

<br/>

### 단일 스레드

- 단일 스레드로 인해서 적재해야하는 데이터가 많다면 시간이 매우 길어질 수 있음
- 테이블에 여러 인덱스가 있다면 INSERT 되는 양이 늘어나므로 속도가 현저히 떨어짐

<br/>

### 단일 트랜잭션

- 문장이 시작한 시점부터 언두 로그가 삭제되지 못하고 계속 유지되야함
- 언두 로그를 디스크로 기록할때도 문제가 되지만, 로그가 많이 쌓이면 레코드를 읽는 쿼리들이 필요한 레코드를 찾는데 더 많은 오버헤드를 만들기도함
- 가능하면 여러 개의 파일로 준비해서 LOAD DATA 문장을 동시에 여러 트랜잭션으로 나뉘어 실행되게 하는게 좋음

<br/>

# 성능을 위한 테이블 구조

- INSERT 문장 자체는 튜닝할 수 있는 부분이 별로 없음
- 실제로 쿼리 튜닝을 할 때도 소량의 레코드를 삽입하는 문장 자체는 무시하는 경우가 많음

<br/>

### 대량 INSERT 성능

- 만약 다수의 건을 삽입한다면 미리 기본기를 기준으로 정렬해서 삽입하면 성능이 도움이 될 수 있음
- 레코드를 삽입할때마다 InnoDB 엔진은 기본키를 찾아서 레코드가 저장될 위치를 찾아야함
- 순서대로 정렬되어 있다면 매번 저장될 위치를 찾이 않아도 되서 성능이 향상될 수 있음

<br/>

#### 세컨더리 인덱스와 대량 INSERT

- 대량 삽입에 대한 성능은 기본키로 많이 결정되지만 그게 전부는 아니다
- 세컨터리 인덱스도 정렬된 순서로 있다면 마찬가지로 성능에서 이점이 존재함
- 하지만 세컨더리 인덱스에 대한 정렬여부는 보장이 힘드므로 너무 남발하는것은 좋지 않음
- 세컨더리 인덱스는 결국 SELECT 문장에서 이점이 존재하니 적절히 trade-off가 필요하다

<br/>

### 기본키 선정

- 기본키는 INSERT 성능을 결정하는 가장 중요한 부분임
- 대용량 삽입시 어느정도 까지는 B-Tree 전체가 메모리에 적재되겠지만 결국 디스크 읽기가 필요해짐
- 기본적으로 클러스터링 키 구조로 사용하기 때문에 단순히 INSERT 성능만을 위해서 사용하는건 안된다
- 대부분 OLTP 서비스는 SELECT에 대한 비율이 압도적으로 높기때문에 가능하면 단조 증가/감소 방식을 사용하자

<br/>

### Auto-Increment 컬럼

- InnoDB 엔진을 사용하는 테이블은 자동으로 기본키로 클러스터링된다
- 하지만 자동증가 컬럼을 사용하면 클러스터링되지 않는 테이블의 효과를 얻을 수 있음
- 자동증가 컬럼을 통해서 테이블을 만드는건 가장 빠른 INSERT를 보장하는 방법임
- 가장 마지막으로 증가된 컬럼을 조회할때는 MAX() 대신 LAST_INSERT_ID() 함수를 사용하는걸 권장함

```sql
-- 10
select MAX(id) from test;

-- 10
select LAST_INSERT_ID();
```
