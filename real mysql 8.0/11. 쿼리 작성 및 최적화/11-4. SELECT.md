# SELECT 절의 처리 순서

- 보통 OLTP 서비스에서는 SELECT + ORDER BY, WHERE, FROM 등 다양한 키워드를 같이 사용함
- 이 때 어느 절이 먼저 실행되는지를 모르면 처리 내용이나 결과 예측이 불가능함

### 각 쿼리의 실행 순서

> 대부분의 쿼리는 해당 순서대로 실행됨. 단 윈도우 함수 및 CTE는 예외임

- 드라이븐/드리븐 테이블을 조인 및 WHERE 조건 적용
- GROUP BY를 통한 그룹핑
- DISTINCT가 있다면 중복 제거
- HAVING 조건을 통한 필터링
- ORDER BY를 통한 정렬
- LIMIT 조건을 통한 레코드 수 제한

<br/>

### ORDER BY가 조인보다 먼저 실행되는 경우 쿼리 실행 순서

> 주로 GROUP BY 없이 ORDER BY만 사용된 쿼리에서 사용하는 순서

- 드라이빙 테이블에서 WHERE 조건을 통한 필터링
- ORDER BY를 통한 정렬
- 드리븐 테이블들을 조인
- LIMIT 조건을 통한 레코드 수 제한

<br/>

### 작업 순서 커스터마이징?

- 위 소개된 순서 이외에 직접 커스터마이징을 할려면 서브쿼리로 작성된 인라인 뷰를 사용해야함
- 하지만 DERIVED 처럼 임시 테이블이 생성되므로 주의해야함
  - 또한 WITH절(CTE)의 경우도 제일 먼저 실행되서 임시 테이블로 저장됨

```sql
select emp_no, cnt
from (
	select s.emp_no, COUNT(DISTINCT e.first_name) as cnt, MAX(s.salary) AS max_salary
	from salaries s
		inner join employees e ON e.emp_no = s.emp_no
	where s.emp_no IN (100001, 100002)
	group by s.emp_no
	HAVING MAX(s.salary) > 1000
	LIMIT 10
) inline_view
order by max_salary asc;
```

| id  | select_type | table      | partitions | type   | possible_keys     | key     | key_len | ref                | rows | filtered | Extra          |
| --- | ----------- | ---------- | ---------- | ------ | ----------------- | ------- | ------- | ------------------ | ---- | -------- | -------------- |
| 1   | PRIMARY     | <derived2> |            | ALL    |                   |         |         |                    | 10   | 100.0    | Using filesort |
| 2   | DERIVED     | s          |            | range  | PRIMARY,ix_salary | PRIMARY | 4       |                    | 19   | 100.0    | Using where    |
| 2   | DERIVED     | e          |            | eq_ref | PRIMARY           | PRIMARY | 4       | realmysql.s.emp_no | 1    | 100.0    |                |

<br/>

### MySQL의 LIMIT 동작방식

- LIMIT은 WHERE 조건이 아닌 모든 처리결과에 대해서 레코드 건수를 제한하는 형태로 사용됨
- 그래서 항상 마지막에 쿼리 결과에 대한 레코드의 수를 제한하기 위해서 실행됨

<br/>

# WHERE, GROUP BY, ORDER BY 인덱스 사용

### 인덱스를 사용하기 위한 기본 규칙

- 기본적으로 인덱스된 컬럼의 값 자체를 변환하지 않고 그대로 사용한다는 조건을 만족해야함
- 특정 컬럼을 가공한 후 다른 상수랑 비교하게되면 생성된 인덱스를 활용할 수 없음
- 만약 md5() 또는 복잡한 연산을 해야하면 미리 가상컬럼을 통해서 인덱스를 생성하거나 함수기반 인덱스 사용을 추천함
- WHERE 절의 경우 상수값과 비교조건의 컬럼의 자료형이 일치해야함

<br/>

### WHERE의 인덱스 사용

- 인덱스를 사용하는 방법은 크게 작업 범위 결정 조건, 체크 조건 두 가지로 구분이 가능함

<br/>

#### 작업 범위 결정 조건

- 동등 비교 조건이나 IN으로 구성된 조건에 사용된 컬럼이 인덱스의 컬럼 구성과 좌측에서 부터 비교했을때 얼만 일치하냐에 따라 달라짐
- AND 조건
  - AND 조건의 경우 나열된 순서에 상관없이 옵티마이저가 최적화가 가능한 실행계획을 만들어줌
- OR 조건
  - 만약 조건중 1개라도 인덱스가 없다면 풀 테이블 스캔을 수행하게됨
  - 인덱스가 있다면 index_merge 방법으로 수행이 가능함
  - WHERE에 OR 조건이 있다면 항상 주의하는게 좋음

<br/>

### GROUP BY의 인덱스 사용

- 일단 GROUP BY에 명시된 컬럼의 순서가 인덱스를 구성하는 순서와 같으면 사용이 가능함
- 뒤쪽에 있는 컬럼은 명시가 안되도 사용이 가능하지만, 인덱스의 앞쪽에 있는 컬럼이 명시되지 않으면 사용못함
- GROUP BY 절에 명시된 컬럼이 하나라도 인덱스와 없다면 WHERE와는 다르게 인덱스 사용이 불가능함

<br/>

#### 불가능한 예시

```sql
... GROUP BY COL_2, COL_1
... GROUP BY COL_1, COL_3
... etc
```

<br/>

#### 가능한 예시

```sql
... GROUP BY COL_1, COL_2
... GROUP BY COL_1, COL_2, COL_3
... etc
```

<br/>

#### WHERE + GROUP BY 혼용할때 인덱스 사용여부

- 아래 두개는 공통적으로 COL_1이 상수와 비교되므로 인덱스를 사용함
- 결국 GROUP BY에 명시된 컬럼과 상관없이 동일한 결과를 만들어냄
- 이처럼 GROUP BY절을 수정해도 결과가 같다면 WHERE, GROUP BY 모두 인덱스를 사용한다고 판단함

```sql
... WHERE COL_1='const' ... GROUP BY COL_2, COL_3
... WHERE COL_1='const' ... GROUP BY COL_1, COL_2, COL_3
```

<br/>

### ORDER BY의 인덱스 사용

- GROUP BY의 조건과 거의 흡사하지만 한가지 조건이 더 존재함
- 정렬되는 각 컬럼이 ASC 및 DESC 옵션이 인덱스랑 같거나 정반대인 경우만 사용이 가능함
- MySQL 인덱스의 경우 모두 ASC로 정렬되서 저장됨
- 즉 ORDER BY의 모든 정렬이 다 ASC 이거나 DESC 이여야 인덱스 사용이 가능함

<br/>

#### 불가능한 경우

```sql
... ORDER BY COL_2, COL_3
... ORDER BY COL_1, COL_3, COL_2
... ORDER BY COL_1, COL_2 DESC, COL_3
... etc
```

<br/>

### WHERE + ORDER BY or GROUP BY 인덱스 사용

- 아래 3가지 방법중 한가지 방법으로만 인덱스를 사용
  - WHERE + ORDER BY가 동일한 인덱스 사용
    - 조건과 정렬의 대상이 하나의 인덱스에 연속해서 포함됨
    - 가능하다면 해당 방식으로 처리되도록 튜닝이나 인덱스 생성을 권장
  - WHERE만 사용
    - 인덱스를 사용해서 정렬이 불가능하면 소트버퍼(Filesort)로 처리함
    - WHERE에서 일치하는 레코드가 많지 않을때 효율적인 방법
  - ORDER BY만 사용
    - ORDER BY 순서대로 인덱스를 읽으면서 레코드 한건씩 일치여부에 따라서 가져오거나 버림
    - 아주 많은 레코드를 조회해서 정렬해야되는 경우 이런 방법을 쓰기도 함
    - 하지만 디스크에 랜덤I/O를 많이 일으킬 수 있음

<br/>

#### WHERE의 조건절에서 범위 조건의 비교가 사용되는 예시

- WHERE, ORDER BY에 명시된 컬럼 순서가 일치하지 않거나 없는 컬럼이 있다면 인덱스를 활용하여 전부 처리가 불가능함

```sql
-- 인덱스를 활용한 WHERE, ORDER BY 모두 처리
select * from test where coL_1 > 10 order by col_1, col_2, col_3

-- WHERE에만 인덱스가 사용되고, ORDER BY는 별도로 처리
select * from test where coL_1 > 10 order by col_2, col_3
```

<br/>

### GROUP BY + ORDER BY 인덱스 사용

- 모두 하나의 인덱스를 통해서 처리할려면 앙쬭에 명시된 컬럼값과 순서가 동일해야함
- 만약 둘중 하나라도 인덱스 사용이 불가능하면 둘 다 인덱스를 아에 못쓴다
- 8 버전 부터는 GROUP BY를 자동으로 정렬하지 않으니 그루핑, 정렬을 다 할려면 두곳다 명시해야함

<br/>

### WHERE + ORDER BY + GROUP BY 인덱스 사용

> 아래 조건이 모두 만족되야 인덱스 사용이 가능함

- WHERE 절이 인덱스 사용이 가능한가?
- GROUP BY 절이 인덱스 사용이 가능한가?
- GROUP BY + ORDER BY 절이 동시에 인덱스 사용이 가능한가?

<br/>

# WHERE 비교 조건 사용 시 주의사항

쿼리가 최적으로 실행될려면 적합한 인덱스 + WHERE 절 비교 조건의 표현식을 적절하게 사용하는게 중요함

### NULL 비교

- MySQL은 NULLABLE 컬럼도 인덱스로 관리됨
- 쿼리에서 NULL 비교를 위해서는 `IS NULL`, `ISNULL()`, `<=>` 연산자를 사용해야함
- 그 외의 경우는 인덱스 사용이 불가능하므로 가능하면 `IS NULL` 사용을 권장함

```sql
-- 인덱스 사용 가능
select * from titles t where to_date IS NULL;
select * from titles t where ISNULL(t.to_date);

-- 인덱스 사용 불가능
select * from titles t where ISNULL(to_date)=1;
select * from titles t where ISNULL(to_date)=true;
```

<br/>

### 문자열이나 숫자 비교

- 문자 또는 숫자 컬럼을 비교할때는 그 타입에 맞는 상수값 사용을 권장함
- 숫자 컬럼에 문자열 상수를 비교하면 문자열 상수를 숫자로 치환하고 비교해서 큰 영향은 없음
- 문자열 컬럼에 숫자를 비교하면 사전에 비교대상 컬럼을 모두 숫자로 변환하니 성능에 영향이 있음

<br/>

### 날짜 비교

#### DATE or DATETIME + 문자열

- 기본적으로 MySQL이 내부적으로 문자열을 자동으로 DATETIME 값으로 변환해서 비교를 수행함
- STR_TO_DATE()도 사용이 가능하고, 이러한 방식은 모두 인덱스를 사용하므로 걱정하지 않아도 됨
- 하지만 기존 날짜타입을 문자열로 변환하거나 기타 연산을 하면 인덱스 사용이 불가능함
- 가능하면 DATE, DATETIME 컬럼을 변경하지 말고 상수를 변경하는 형태로 조건을 쓰는게 좋음

<br/>

#### DATE + DATETIME 비교

- 단순하게 `date_col > DATE(NOW())` 형식으로 사용하면 된다
- 인덱스 사용여부에 영향이 없으므로 쿼리 결과에 주의하면 된다

<br/>

#### DATETIME + TIMESTAMP 비교

- 컬럼이 DATETIIME이면 `FROM_UNIXTIME(col)`로 TIMESTAMP를 DATETIME으로 변환해서 비교
- 컬럼이 TIMESTAMP이면 `UNIX_TIMESTAMP(col)`로 DATETIME를 TIMESTAMP으로 변환해서 비교
- 그 외에도 NOW() 함수를 사용하는 방법도 존재함

<br/>

### Short-Circuit Evaluation

- 여러개의 표현식이 AND, OR 논리식으로 연결된 경우, 선행 조건에 따라서 후행 조건을 평가할지 결정하는 최적화
  - `if (A AND B) THEN SOMETHING`
- MySQL은 해당 방식으로 최적화를 처리할지 말지 결정함
- 하지만 만약 WHERE 조건에 인덱스를 사용하는 조건이 있다면 해당 조건이 최우선으로 평가됨
- 또한 서브쿼리나 복잡한 연산 등 작업은 WHERE 절의 뒤쪽으로 배치하는게 성능상 도움이 됨

<br/>

# DISTINCT

- 특정 컬럼의 유니크한 값을 조회할려면 SELECT에 DISTINCT 키워드를 붙이면 됨
- 하지만 남발하는건 성능상에 문제도 있지만 쿼리의 결과도 의돠한대로 안나올수도 있음
- 추후 상세하게 정의예정

<br/>

# LIMIT n

- 처리된 쿼리 결과에서 지정된 순서에 위치한 레코드만 가져오고자 할 때 사용함
- WHERE 조건이 아니라서 항상 쿼리의 맨 마지막에 실행됨
- 쿼리에서 모든 레코드의 정렬이 안료되지 않았더라도 상위 N건만 정렬되면 작업을 멈춤
  - 특정 경우에는 성능이 향상될수도 있음
- 가장 중요한건 실제 보여지는 결과가 아닌 해당 결과를 만들기 위해서 어떤 작업을 했는지가 중요함
- LIMIT (N, M) 인자에는 함수나 서브쿼리 등 대입이 불가능함

<br/>

### 다른 문법과 같이 사용된 예시들

#### 단순 LIMIT

- 우선 풀 테이블 스캔이 시작됨
- LIMIT에 의해서 스토리지 엔진으로 부터 10개의 레코드를 읽어내는 순간 작업은 종료됨

```sql
select * from employees e  LIMIT 0, 10;
```

<br/>

#### GROUP BY와 함께 사용

- GROUP BY가 있다면 해당 쿼리가 끝나고나서야 LIMIT 처리가 가능함
- 실질적으로 서버에서 처리하는 작업을 많이 줄여주진 못함

```sql
select first_name from employees e group by first_name limit 0, 10;
```

<br/>

#### DISTINCT와 함께 사용

- 풀스캔을 통해서 중복이 없는 레코드들을 만든다
- 만들면서 데이터가 LIMIT에 걸린다면 그 즉시 작업이 종료된다
- 이 경우 레코드의 중복값 분포도에 따라서 작업량을 많이 줄여줄 수 있음

```sql
select DISTINCT first_name from employees e limit 0, 10
```

<br/>

#### WHERE + ORDER BY + LIMIT

- WHERE 조건으로 해당하는 레코드를 읽고나서 정렬을 수행함
- 정렬을 하는 도중에 10건이 정렬이 완료되면 더 이상 작업을 하지 않고 반환함
- 사실상 레코드에 접근하는게 더 비용이 커서 2번 처럼 크게 성능향상은 없음

```sql
select * from employees e
where emp_no BETWEEN 10001 AND 11000
ORDER BY first_name
LIMIT 0, 10
```

<br/>

### 성능상의 이슈

- `LIMIT 200000, 10`을 하게되면 200,010개의 레코드를 먼저 읽는다
- 그러고 나서 20만건의 레코드는 버리고 맨 뒤의 10건만 사용자에게 반환한다
- 결국 레코드를 읽는건 똑같으므로 쿼리의 처리속도가 느려진다

<br/>

#### 해결방법

- WHERE 조건을 통해서 데이터를 제한하여 읽고나서 필요한 만큼만 반환하는게 좋다

```sql
-- 처음 페이지 읽기
select * from salaries order by salary limit 0, 10

-- 두번째 페이지 읽기
select * from salaries
where salary >= 10000 AND NOT (salary=33864)
order by salary limit 0, 10
```

<br/>

# COUNT()

- 쿼리 결과의 레코드를 반환하는 함수
- `COUNT(*)`에서 `*`은 모든 컬럼을 의미하는게 아니라 그냥 레코드 자체를 의미함
- InnoDB의 경우 직접 데이터나 인덱스를 읽어야 계산이 가능하니 대용량 테이블에서는 주의해야함
  - 대용량 테이블에서는 `SHOW TABLE STATUS + ANALYZE TABLE` 명령으로 확인하는걸 권장한다

### 많이 저지르는 실수

- 대표적인 실수는 ORDER BY로 정렬을 하거나, LEFT JOIN 같은 레코드 건수와 무관한 작업을 하는것임
- 레코드의 개수를 세는데 정렬은 아무런 상관이 없다
- 마찬가지로 LEFT JOIN도 레코드 건수에 변화가 없거나, 아우터 테이블에서 별도로 체크를 하지 않아도 된다면 제거하자
- 8 버전 부터는 COUNT(\*) 쿼리에 사용된 ORDER BY는 무시하도록 개선됬다
  - 하지만 쿼리의 복잡도를 낮추고 가독성을 높이기 위해선 필요한 문장만 작성하는게 좋다

<br/>

### COUNT와 인덱스

- 인덱스가 제대로 사용하도록 튜닝되지 모한 쿼리는 페이징해서 데이터를 가져오는 쿼리보다 더 느릴수 있다
- `COUNT(\*)` 쿼리도 상당한 부하를 일으키므로 주의해야함

<br/>

### COUNT와 NULL

- 인자로 컬럼명이나 표현식이 사용되면 해당 레코드가 NULL이 아닌것만 카운팅된다
- NULLABLE 컬럼의 경우 쿼리 결과가 의도한것과 일치하는지 검사를 해봐야한다

<br/>

# JOIN

### JOIN의 순서와 인덱스

- 인덱스 레인지 스캔은 탐색(Seek)과 스캔(Scan)하는 과정으로 구분이 가능함
- 보통 인덱스를 통해 가져오는 레코드가 적은편이라 스캔은 부하가 적지만, 탐색은 상대적으로 부하가 높음
- 또한 드리븐 테이블에서 레코드를 읽는건 훨신 큰 부하가 발생하므로 옵티마이저는 최적의 계획을 수립해줌

<br/>

```sql
select *
from employees e, dept_emp de
where e.emp_no = de.emp_no
```

#### 드라이빙, 드리븐 모두 인덱스가 있는경우

- 레코드 건수에 따라서 2개 모두 드라이빙이 될 수 있음
- 이런 경우 옵티마이저가 골라주는 방법이 최적일 때가 많음

<br/>

#### employees.emp_no에만 인덱스가 있을때

- 만약 employees가 드라이빙이 된다면 레코드마다 dept_emp를 풀스캔해야함
- 이런 경우는 employees에 효율적인 접근 방법이 있더라도 dept_emp를 드라이빙으로 지정할 확률이 높음

<br/>

#### dept_emp.emp_no에만 인덱스가 있을때

- 위와 반대로 employees가 드라이빙으로 지정할 확률이 높음

<br/>

#### 두 컬럼 모두 인덱스가 없는 경우

- 결국 테이블 풀 스캔은 항상 발생하게 되므로 레코드 건수가 적은 테이블을 드라이빙 테이블로 선택하는게 효율적임

<br/>

### JOIN 컬럼의 데이터 타입

- 비교 조건에서 양쪽 항이 상수든 테이블의 컬럼이든 관계없이 인덱스를 사용하기 위해선 데이터 타입을 일치시켜야함
- 또한 서로 다른 문자 집합과 콜레이션으로 생성이 된 경우도 풀스캔을 해야할 확률이 높으니 주의해야함
  - 이런 경우는 서로 통일하는것이 유일한 해결책임
  - 각 컬럼에 저장되는 타입에 맞게 타입을 선정하고, 최종적으로 점검하는것이 좋음

<br/>

### OUTER JOIN의 성능과 주의사항

- 아우터 조인은 서로 데이터가 일관되지 않은 경우에만 필요한 방법임
- 옵티마이저는 절대 아우터로 조인되는 테이블을 드라이빙으로 선택하지 못하기 때문에 풀 스캔이 필요한 테이블을 드라이빙 테이블로 선택함
- 이너 조인으로도 충분한 테이블을 아우터 조인 방식으로 쿼리를 작성화면 최적화의 기회를 뺏어버리는것임

<br/>

#### LEFT JOIN만 사용하는 경우

- employees 테이블을 풀스캔 하면서 dept_emp, departments 테이블을 드리븐 테이블로 선택함

```sql
explain
select *
from employees e
left join dept_emp de on de.emp_no = e.emp_no
left join departments d on d.dept_no = de.dept_no and d.dept_name = 'Development';
```

| id  | select_type | table | partitions | type   | possible_keys       | key               | key_len | ref                  | rows   | filtered | Extra       |
| --- | ----------- | ----- | ---------- | ------ | ------------------- | ----------------- | ------- | -------------------- | ------ | -------- | ----------- |
| 1   | SIMPLE      | e     |            | ALL    |                     |                   |         |                      | 300252 | 100.0    |             |
| 1   | SIMPLE      | de    |            | ref    | ix_empno_fromdate   | ix_empno_fromdate | 4       | realmysql.e.emp_no   | 1      | 100.0    |             |
| 1   | SIMPLE      | d     |            | eq_ref | PRIMARY,ux_deptname | PRIMARY           | 16      | realmysql.de.dept_no | 1      | 100.0    | Using where |

<br/>

#### INNER JOIN으로 최적화

- 최적화를 하고나니 departments.dept_name이 Development인 컬럼을 찾아서 조인을 실행한다

```sql
explain
select *
from employees e
inner join dept_emp de on de.emp_no = e.emp_no
inner join departments d on d.dept_no = de.dept_no and d.dept_name = 'Development';
```

| id  | select_type | table | partitions | type   | possible_keys             | key         | key_len | ref                 | rows  | filtered | Extra |
| --- | ----------- | ----- | ---------- | ------ | ------------------------- | ----------- | ------- | ------------------- | ----- | -------- | ----- |
| 1   | SIMPLE      | d     |            | ref    | PRIMARY,ux_deptname       | ux_deptname | 162     | const               | 1     | 100.0    |       |
| 1   | SIMPLE      | de    |            | ref    | PRIMARY,ix_empno_fromdate | PRIMARY     | 16      | realmysql.d.dept_no | 41392 | 100.0    |       |
| 1   | SIMPLE      | e     |            | eq_ref | PRIMARY                   | PRIMARY     | 4       | realmysql.de.emp_no | 1     | 100.0    |       |

<br/>

#### OUTER JOIN에서 자주 하는 실수

- 아우터로 조인되는 테이블에 대한 조건은 WHERE 절에 작성하는 실수다
- 이런 경우 옵티마이저는 LEFT JOIN을 INNER JOIN로 변환하여 실행하게 됨
- 정상적인 OUTER JOIN이라면 ON 조건의 옆으로 옮겨야한다

**before**

```sql
explain
select *
from employees e
left join dept_manager mgr on mgr.emp_no = e.emp_no
where mgr.dept_no = 'd001';
```

**after**

```sql
explain
select *
from employees e
left join dept_manager mgr on mgr.emp_no = e.emp_no and mgr.dept_no = 'd001';
```

<br/>

### JOIN과 외래키(Foreign Key)

- 외래키와 조인은 아무런 연관이 없고, 외래키는 참조무결성을 위한 수단이다
- 일반적으로 데이터 모델링시는 관계를 그리지만, 실제 테이블 생성시는 안넣을때도 많다

<br/>

### 지연된 조인(Delayed Join)

- 조인이 실행되기 전에 GROUP BY, ORDER BY를 처리하는 방식이다
- 인덱스를 사용하지 못하는 방식의 쿼리가 필요할 때 사용하면 좋다

<br/>

#### 기존 방법

- employees 테이블을 드라이빙 테이블로 선택해서 조건을 만족하는 레코드를 찾고 salaries 테이블과 조인함
- 이후에 조인된 결과를 임시 테이블에 저장하고 GROUP BY로 그룹핑
- ORDER BY를 통해 정렬하면서 상위 10건만 최종적으로 반환함

```sql
explain
select e.*
from salaries s , employees e
where e.emp_no = s.emp_no
	and s.emp_no BETWEEN 10001 AND 13000
GROUP BY s.emp_no
ORDER BY SUM(s.salary) DESC
LIMIT 10;
```

| id  | select_type | table | partitions | type  | possible_keys     | key     | key_len | ref                | rows | filtered | Extra                                        |
| --- | ----------- | ----- | ---------- | ----- | ----------------- | ------- | ------- | ------------------ | ---- | -------- | -------------------------------------------- |
| 1   | SIMPLE      | e     |            | range | PRIMARY           | PRIMARY | 4       |                    | 2999 | 100.0    | Using where; Using temporary; Using filesort |
| 1   | SIMPLE      | s     |            | ref   | PRIMARY,ix_salary | PRIMARY | 4       | realmysql.e.emp_no | 9    | 100.0    |                                              |

<br/>

#### 지연된 조인 사용

- 예상한대로 FROM 절의 서브쿼리가 임시 테이블로 처리됨
- 지연된 조인으로 변경된 이 쿼리는 임시테이블에 저장하고 GROUP BY를 통해서 레코드를 줄인다

```sql
explain
select *
from (
	select s.emp_no
	from salaries s
	where s.emp_no BETWEEN 10001 AND 13000
	GROUP BY s.emp_no
	ORDER BY SUM(s.salary)
	LIMIT 10
) x,
employees e
where e.emp_no = x.emp_no;
```

| id  | select_type | table      | partitions | type   | possible_keys     | key     | key_len | ref      | rows  | filtered | Extra                                        |
| --- | ----------- | ---------- | ---------- | ------ | ----------------- | ------- | ------- | -------- | ----- | -------- | -------------------------------------------- |
| 1   | PRIMARY     | <derived2> |            | ALL    |                   |         |         |          | 10    | 100.0    |                                              |
| 1   | PRIMARY     | e          |            | eq_ref | PRIMARY           | PRIMARY | 4       | x.emp_no | 1     | 100.0    |                                              |
| 2   | DERIVED     | s          |            | range  | PRIMARY,ix_salary | PRIMARY | 4       |          | 56844 | 100.0    | Using where; Using temporary; Using filesort |

<br/>

#### 지연된 조인이 사용가능한 조건

- LEFT(OUTER) JOIN의 경우 드라이빙, 드리븐 테이블이 1:1 or M:1 관계여야함
- 드라이빙 테이블에 있는 레코드는 드리븐 테이블에 모두 존재해야함
- 이 때 반드시 데이터 정합성이 일치한다는 조건이므로 꼭 확인후에 적용해야함

<br/>

### 레터럴 조인(Lateral Join)

- 특정 그룹별로 서브쿼리를 실행해서 해당 결과와 조인이 가능한 기능
- FROM 절에 사용된 서브쿼리가 외부 쿼리의 컬럼을 참조하기 위해서는 LATERAL이 명시되어 있어야함
- 하지만 LATERAL 키워드를 가진 서브쿼리는 조인 순서상 후순위로 밀리고, 외부 쿼리의 결과값 단위로 임시 테이블이 생성되므로 꼭 필요한 경우만 써야함

```sql
explain
select *
from employees e
left join lateral (
	select *
	from salaries s
	where s.emp_no = e.emp_no
	order by s.from_date DESC
	limit 2
) s2 on s2.emp_no = e.emp_no
where e.first_name="Matt";
```

| id  | select_type       | table      | partitions | type | possible_keys | key          | key_len | ref                | rows | filtered | Extra                      |
| --- | ----------------- | ---------- | ---------- | ---- | ------------- | ------------ | ------- | ------------------ | ---- | -------- | -------------------------- |
| 1   | PRIMARY           | e          |            | ref  | ix_firstname  | ix_firstname | 58      | const              | 233  | 100.0    | Rematerialize (<derived2>) |
| 1   | PRIMARY           | <derived2> |            | ref  | <auto_key0>   | <auto_key0>  | 4       | realmysql.e.emp_no | 2    | 100.0    |                            |
| 2   | DEPENDENT DERIVED | s          |            | ref  | PRIMARY       | PRIMARY      | 4       | realmysql.e.emp_no | 9    | 100.0    | Using filesort             |

<br/>

### 실행 계획으로 인한 정렬 흐트러짐

- 네스티드 루프의 경우 드라이빙 테이블에서 읽은 레코드의 순사가 다른 테이블이 모두 조인되도 그대로 유지됨
- 이건 주어진 조건에 의해서 드라이빙 테이블을 인덱스 스캔 또는 풀스캔을 하고, 그 때 읽은 순서대로 최정 결과에 반영되기 때문임
- 만약 해시조인이 사용되면 쿼리 결과의 레코드 순서가 달라짐
- 만약 정렬된 결과가 필요한 경우라면 드라이빙 테이블순서에 의존하지 말고 ORDER BY를 명시하는걸 권장함

<br/>

# GROUP BY
