# 복제 데이터 포맷

- Statement 형식과 Row 형식 총 2가지를 지원한다
- 두가지 종류중 하나로 설정하거나 섞어 쓰는 방식으로 사용이 가능하다

<br>

# Statement 형식

- 변경 이벤트에 대해서 이벤트를 발생시킨 SQL 자체를 저장하는 형식
- 하나의 sql이 여러개의 데이터를 변경할수도 있는데 이래도 실제로는 1개의 sql만 저장됨
- 변경 내역이 대부분 저장되는 파일이라 감사 등의 목적으로도 활용할 수 있음
- 단점은 비확정적으로 처리될 수 있는 쿼리의 경우는 복제에 있어서 일관성이 깨질수도 있음
  - DELETE/UPDATE 쿼리에서 order by 없이 limit 사용
  - 함수를 사용하는 쿼리
  - ...
- 또 다른 단점은 row로 복제될 때 보다 데이터에 락은 더 많이 걸게됨
- 제한사항으로는 트랜잭션 격리 수준이 `repeatable-read` 이상이어야 한다는 점임

<br>

# Row 형식

- 변경된 값 그 자체가 바이너리 로그에 저장되는 형식
- 복제시에 소스와 레플리카 간 데이터 일관성을 지킬수 있는 가장 안전한 방식
- 함수의 경우도 최종적으로 변경된 데이터를 기록하므로 바이너리 로그에 저장이 가능함
- Statement 방식에 비해서 데이터에 락이 최소화 되어서 처리됨
  - 쿼리가 실행되는게 아닌 변경된 데이터가 바로 적용되서 어떤 이벤트건 더 적은 락을 점유함
- 모든 트랜잭션 격리 수준에서 사용이 가능함
- 하지만 사용자 계정 생성, 권한 부여/회수 등 DDL은 전부 Statement 형태로 저장됨

<br>

# Mixed 형식

- 기본적으로는 Statement 형식을 사용하지만 자체 판단에 의해서 Row 형식으로 변경해서 저장도 가능함
- 만약 Statement로 저장시 일관성이 보장되지 않는 쿼리는 자동으로 Row 형식으로 변경함
- 만능은 아니고 사용하는 쿼리 형태에 제일 적합한 형태를 사용하는게 좋음

<br>

# Row 포맷의 용량 최적화

- Row를 쓰게되면 제일 망설이는 부분은 Statement에 비해서 더 많은 저장공간은 차지한다는 점이다
- MySQL에서는 이러한 저장공간 최적화를 위해서 2가지 방법을 제공해준다

<br>

### 바이너리 로그 Row 이미지

- Row 포맷의 바이너리 로그 파일 용량을 최소화하기 위해서 저장되는 변경 데이터의 컬럼 구성을 제어하는 `binlog_row_image`라는 시스템변수를 제공해줌
- Row 포맷은 변경 전/후 레코드가 같이 저장되는데 위 시스템 변수는 각 변경 전후 레코드들에 대해 어떤 컬럼을 기록할건지 결정함
- 총 3개의 옵션이 존재하고 기본값은 `full`임

<br>

#### full

- 모든 컬럼들의 값을 바이너리 로그에 저장하는 방식

<br>

#### minimal

- 변경 데이터에 대해서 꼭 필요한 컬럼만 바이너리 로그에 저장
- 아래 표에서 `PKE`는 기본키 또는 기본키 역할을 하는 컬럼 조합을 의미함

| 이벤트 | 변경 전 레코드 | 변경 후 레코드                                                         |
| ------ | -------------- | ---------------------------------------------------------------------- |
| INSERT | X              | INSERT시 값이 명시됬던 컬럼, auto_increment 컬럼이 있다면 그 값도 저장 |
| UPDATE | `PKE`          | UPDATE시 값이 명시됬던 모든 컬럼                                       |
| DELETE | `PKE`          | X                                                                      |

<br>

#### noblob

- full 처럼 작동하지만 blob, text 컬럼에 대해서 변경이 발생하지 않으면 해당 컬럼은 기록하지 않음

<br>

### 바이너리 로그 트랜잭션 압축

- 안정적인 복제를 위해 일정 기간동안은 보관하고, 시점복구를 위해서 외부 스토리지에 저장하기도함
- 하지만 많은 디스크 용량과 네트워크 대역폭을 차지하게됨
- 8.20 버전 이후로는 이러한 트랜잭션에서 변경한 데이터를 압축해서 기록할 수 있도록 지원함
  - 데이터는 zstd 알고리즘으로 압축, `Transaction_payload_event`라는 하나의 이벤트로 기록됨
  - 쿼리에 따라 다르겠지만 약 50만건의 데이터를 저장하는 경우 50% 정도 압축되었음
- 압축된 트랜잭션은 복제될때도 상태를 유지학, 레플리케이션 I/O 스레드도 그대로 릴레이 로그에 기록함
- `binlog_transaction_compression`으로 압축여부를 제어하고, `binlog_transaction_compression_level`로 압축률을 제어함
  - 압축 레벨의 경우 기본값인 3으로 사용해도 별 문제가 없을듯함
- 일부 상황에서는 압축지 지원되지 않으며, 실제 내용 확인을 위해서 압축이 해제되기도함
