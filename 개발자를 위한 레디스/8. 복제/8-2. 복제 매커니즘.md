# 복제 매커니즘 - 로컬 디스크 사용

- 복제 노드에서 REPLICAOF 명령어로 복제를 시도
- 마스터 노드에서 fork로 자식 프로세스를 만들고, RDB 스냅샷을 생성
- 위 과정동안 데이터 변경 작업은 RESP 형태로 마스터 노드의 복제 버퍼에 저장
- RDB 생성이 완료되면 복제 노드로 복사되고, RDB 파일을 통해서 데이터를 로딩
- 복제 과정동안 버퍼에 저장됬던 데이터를 복제본으로 전달해서 수행시킴

### 최대 복제 작업의 수

- 복제 작업은 한번에 한개만 실행이 가능함, 다른 복제는 큐에서 대기함
- repl-diskless-sync-delay 옵션
  - 해당 옵션을 활성화하면 새로운 복제본과의 연결은 위 설정초만큼 기다렸다가 한다는 뜻이다
  - 보통 네트워크 문제로 재동기화를 요청하면 마스터에는 한번에 여러개의 복제본에서 복제 연결이 들어오는게 일반적으로 위 옵션을 키는것을 권장함

<br/>

# 복제 매커니즘 - 원격 디스크 사용

- 복제 노드에서 REPLICAOF 명령어로 복제를 시도
- 마스터에서 복제본으로 소켓을 통해 직접 연결, RDB 파일은 생성되면서 복제본의 소켓으로 전송
- 위 과정동안 데이터 변경 작업은 RESP 형태로 마스터 노드의 복제 버퍼에 저장
- 소켓에서 읽어온 RDB 파일을 디스크에 저장
- 그 외 동일
- 디스크 I/O 보다 네트워크가 더 빠른경우 사용할수 있는 방법임

<br/>

# 비동기 방식으로 동작하는 복제 연결

- 정상적으로 연결이 됬다는 가정하메 마스터 -> 복제본 데이터 전달은 비동기로 작동함
- 만약 마스터 노드 장애로 인해서 백업으로 전달되지 않으면 데이터 유실이 발생함
  - 전달되는 속도는 매우 빠르므로 이런 현상은 빈번하게 발생하지 않음

<br/>

# 복제 아이디

- 복제 기능을 사용하지 않는 인스턴스를 포함 모든 인스턴스는 복제 아이디를 가지고있음
- `INFO REPLICATION` 명령어로 복제와 관련된 설정 확인이 가능함

<br/>

# 부분 재동기화

- 네트워크가 불안정하고 복제 연결이 끊길때마다 RDB를 새로 받으면 성능이 나빠질것임
- 위 현상을 방지하기 위해서 부분 재동기화를 제공함
- 마스터는 커넥션 유실을 대비해서 백로그 버퍼라는 공간에 복제본에 전달할 데이터를 저장해둠
- 복제본에선 PSYNC 명령어로 자신의 replication id랑 offset을 마스터로 전달함
  - 이 과정에서 모든 데이터를 다시 복제하는게 아닌 차이나는 offset만 백로그 버퍼에서 전달받음
- 백로그 버퍼에 원하는 데이터가 없거나 replication id가 다르면 전체 재동기화를 실행함
- 백로그 크기는 기본 1MB이며, repl-backlog-size로 조정이 가능함

<br/>

# Secondary 복제 ID

- 기존 마스터 노드가 다운되어 하위 복제본 노드의 마스터가 바뀐다고 가정
- B -> A, C -> A 구조에서 세컨더리 복제 ID를 등록해두면 C -> B 구조로 복제됨
- 또한 동일한 replicatio id를 갖는다면 C는 B노드에 대해서 부분 재동기화를 실행함
- 전체 재동기화를 안해도 되서 불필요 작업을 줄일 수 있음
- 결국 secondary replication id는 복제본의 페일오버 이후 마스터 노드로 승격되는 복제본 때문임

<br/>

# 읽기 전용 모드로 동작하는 복제본 노드

- 기본적으로 복제본 노드는 읽기 전용 모드로 동작하며 SET 명령어 사용이 불가능함
- replica-read-only 옵션으로 제어가 가능하지만, 복제본 -> 마스터의 데이터 전달이 없어서 권장하지 않음

<br/>

# 유효하지 않은 복제본 데이터

- 유효하지 않은 데이터란 마스터와 복제본 데이터가 정확하게 일치하지 않는 경우을 뜻함
- 데이터가 불일치할때는 에러가 발생하며, `replica-serve-stale-data` 옵션으로 그냥 데이터를 줄수도 있음

<br/>

# 백업을 사용하지 않는 경우에서의 복제

- 복제를 사용하는 경우 마스터, 복제본 모두 백업기능을 사용하는게 좋음
- 만약 사용하지 않으려면 재부팅 후 레디스가 자동으로 시작되지 않게 설정할것을 권장
- 마스터가 재부팅되서 다시 시작하면 복제본은 빈 데이터를 그대로 가져올것임
