### 좋아요 처리하기

- RDB에서 초당 몇만개의 카운트를 구현하기에는 부하가 심함
- sorted set을 사용해서 좋아요 한 유저를 추가하고, 그에 대한 개수를 카운트해서 쉽게 구현이 가능함

```
127.0.0.1:6379> sadd comment-like:123 1 2 3 4 5
(integer) 5
127.0.0.1:6379> scard comment-like:123
(integer) 5
127.0.0.1:6379>
```

<br/>

### 읽지 않은 메시지 수 카운팅하기

- 레디스에 저장했다가 필요한 시점에 한번에 꺼내서 업데이트하는 방식으로 구현
- RDB의 부하를 최소화하고 성능을 향상시킬수 있음
- 예시
  - 상황 : 아래 채널에 접속한 유저에게 새로운 메세지가 1건 온다고 가정
  - 유저 아이디 : 123
  - 채널 아이디 : 4234

```
127.0.0.1:6379> hset user:234 channel:4234 1
(integer) 1
127.0.0.1:6379> hincrby user:234 channel:4234 1
(integer) 2
127.0.0.1:6379> hgetall user:234
1) "channel:4234"
2) "2"
127.0.0.1:6379>
```

<br/>

### DAU 구하기

- DAU는 하루동안 서비스에 방문한 사용자의 수를 의미
- set으로 구현도 가능하지만, 1000만명이 방문했을때 모든 유저 아이디를 저장하는건 비효율적임
  - 가능하면 하나의 키당 2~300만개의 값을 저장하는걸 권장함
- 레디스 비트맵을 활용하면 메모리를 아끼면서 실시간으로 서비스 DAU 구현이 가능해짐
- 1000만명의 사용자는 1개의 비트로 표현이 가능 -> 대략 1.2MB로 매우 효율이 좋음

```
<!-- 유저 아이디가 14인 유저의 방문시 -->
127.0.0.1:6379> setbit dau:240912 14 1
(integer) 0

<!-- 특정 일자 DAU 확인 -->
127.0.0.1:6379> bitcount dau:240912
(integer) 1

<!-- 3일 동안 연속 출산한 유저의 정보를 dau:latest로 저장 -->
127.0.0.1:6379> bitop and dau:latest dau:240910 dau:240911 dau:240912
(integer) 2
127.0.0.1:6379> bitcount dau:latest
(integer) 1
127.0.0.1:6379>

<!-- 비트맵 가져오기 -->
127.0.0.1:6379> get dau:latest
"\x00\x02"
127.0.0.1:6379>
```

비트맵 내부의 값을 깔려면 파이썬 등 프로그래밍 언어에서 추출하면 된다

<br/>

### hyperloglog를 이용한 어플리케이션 미터링

- 클라우드 환경은 사용한 만큼 지불하는 정책을 가진다
- 이러한 정책에서 과금비용을 계산하기 위해서 초당 수천건 이상의 작업이 발생할 수 있다
- 이 때 미터링 솔루션 사용이 가능하고, 이는 높은 처리량과 낮은 대기시간을 가져야한다
- set과 유사하지만 용량은 12kb로 고정되어서 효율적이다

```
<!-- 49483 로그 저장 -->
127.0.0.1:6379> pfadd 240912:user:123 49483
(integer) 1

<!-- 32714 로그 저장 -->
127.0.0.1:6379> pfadd 240912:user:123 32714
(integer) 1

<!-- 49483 로그 저장 -->
127.0.0.1:6379> pfadd 240912:user:123 49483
(integer) 0

<!-- hyperloglog에 저장된 중복되지 않은 데이터의 개수 확인 -->
127.0.0.1:6379> pfcount 240912:user:123
(integer) 2
```
