# 레디스의 스트림

- 5버전에서 추가된 자료구조
- 대용량/대규모 메세징 데이터 처리가 가능하도록 설계됨
- 계속해서 데이터를 추가만 할 수 있는 구조임
- 사용처
  - 대량의 데이터를 효율적으로 처리하는 플랫폼으로 활용
  - 생성상 데이터를 소비자들이 처리할 수 있게 지원하는 저장소 및 큐잉시스템
- Kafka와 유사하며 일부 기능은 훨씬 뛰어나게 설계됨

<br/>

# 스트림

- 연속적인 데이터의 흐름, 일정한 데이터 조각의 연속을 의미
- 예를 들면 대용량 데이터를 읽어올 때 한번에 다 읽는게 아닌 여러개의 쪼개서 로딩

<br/>

# 데이터의 저장

- 레디스 스트림에서 각 메세지는 시간과 관련된 고유한 ID를 가짐
  - `<millisecondsTime>-<sequenceNumber>`

### XADD

- 새로운 이름의 스트림에 데이터를 저장하면 바로 자료구조가 생성됨
- 기존에 존재하는 스트림에 데이터를 추가하면 데이터만 추가됨
- hash 자료 구조와 유사하게 데이터가 저장되므로 각 메세지마다 유동적 데이터 저장이 가능함
- 기본아이디가 아닌 별도의 아이디가 사용하고 싶다면 \* 대신 아이디를 입력하면됨
  - 최소값은 0-1 이며 이후 아이디는 더 큰 값을 사용해야함

```
127.0.0.1:6379> xadd email * subject "first" body "hello?"
"1726208369577-0"
127.0.0.1:6379> xadd email * subject "second" body "world"
"1726208392652-0"
127.0.0.1:6379> xadd noob 0-1 "hello" "world"
"0-1"
127.0.0.1:6379> xadd noob 0-2 "hello" "world"
"0-2"
```

<br/>

# 데이터 조회

### 실시간 리스닝

- XREAD 명령어로 실시간으로 스트림에 저장되는 데이터를 읽어올 수 있음
  - `xread block 0 streams email 0`
    - block
      - block 0 : 더 이상 가져올 데이터가 없어도 연결 끊지말고 리스닝
      - block 1000 : 최대 1초(1000ms) 리스닝
    - streams email
      - streams email 0 : id가 0보다 큰 값을 읽어오라는 의미, 즉 처음부터 다 읽기
      - streams email $ : 커맨드 실행한 이후 추가된 값 읽어오라는 의미

```
127.0.0.1:6379> xread block 0 streams email 0
1) 1) "email"
   2) 1) 1) "1726208369577-0"
         2) 1) "subject"
            2) "first"
            3) "body"
            4) "hello?"
      2) 1) "1726208392652-0"
         2) 1) "subject"
            2) "second"
            3) "body"
            4) "world"
127.0.0.1:6379>
```

<br/>

### 특정 데이터 조회

- XRANGE 커맨드로 ID를 통해 특정 시간대의 데이터 조회가 가능함
- 가장 작은 아이디는 -로, 마지막 아이디는 +로 지정이 가능함

```
<!-- 스트림의 모든 값 조회 -->
127.0.0.1:6379> xrange email - +
1) 1) "1726208369577-0"
   2) 1) "subject"
      2) "first"
      3) "body"
      4) "hello?"
2) 1) "1726208392652-0"
   2) 1) "subject"
      2) "second"
      3) "body"
      4) "world"

<!-- 특정 시간대의 값 조회 -->
127.0.0.1:6379> xrange email 1726208369577 1726208369579
1) 1) "1726208369577-0"
   2) 1) "subject"
      2) "first"
      3) "body"
      4) "hello?"
127.0.0.1:6379>

<!-- 특정 시간대를 기준으로 해당 시간을 제외한 데이터 조회 -->
127.0.0.1:6379> xrange email (1726208369577 1726208369579
(empty array)
127.0.0.1:6379>

<!-- 조회할 최대 개수 지정(COUNT) -->
127.0.0.1:6379> xrange email 1726208369577 1726208369579 count 1
1) 1) "1726208369577-0"
   2) 1) "subject"
      2) "first"
      3) "body"
      4) "hello?"
127.0.0.1:6379>
```

<br/>

# 소비자, 소비자 그룹

- 동일한 데이터를 여러개의 소비자에게 전달하는걸 fan-out 이라고 부름
- XREAD 명령어를 통해서 여러개의 소비자가 하나의 스트림을 구독할 수 있음
- 레디스는 스트림에 데이터가 저장되는 순간에 아이디가 부여되므로 순서보장이 가능함
- 레디스의 소비자 그룹은 그룹 내 다른 소비자가 읽지 않은 메세지만 읽어감
- 소비자 그룹 내부에서는 각 소비자를 식별할 수 있는 고유한 이름을 부여해야함

```
<!-- 새로운 소비자 그룹 생성, 생성 이후에 발생한 메세지만 읽도록 지정 -->
127.0.0.1:6379> xgroup create email EmailServiceGroup $
OK
127.0.0.1:6379> xreadgroup group EmailServiceGroup emailService1 count 1 streams email >
(nil)
127.0.0.1:6379>
```

#### 명령어의 의미

- COUNT 1 : email stream에 있는 1개의 메세지만 읽어오기, 없으면 nil
- stream email > : 다른 소비자에게 전달되지 않은 메세지를 읽어오기

<br/>

# 부하분산

- 스트림과 소비자 그룹은 별개로 동작할 수 있음
- 여러개의 소비자 그룹이 존재할수 있고, 같은 그룹내에서 같은 메세지 수신도 가능함
- 또한 다른 소비자 그룹에서 다른 그룹이 수신한 메세지도 읽을 수
- 따라서 특정 메세지가 필요한 여러개의 서비스로 분산이 가능함

<br/>

# ACK와 보류 리스트

- 장애로 인해 시스템이 종료되면 어디까지 처리했는지, 처리유무 등 인지가 필요함
- 레디스 자체적으로 읽어간 메세지에 대한 리스트를 관리하고 해당 값은 동일한 메세지를 중복으로 전달하지 않기 위해서 사용함
  - 마지막으로 읽어간 아이디는 `last_delivered_id`로 저장/업데이트됨
- 소비자마다 보류 리스트를 가지고 있으며 처리가 완료되면 ACK 메세지에 의해서 해당 항목이 삭제됨

```
127.0.0.1:6379> xpending email EmailServiceGroup
1) (integer) 0 // ACK를 못받아서 보류중인 개수
2) (nil) // 보류중인 아이디의 최소값
3) (nil) // 보류중인 아이디의 최대값
4) (nil) // 보류중인 개수
127.0.0.1:6379>
```

```
<!-- 데이터 처리됬다는 신호 보내기 -->
127.0.0.1:6379> xack Email EmailServiceGroup 1726212055826-0
(integer) 0
127.0.0.1:6379>
```

<br/>

# 보증전략

### at most once

- 메세지를 최초 한번 보내는것을 의미
- 소비자는 실제로 메세지 처리전에 ACK 신호를 보냄
  - 속도는 올라가지만 서비스 다운이후에 복구시에는 실제 처리를 못한 데이터 유실가능성이 있음
- 일부 메세지가 손실되도 빠른 응답이 필요한경우 사용함

### at least once

- 소비자는 받은 모든 메세지를 실제로 처리하고나서 ACK를 보냄
- 하지만 처리도중 장애가 발생해서 재처리가 필요한 경우 중복처리가 발생할 수 있음
- 멱등함이 보장되는 서비스면 괜찮지만, 그렇지 않을 경우는 문제가 발생할 수 있음

### exactly once

- 모든 메세지는 무조건 한 번씩 전송되는 것을 보장한다는 의미
- 레디스 내부에서 set 등을 활용해서 이미 처리된 메세지 유무를 관리하는 등 추가작업이 필요

<br/>

# 메세지 재할당

- 만약 특정 소비자 채널이 장애가 발생이후에 복구되지 않는다면 다른 소비자가 처리해줘야함
- XCLAIM 명령어를 이용해서 메세지 소유권을 다른 소비자에게 할당이 가능함
- 명령어 사용시 최소 대기시간 설정이 필요함
  - 최소 대기시간을 초과한 경우만 소유권을 변경할 수 있도록 해서 동일 메세지가 다른 소비자에게 중복할당 되는걸 방지해줌

<br/>

# 메세지 자동 재할당

- XCLAIM의 경우 XPENDING을 통해서 사전에 보류된 메세지 확인이 필요함
  - 이런 재할당을 해야하는 상황이 자주 생기면 매우 귀찮아짐
- XAUTOCLAIM 명령어를 이용해서 메세지 자동으로 재할당이 가능함

<br/>

# 메세지 수동 재할당

- 스트림 내부의 메세지는 각 counter라는 값을 가지고있음
- XREADGROUP, XCLAIM을 통해서 소비자에게 할당 및 재할당할때 1씩 증가
- 메세지에 문제가 있어서 처리되지 못할경우 counter가 무한하게 증가함
- counter가 특정값에 도달하면 메세지를 특수한 다른 스트림으로 보내서 추후에 수동으로 처리하게 하는게 현명할수도 있음
- 이를 dead letter 라고 부름

<br/>

# 스트림 상태 확인

- XINFO 명령어를 통해서 스트림의 상태를 확인할 수 있음

```
<!-- 특정 소비자 그룹에 속한 소비자의 정보 확인 -->
127.0.0.1:6379> xinfo consumers email EmailServiceGroup
(empty array)
127.0.0.1:6379>
```

```
<!-- 스트림에 속한 전체 소비자 그룹 리스트 -->
127.0.0.1:6379> xinfo groups email
1)  1) "name"
    2) "EmailServiceGroup"
    3) "consumers"
    4) (integer) 0
    5) "pending"
    6) (integer) 0
    7) "last-delivered-id"
    8) "1726211987802-0"
    9) "entries-read"
   10) (nil)
   11) "lag"
   12) (integer) 1
127.0.0.1:6379>
```

```
<!-- 스트림 자체의 정보 -->
127.0.0.1:6379> xinfo stream email
 1) "length"
 2) (integer) 2
 3) "radix-tree-keys"
 4) (integer) 1
 5) "radix-tree-nodes"
 6) (integer) 2
 7) "last-generated-id"
 8) "1726212055826-0"
 9) "max-deleted-entry-id"
10) "0-0"
11) "entries-added"
12) (integer) 2
13) "recorded-first-entry-id"
14) "1726211987802-0"
15) "groups"
16) (integer) 1
17) "first-entry"
18) 1) "1726211987802-0"
    2) 1) "subject"
       2) "New Features"
       3) "body"
       4) "redis 9"
19) "last-entry"
20) 1) "1726212055826-0"
    2) 1) "subject"
       2) "New Features"
       3) "body"
       4) "redis 9"
127.0.0.1:6379>
```
