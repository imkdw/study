# 메세지 브로거

- 최근 아키텍쳐는 여러개의 모듈이 느슨하게 연결된 구조를 선호함
- 모듈간 느슨하지만 탄탄한 상호작용을 위해서 메세지 브로커가 필요함
- 모듈간의 상호작용은 동기 방식보다는 비동기 방식을 권장함
- 메세지 브로커는 메시징 큐, 이벤트 스트림 2개로 나눌 수 있음

<br/>

# 메시징 큐

- 데이터를 생성하는 역할을 생산자로, 수신하는 쪽은 소비자로 지칭함
- 생산자는 소비자의 큐로 메세지를 직접 푸시하게 됨
- 소비자는 메시징 큐의 메세지를 읽으면 해당 데이터를 삭제함
- 만약 2개의 소비자에게 같은 메세지를 전달해야되면 2개의 메세지를 푸시해야함
- 만약 사전에 데이터가있는 상태에서 새로운 소비자가 추가되면 기존 데이터를 읽을 수 없음
- 보통 1:1 상황에서 한서비스가 다른 서비스에게 동작을 지시할 때 유용함

<br/>

# 이벤트 스트림

- 데이터를 생성하는 역할을 발행자, 데이터를 조회하는 쪽을 구독자로 지칭함
- 발생자는 특정 저장소에 데이터를 1개 푸시가 가능함
- 구독자들은 동일한 메세지를 풀이 가능하므로 메세지를 복제해서 저장하지 않아도됨
- 구독자가 읽은 메세지는 큐와 다르게 바로 삭제하지 않고 일정 시간뒤에 삭제됨
- 스트림은 특정 저장소에 데이터가 남기때문에 히스토리 조회가 가능함
- 보통 다대다(N:M) 상황에서 유리함

<br/>

# 레디스를 메세지 브로커로 사용하기

- 자체적으로 제공하는 pub/sub 패턴을 사용해서 구현이 가능함
- 한번 전송된 데이터는 바로 삭제되고 잘 전달됬는지 등 정보는 보장하지 않음
- fire-and-forget 처럼 일회성으로 간단한 알림 서비스에서 유용하게 사용이 가능함

### 레디스에서 메시징 큐

- list 자료구조는 메세징 큐로 사용하기에 알맞음
- 데이터 푸시/팝이 가능하고, 매번 데이터가 있는지 확인하지 않고 list에 데이터가 추가되면 읽어갈 수 있는 블로킹 기능 사용이 가능함

### 레디스에서 이벤트 스트림

- stream 자료구조는 이벤트 스트림을 사용하기에 알맞음
- Kafka에서 영감을 받은 구조로, 오직 데이터 추가만 지원함
