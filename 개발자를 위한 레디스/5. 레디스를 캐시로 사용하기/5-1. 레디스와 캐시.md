# 캐시

- 데이터의 원본보다 빠르고 효율적으로 엑세스할 수 있는 임시 데이터 저장소
- 원본 데이터를 가져오는거 보다 빠르기 때문에, 작업을 위한 대기시간을 줄일 수 있음

<br/>

# 캐시로서의 레디스

- 사용이 매우 간단함
- 데이터를 검색하고 반환하는게 매우 빠름
- 평균 읽기/쓰기 속도는 1ms고, 초당 수백만 건의 작업이 가능함
- 센티널 또는 클러스터를 통해서 가용성도 보장이 가능함

<br/>

# 캐싱 전략

- 레디스를 캐시로 사용할 떄 어떻게 배치하냐에 따라서 성능에 큰 영향을 미칠 수 있음

### 읽기 전략 - look aside

- 데이터를 읽어갈떄 주로 사용하며, 가장 일반적인 방법
- 데이터를 읽을때 캐시에 존재하는지 먼저 확인하고 있으면 그 데이터를 반환함
- 캐시에 없다면 원본 DB에서 데이터를 읽어서 가져옴, 이후 원본 데이터를 레디스에 저장
- 장점은 레디스에 문제가 발생하더라도 원본 DB가 살아있다면 거기서 데이터를 가져오면됨
  - 하지만 만약 모든 요청이 DB를 통과하게되면 부하가 발생할수도 있음

#### 캐시워밍

- 최초 어플리케이션 로딩시 레디스에는 데이터가 없기때문에 모든 요청이 디비로 향함
- 이 때 부트스트래핑시 DB의 데이터를 레디스에 미리 올려놓는걸 캐시워밍 이라고 부름

<br/>

### 쓰기 전력과 캐시의 일관성

- 캐시는 DB에 저장된 데이터를 단순히 복사해온 값이다
- 만약 업데이트시 원본 DB에만 데이터가 변경되면 캐시와 불일치가 발생한다

#### wrtie through

- DB의 데이터를 업데이트 할때마다 레디스의 데이터도 같이 업데이트하는 전략
- 최신데이터를 유지하지만 매번 레디스와 DB 2개의 데이터를 업데이트 해야함

<br/>

### 만료시간

- 레디스의 TTL은 데이터를 얼마나 오래 저장할건지에 대한 시간이며 초 단위로 표현함

#### 만료된 데이터의 삭제방식

- passive 방식
  - 특정 키에 접근시 해당 데이터가 만료됬다면 그 때 삭제함
  - 하지만 사용자가 다시는 접근하지 않을수도 있어서 이 방법만으로는 충분하지 않음
- active 방식
  - TTL이 설정된 키 중 20개를 랜덤으로 뽑아서, 만료된 키는 메모리에서 삭제
  - 25% 이상의 키가 삭제됬다면 다시 20개의 키를 랜덤하게 뽑고 확인
  - 만약 25% 이상의 키가 삭제되지 않았다면 20개의 키 집합에서 다시 확인
  - 위 과정을 1초에 10번씩 수행함
- 공통적으로 발생하는 문제는 최악이라는 가정으로 전체 사용량의 25%는 이미 만료된 키일수도 있음

<br/>

### 메모리 관리와 maxmemory-policy 설정

- 너무 많은 데이터가 저장되면 메모리가 가득 찰수도 있음
- 최대 메모리 사용량과, 가득 찼을떄 어떤 기준으로 내부 데이터를 지울지 정할수 있음

#### noeviction

- 기본값으로 데이터가 가득 차더라도 자동으로 삭제하지 않음
- 메모리가 가득 찬 경우 더이상 데이터 저장이 불가능하다고 에러를 반환하는 설정
- 어플리케이션의 에러로 이어질 수 있으며 권장하지 않는 설정값
- 데이터의 관리 책임을 앱에서 담당하겠다는 의미
- 보통 내부적 판단으로 데이터를 삭제하는게 위험하다고 판단될 때 사용함

<br/>

### LRU eviction

- 데이터가 가득 차는 경우 가장 최근에 사용되지 않은 데이터부터 삭제하는 정책
- volatile-lru
  - 만료시간이 설정된 키에 한해서 자동으로 삭제 처리
  - 만료되면 안되는 데이터를 사용(TTL 미적용)시에 해당 방법이 적합
  - 단점은 모든 키에 만료시가닝 없다면 noeviction과 동일한 정책을 지님
- allkeys-lru
  - 레디스를 캐시로 사용할 때 잘 모르겠다면 해당 방식을 사용하는걸 권장함
  - 모든 키를 LRU 방식으로 삭제하므로 장애는 막을 수 있음

<br/>

### LFU eviction

- 데이터가 꽉 찼을때 가장 자주 사용되지 않은 데이터부터 삭제하는 정책
- 키를 엑세스하는 패턴에 따라서 우선순위가 유동적으로 바뀔수 있음
- volatile-lfu
  - 만료시간이 설정된 키에 한해서 자동으로 삭제 처리
  - 마찬가지로 특정 상황에선 장애가 발생할 수 있음
- allkeys-lfu
  - 모든 키에 대해서 LFU 정책을 적용하는 방법

<br/>

### random eviction

- 레디스에 저장된 키를 랜덤으로 골라내서 삭제하는 방식
- 다른 방법과 다르게 어떤 키를 삭제할지 고르지 않아도 되서 부하가 덜함
- 랜덤으로 삭제해서 추후 사용될 데이터를 지울수도 있으니 주의해야함
- volatile-random
  - 만료시간이 설정된 키에 한해서 자동으로 삭제 처리
- allkeys-random
  - 모든 키에 대해서 random 정책을 적용하는 방법
- volatile-ttl
  - 만료시간이 제일 가까운 키를 삭제

<br/>

### 캐시 스탬피드 현상

- 모든 키에 대해서 TTL을 설정하는걸 권장하지만 일부 환경에서는 스탬피드 현상이 발생할 수 있음
- N개의 어플리케이션에서 데이터에 접근하는 상황을 가정
  - 특정 키가 만료되어서 N개의 요청이 동시에 DB에 무거운 읽기를 요청
  - 레디스에는 데이터가 N번 갱신
- 이러한 현상은 DB에 부하를 주며 서비스 장애로도 이어질 수 있음

#### 적절한 만료시간 설정

- 가장 간단한 방법으로 만료시간을 너무 짧지 않게 하는것
- 앱에서 반복적으로 여러번 사용해야하는 데이터라면 만료시간을 길게 설정하는게 좋음

#### 선 계산

- 실제 키가 만료되기전에 갱신해주는 방법

#### PER 알고리즘

- 캐시가 만료되기 전에 언제 DB에서 데이터를 읽어야하는지 계산하는 알고리즘

```
currentTime - (timetoCompute * beta * log(rand())) > expiry
```
