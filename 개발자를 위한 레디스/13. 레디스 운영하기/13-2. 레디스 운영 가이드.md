# 장애, 성능저하를 읽으키는 설정 항목

### maxmemory-policy

- 메모리가 가득 찼을때 어떤 키를 제거할지에 대한 설정
- 기본적으로 데이터를 더이상 저장할 수 없다는 에러 발생

### stop-writes-on-bgsave-error

- rdb snapshot에서 에러가 발생하면 모든 쓰기 작업을 중단하는 역할
- 최신 백업의 실패를 인지하고, 서버에 문제가 있음을 알려줘서 더 큰 장애를 막음
- 하지만 모니터링툴이 존재해서 쉽게 식별이 가능하므로 계속해서 쓰기를 원한다면 비활성화 하기

### 자동 백업 옵션

- AOF, RDB 모두 bgsave로 동작할때 메모리 사용량이 2~3배씩 늘어날수도 있음
- 가능하면 원하는 시간대에 작업을 수행하도록 설정하는게 좋음

<br/>

# 레디스 운영 및 성능 최적화

### 오래 걸리는 커맨드 사용

- 레디스는 싱글스레드로 동작하므로 O(N) 이상의 커맨드를 사용하는걸 지양하는게 좋음

### 레디스에서 트랜잭션

- 레디스는 싱글스레드로 작동하기 떄문에 주의해서 써야함
  - 트랜잭션 동안 다른 요청을 모두 블록킹됨
  - 또한 트랜잭션 내부에서는 BRPOP, BLPOP을 쓸 수 없음
- 트랜잭션을 위한 2가지 방법을 제공함

#### MULTI/EXEC

- MULTI로 트랜잭션을 열고, EXEC로 완료하는 방식임

```
127.0.0.1:6379> multi
OK
127.0.0.1:6379(TX)> incrby money 100
QUEUED
127.0.0.1:6379(TX)> rpush log "입금 100"
QUEUED
127.0.0.1:6379(TX)> exec
1) (integer) 200
2) (integer) 1
127.0.0.1:6379>
```

#### 루아 스크립트

- 레디스 내부에서 원자적으로 실행됨
- 여러개의 명령을 한번에 수행이 가능하고, 중간에 다른 요청을 수용하지 않아 트랜잭션처럼 사용이 가능
- 원자성을 가지지만 중간에 명령어가 실패해도 다음 라인으로 넘어가서 롤백이 안됨

### has-get / has-del 패턴

- 사전에 exists로 확인하고 데이터를 가져오거나 삭제하는 패턴을 뜻함
- 네트워크 부하를 늘리고 불필요한 작업이 같이 진행되므로 지양하는걸 권장함

### 클라이언트 출력 버퍼 사이즈

- 클라이언트가 서버로 응답을 받을때 일시적으로 저장하는 역할
- 속도차이나 부하 등 으로 인해 발생하는 버퍼오버플로를 방지해서 안정적인 통신을 보장해줌
- 하지만 대용량 데이터나 많은 커맨드를 쓰는 경우는 오버플로가 발생할 수 있음
- 복제를 사용하는 경우는 사이즈를 꼭 늘려줘야함

### 키스페이스 알림 기능을 사용한 키 만료 모니터링

- 키에 대한 변경사항을 모니터링해서 내부적인 pub/sub 채널을 이용해서 메세지를 구독할수 있는 기능
- notify-keyspace-events 옵션을 사용해서 알림을 받을 수 있음

### 특정 prefix를 가진 키 삭제

- 레디스에서 기본적으로 제공하지 않는 기능으로 앱에서 핸들링이 필요함
- 루아 스크립트를 통해서 삭제하면 네트워크 부하 최적화도 가능함

<br/>

# 레디스 모니터링

### 슬로우 로그

- 응답시간이 길어지는 쿼리를 기록하는 로그
- cli에서 `SLOWLOG GET` 명령을 사용해서 접근할 수 있음
- `slowlog-log-slower-than` 옵션을 사용해서 쿼리 시간이 지정된 시간보다 늦어지면 기록함
  - 기본은 10초로 되어있음
- `slowlog-max-len` 옵션을 사용해서 저장할 수 있는 로그 길이를 지정함
  - 기본은 128이다

```
127.0.0.1:6379> slowlog get
(empty array)
127.0.0.1:6379>
```

### 그래프 지표

#### CPU

- 커맨드를 실행하는 동안은 싱글스레드로 작동하지만, 백업, 파일저장 등 백그라운드 작업시 다른 CPU 활용이 가능함

#### 메모리

- 핵심 요소 중 하나이며, 주의 깊게 모니터링이 필요함
- `used_memory` 옵션을 사용해서 사용된 메모리를 지정함
- `DatabaseMemoryUsagePercentAge`가 100%에 도달하면 이빅션 작업이 발생함
  - CPU 사용량이 과도하게 올라갈수 있으니 주의가 필요함
- 항상 데이터의 TTL을 적절하게 지정하는게 좋음
- `used_memory_rss`는 OS가 레디스에 할당한 실제 물리적인 메모리 사용량임
  - 논리적인 메모리 < 물리적인 메모리 상태가 되면 단편화 문제가 발생할수도 있음
  - 대표적으로 키가 갑작스럽게 몰렸다가 삭제, 이빅션이 많이 발생 등이 원임임
  - `activedefrag yes`로 단편화가 자주 발생할때 최적화가 가능함. 필수는 아님

#### 네트워크

- 레디스는 더 많이 처리가 가능하지만, 네트워크 대역폭으로 인해 성능이 낮은것처럼 보일수도 있음
- 복제, 클러스터 등 다양한 방법으로 최적화가 가능함

#### 커넥션

- 레디스에 연결된 클라이언트의 커넥션 숫자를 모니터링
- 앱의 장애로 인해 급격하게 올라가거나 등 할수 있음
- timeout이 아닌 tcp keepalive 옵션을 사용하는 경우 CPU 사용량이 더 많으니 커넥션 풀링이 중요함

#### 복제

- 복제 지연은 복제본 노드에서 마스터 노드의 데이터를 복제가 지연되는걸 뜻함
- 복제 지연이 발생하면 원인을 빠르게 파악해서 해결하는게 좋음
