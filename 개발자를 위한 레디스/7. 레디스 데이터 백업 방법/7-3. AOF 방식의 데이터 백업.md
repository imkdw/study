# AOF 방식의 데이터 백업

- 파일명은 기본적으로 appendonly.aof로 저장됨
- 메모리상 데이터가 변화하는 작업만 기록됨
  - flushall 명령어로 모든 데이터를 날려도, 복구가 가능함
- 모든 데이터가 실제 레디스 명령어로 저장되진 않음
  - BRPOP 같은 경우는 aof 내부에는 RPOP으로 저장됨

```
appendonly yes
appendfilename "appendonly.aof"
appenddirname "appendonlydir"
```

<br/>

# AOF 파일 재구성하기

- AOF 백업을 안정적으로 사용할려면 점점 커지는 파일을 주기적으로 압축을 통한 재구성이 필요함
  - 조건부 또는 수동으로 재구성이 가능함
- 기존 디스크에 존재하는 AOF 재사용이 아닌, 메모리에 있는 데이터를 통한 새로운 파일을 만듬

### 버전 7 이전의 재구성 과정

- fork를 통해 자식 프로세스 생성 및 레디스 데이터를 신규 임시파일로 저장
- 위 과정에서 데이터가 변경되면 AOF 파일 및 인메모리 버퍼에 동시에 저장
- AOF 재구성이 끝나면 인메모리 버퍼에 저장된 내용을 임시파일 마지막에 추가
- 임시파일을 기존 AOF 파일에 덮어씌움

### 버전 7 이후의 재구성 과정

- fork를 통해 자식 프로세스 생성 및 레디스 데이터를 신규 임시파일로 저장
- 위 과정에서 데이터가 변경되면 신규 AOF 파일에 저장
- 재구성이 끝나면 임시 manifest 파일을 생성하고 변경된 버전으로 업데이트
- manifest 파일을 덮어씌우고 이전 버전의 파일을 삭제함
- 순차적인 I/O만 발생해서 디스크 접근 과저이 매우 효율적임

<br>

# 자동 AOF 재구성

- 현재와 마지막으로 구성된 AOF 파일을 비교해서 처리함
- 비효율적일수도 있으니 적어도 AOF 파일이 특정 크기 이상일때만 재구성을 하도록 지정하는걸 권장

```
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
```

<br/>

# 수동 AOF 재구성

- BGREWRITEOF 명령어를 통해서 원하는 시점에 수동으로 AOF 파일을 재구성할 수 있음
- 자동으로 재구성할때랑 동일하게 동작함

<br/>

# AOF 타임스탬프

- 버전 7 이상부터는 AOF를 저장할 때 타임스탬프를 남길 수 있음
- 설정에서 aof-timestamp-enabled 옵션을 활성화해서 사용이 가능함
- 타임스탬프가 있다면 redis-check-aof를 사용해서 특정 시점으로 복원도 가능함

<br/>

# AOF 파일 복원

- redis-check-aof 프로그램은 AOF 파일이 손상됬을때도 사용이 가능함
- 내부에서 fix 옵션을 사용하면 원본 파일에도 영항이 가니 가능하면 외부에다 복제해두는것을 권장함

<br/>

# AOF 파일의 안정성

### OS에서 파일을 저장하는 방법

- 레디스에서 커널로 WRITE라는 신호를 발송
- 커널에서는 OS 영역의 임시 버퍼에 파일을 저장
- OS가 판단하기에 커널이 여유있거나, 최대 지연시간인 30초에 도달하면 실제 디스크에 저장
  - FSYNC는 커널의 OS 버퍼에 있는 내용을 디스크에 강제 저장하는 시스템콜

### 레디스에서 옵션 제어

- APPENDASYNC 옵션을 사용하면 FSYNC 호출 제어가 가능함
- APPENDASYNC no
  - AOF 파일을 저장할 때 WRITE 시스템 콜을 호출
  - 커널 영역에 데이터가 잘 저장되는지만 확인해서 성능이 제일 좋음
- APPENDASYNC always
  - AOF 파일을 저장할 때 WRITE + FSYNC 시스템 콜을 호출
  - 매번 데이터를 쓸때 정확하게 저장되는지 기다리므로 성능이 제일 낮음
- APPENDASYNC everysec(기본/권장)
  - AOF 파일을 저장할 때 WRITE를 호출하고, 1초에 한번씩 FSYNC 시스템 콜을 호출
  - 성능은 no 랑 거의 비슷함
