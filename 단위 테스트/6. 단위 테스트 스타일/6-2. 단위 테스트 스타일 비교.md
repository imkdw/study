# 회귀 방지와 피드백 속도 지표로 비교

### 회귀 방지 지표를 결정하는 수치

- 테스트 중 실행되는 코드의 양
- 코드 복잡도
- 도메인 유의성

<br>

### 관계

- 보통 코드가 적든 많든 원하는 대로 테스트 작성이 가능함
- 코드 복잡도와 도메인 유의성 역시 마찬가지지만, 통신 기반 스타일에는 예외가 있음
  - 남용하면 작은 코드 조각을 검증하고 다른 것은 모두 목을 사용하는 등 피상적인 테스트가 나올수도 있음
- 테스트 스타일과 피드백 속도 사이에는 상관관계가 거의 존재하지 않음
- 목은 런타임에 지연 시간이 생기는 편이기는 하나 테스트가 수만개가 아니라면 별로 차이는 없음

<br>

# 리팩터링 내성 지표로 스타일 비교

- `출력 기반 테스트`는 테스트가 대상 메소드에만 결합되므로 거짓 양성 방지가 가장 우수함
- `상태기반 테스트`는 거짓 양성이 되기 쉬운데 이러한 테스트는 테스트 대상 메소드 외에도 클래스 상태와 함께 동작하기 때문임
- `통신기반 테스트`는 허위 경보에 가장 취약함. 테스트 대역으로 상호작용을 확인하는 테스트는 대부분 깨지기 쉬움

<br>

# 유지 보수성 지표로 스타일 비교하기

- 단위 테스트 스타일과 밀접한 관련이 있지만 완화할 수 있는 방법이 많지 않음
- 단위 테스트 유지비를 2가지 특성으로 정의함
  - 테스트를 이해하기 얼마나 어려운가(테스트 크기에 대한 함수)?
  - 테스트를 실행하기 얼마나 어려운가(테스트에 직접적으로 관련 있는 프로세스 외부 의존)?
- 테스트가 크다면 파악하기도 변경하기도 어려우므로 유지보수가 힘듬
- 테스트가 하나 이상의 외부 의존성과 결합된다면 외부 의존성을 운영하는데 시간이 필요하므로 유지 보수가 어려워짐

<br>

### 출력 기반 테스트의 유지보수성

- 다른 스타일과 비교하면 출력 기반 테스트가 가장 유지보수하기 용이함
- 항상 거의 짧고 간결해서 유지보수하기 편함
- 또한 출력 기반 테스트는 전역 또는 내부 상태를 변경할 일이 없음

<br>

### 상태 기반 테스트의 유지보수성

- 일반적으로 출력 기반 테스트보다 유지 보수가 쉽지 않음
- 상태 검증은 종종 출력보다 더 많은 공간을 차지하기 때문임

<br>

#### 예제

- 테스트는 단순하고 댓글이 하나만 있지만, 검증부는 4줄에 걸쳐서 있음
- 상태 기반 테스트는 종종 훨씬 많은 데이터를 확인해야 하므로 크기가 대폭 커질수도 있음

```ts
it("adding_a_comment_to_an_article", () => {
  const sut = new Article();
  const text = "Comment Text";
  const author = "John Dae";
  const now = new Date("2024-11-24");

  sut.addComment(text, author, now);

  /**
   * 글(Article)의 상태를 검증함
   */
  expect(sut.comments).toHaveLength(1);
  expect(sut.comments[0].text).toBe(text);
  expect(sut.comments[0].author).toBe(author);
  expect(sut.comments[0].date).toBe(now);
});
```

<br>

#### 상태를 검증하는 헬퍼 메소드

- 위 코드처럼 여러줄의 코드에 대해서 헬퍼 메소드로 완화가 가능함
- 하지만 이러한 메소드를 작성하고 유지하는데는 상당한 노력이 필요함

```ts
it("adding_a_comment_to_an_article", () => {
  const sut = new Article();
  const text = "Comment Text";
  const author = "John Dae";
  const now = new Date("2024-11-24");

  sut.addComment(text, author, now);

  /**
   * 헬퍼 메소드를 통한 글(Article)의 상태 검증
   */
  sut.shouldContainNumberOfComment(1).withComment(text, author, now);
});
```

<br>

#### 동등 멤버 정의를 통한 상태검사

- `Fluent Assertions`와 같은 검증문 라이브러리를 통해서 테스트 단순화가 가능함
- 이는 강력한 기술이지만, 클래스가 값에 해당하고 값 객체로 변환이 가능할때만 효과적이다
- 오히려 코드의 오염으로 이어질수도 있다
- 결국 어떠한 방법을 사용하더라도 출력 기반 테스트 보다 공간을 더 많이 차지해서 유지보수성이 떨어지게된다

```ts
it("adding_a_comment_to_an_article", () => {
  const sut = new Article();
  const comment = new Comment(
    "Comment Text",
    "John Dae",
    new Date("2024-11-24")
  );

  sut.addComment(comment.text, comment.author, comment.date);

  sut.comments.should().beEquivalentTo(comment);
});
```

<br>

### 통신 기반 테스트의 유지보수성

- 통신 기반 테스트는 테스트 대역과 상호 작용 검증을 설정해야하며, 이는 공간을 많이 차지하게됨
- 목이 사슬(목이 다른목을 반환다는 등) 형태로 있을때 테스트는 더 커지고 유지보수가 힘들어짐

<br>

# 스타일 비교하기 : 결론

- 가능하면 항상 다른 것보다 출력 기반 테스트를 선호하는게 좋다
- 하지만 이는 쉽지 않는데 우선적으로 함수형으로 적용된 코드에만 가능하다
- 대부분의 객체지향 프로그래밍 언어에ㄴㄴ 해당하지 않는다
- 코드를 순수 함수로 만들면 상태 기반 테스트나 통신 기반 테스트 대신 출력 기반 테스트가 가능해진다

| 구분                             | 출력 기반 | 상태 기반 | 통신 기반 |
| -------------------------------- | --------- | --------- | --------- |
| 리팩터링 내성을 지키기 위한 노력 | 낮음      | 중간      | 중간      |
| 유지미                           | 낮음      | 중간      | 높음      |
