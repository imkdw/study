# 디비 트랜잭션 관리

- 트랜잭션은 제품 코드와 테스트 모두 중요한 주제다
- 제품 코드에서 트랜잭션 관리를 적절하게 하면 데이터 모순을 피할 수 있음

<br>

# 제품 코드에서 트랜잭션 관리

- 읽기 전용 연산에는 여러 트랜잭션을 열어도 괜찮다
- 하지만 변경 연산이 포함되는 경우는 모순을 피하고자 이 연산에 모든 업데이트는 원자적이여야 한다

<br>

### 디비 트랜잭션에서 디비 연결 분리하기

- 모순을 피하기 위해서는 업데이트할 데이터와 업데이트 유지/롤백여부를 결정해야한다
- 이러한 결정은 데이터베이스 클래스는 `Repository`와 트랜잭션으로 나눠서 책임 구분이 가능하다
  - `Repository`: 디비의 데이터에 대한 접근과 수정을 가능하게 하는 클래스
  - `트랜잭션`: 데이터 업데이트를 완전히 커밋하거나 롤백하는 클래스
  - 위 2가지는 책임과 수명이 모두 다르다
- 결국 레포지토리는 스스로 디비를 호출할 수 없음

```ts
class UserRepository {
  private readonly transaction: Transaction;

  constructor(transaction: Transaction) {
    this.transaction = transaction;
  }

  // ...
}

class Transaction implements IDisposable {
  commit(): void {
    // ...
  }
  rollback(): void {
    // ...
  }
}

interface IDisposable {
  commit(): void;
  rollback(): void;
}
```

<br>

### 작업 단위로 트랜잭션 업그레이드 하기

- 작업은 디비를 변경하기 위해 해야하는 모든 업데이트를 파악하고 이러한 업데이트를 하나의 단위로 실행함
- 트랜잭션과 달리 작업 단위는 비즈니스 연산 종료 시점에 모든 업데이트를 실행함
- 대부분의 ORM 프레임워크는 이러한 작업 단위 패턴을 구현하고있음

<br>

# 통합 테스트에서 디비 트랜잭션 관리하기

- 테스트 구절 간 디비 트랜잭션이나 작업 단위를 재사용하지 말것
- 운영 환경에서는 각 비즈니스 연산에 전용 인스턴스가 존재하고, 해당 인스턴스는 컨트롤러 호출 직전에 생성되고 직후에 폐기됨
- 통합 테스트에서 적어도 3개의(준비, 실행, 검증 별) 트랜잭션이나 작업 단위를 사용하는게 좋다
