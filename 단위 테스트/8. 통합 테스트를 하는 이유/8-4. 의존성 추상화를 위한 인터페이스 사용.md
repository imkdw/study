# 인터페이스와 느슨한 결합

- 대부분의 개발자는 외부 의존성에 대해서 모두 인터페이스를 사용하곤 한다
- 인터페이스를 사용하는 이유는 의존성을 추상화해서 느슨한 결합을 달성하고, 기존 코드를 변경하지 않고 새로운 기능을 추가해서 OCP를 지키기 떄문임

<br>

### 추상화를 위한 인터페이스

- 단일 구현을 위한 인터페이스는 추상화가 아님
- 진정한 추상화는 발견하는것이지 발명하는게 아님

<br>

### YANGI 원칙 위배

- 현재 필요하지 않은 기능에 시간을 들이지 말라는 것
- 당장 비즈니스 담당자들에게 필요하지 않은 기능에 대해서 시간을 보내면 시간을 낭비하는것임
- 처음부터 실제 필요에 따라 기능을 구현하는게 더 유리함

<br>

# 프로세스 외부 의존성에 인터페이스를 쓰는 이유

- 인터페이스가 없다면 테스트 대역 생성이 불가능해서 SUT과 프로세스 외부 의존성 간 상호작용 확인이 안됨
- 별국 비관리 의존성에 대해서만 인터페이스를 쓰는게 적합함
- 목 대체 이외의 이유로 단일 구현을 위해 인터페이스를 도입하는건 YANGI 원칙에 위배됨

```ts
class UserController {
  private readonly database: Database;
  private readonly messageBus: MessageBus;

  constructor(database: Database, messageBus: MessageBus) {
    this.database = database;
    this.messageBus = messageBus;
  }
}
```

<br>

# 프로세스 내부 의존성을 위한 인터페이스 사용

- 만약 구현이 하나만 존재하는데 내부 의존성을 위해서 인터페이스를 사용하는건 좋지 않음
- 도메인 클래스에 대해 단일 구현으로 인터페이스를 도입하는 이유는 목으로 처리하기 위해서임
- 하지만 프로세스 외부 의존성과 다르게 도메인 클래스 간 상호작용을 확인해서는 안됨
  - 이러면 결국 꺠지기 쉬운 테스트로 이어지며 리팩토링 내성이 떨어짐
