# 의존성관계에 따라서 모듈단위로 전환하기

- 점진적 마이그레이션을 진행시에는 모듈단위로 하는것이 이상적임
- 최하단 모듈부터 시작해서 최상단에 있는 모듈을 마지막으로 완성해야함

<br>

# 마이그레이션 순서

### 1. 서드파티 라이브러리 타입정보 해결하기

- `npm i @types/*`를 통해서 먼저 해결이 가능함

### 2. 외부 API에 의존하는 타입정보 작성하기

- 프로젝트 내부 모듈은 외부에 의존하지만 API는 해당 모듈에 의존하지 않음
- API에 대한 스펙을 기반으로 타입 정보를 생성해야함

#### 생성을 위한 도구 : madge

- madge를 활용하면 프로젝트의 의존성 그래프를 그릴 수 있음

### 3. 주의점

- 마이그레이션을 진행할때는 오직 타입정보만 추가해야함
- 당장 목적은 코드개선이 아닌 타입정보 추가이므로 리팩토링을 진행해서는 안됨

<br/>

# 마이그레이션 도중 만나는 오류들

### 선언되지 않은 클래스 멤버

- JS의 경우 클래스 내부 상단에 멤버변수를 선언하지 않음
- TS의 경우 파라미터 표현 방식을 사용하지 않는 이상 미리 선언이 필요함
- 또한 JS 코드를 TS 코드로 마이그레이션하는 과정중에 잘못된 설계도 포착이 가능하지만 절대로 리팩토링을 해서는 안됨
- IDE에서 제공하는 리팩토링 기능을 활용하면 생산성이 올라감

```ts
/** JS */
class Greeting {
  constructor(name) {
    this.name = name;
  }
}

/** TS */
class Greeting {
  name: string;

  constructor(name: string) {
    this.name = name;
  }
}
```

<br/>

### 타입이 바뀌는 값

- 당장 마이그레이션이 급해서 타입 단언을 사용함
- 최종적으로는 해당 문제를 제대로 해결해야함

```ts
/** JS */
const state = {};
state.city = "Seoul";

/** TS */

// 1. 한번에 만들기
const state = {
  city: "Seoul",
};

// 2. 타입 단언하기
interface State {
  city: string;
}
const state = {} as State;
state.city = "Seoul";
```

### @ts-check + JSDoc 무효화되는거 주의하기

- TS로 전환하는 순간 주석으로 작성해둔 타입이 무효화됨
- IDE에서 JSDoc을 기반으로 리팩토링을 해주긴 하지만 주의해서 써야함

<br/>

### 테스트코드를 타입스크립트로 전환하기

- 테스트코드는 항상 의존성의 최상단에 위치하고 마이그레이션의 마지막 단계로 되는것이 자연스러운 일임
- 모듈을 하나씩 변경해도 중간중간 테스트코드가 돌아갈 수 있다는건 엄청난 이점임
