# ID를 이용한 애그리거트 참조

- 애그리거트도 다른 애그리거트를 참조할 수 있는데 모든 관리 주체는 루트이므로 루트-루트간 참조한다고 생각하면되ㅑㄴ다
- 객체간의 참조는 필드를 통해서 쉽게 구현이 가능한데 완전한 객체가 아닌 `아이디`만 참조한다
- 객체를 직접 참조하게되면 발생할 수 있는 문제점들이 존재한다

<br>

### 결합도 증가

- 한 애그리거트에서 다른 애그리거트의 상태를 변경하는건 애그리거트간 의존 결합도를 높이는데 이는 변경을 어렵게 만듬

<br>

### 성능과 관련된 여러가지 고민이 필요

- 단순히 연관된 객체의 데이터를 함꼐 화면에 보여줘야 하면 즉시 로딩이 조회 성능에 유리함
- 애그리거트의 상태를 변경하는 기능을 실행하는 경우는 불필요한 객체를 함꼐 로딩할 필요가 없음

<br>

### 확장이 힘듬

- 초기에는 단일 서버에 단일 DBMS로 서비스를 제공하는 것이 가능함
- 점점 사용자가 늘고 트래픽이 증가하면 부하를 분산하기 위해서 도메인별로 시스템을 분리하는데 이러면 DB로 분리될수 있다
- 이렇게되면 더 이상 다른 애그리거트 루트를 참조하기 위해서 단일 기술을 사용할 수 없음을 의미한다

<br>

### 해결책

- ID 참조를 사용하면 이러한 문제를 해결할 수 있다
- 모든 객체가 참조로 연결되지 않고 한 애그리거트에 속한 객체들만 참조로 연결된다
- 만약 한 애그리거트에서 참조되는 애그리거트가 필요하다면 응용 서비스에서 ID를 통해서 로딩하면 된다
- 각 도메인별로 다른 구현기술을 사용할수도 있고 응용 서비스에서 필요한 애그리거트를 로딩하므로 성능이 최적화된다

<br>

# 아이디를 이용한 참조와 조회 성능

- 다른 애그리거트를 ID로 참조하면 참조하는 여러 애그리거트를 읽을 때 조회 속도가 문제될 수 있다
- 만약 여러건의 주문에 대해서 회원정보가 필요한 경우는 주문 수 만큼 회원정보의 쿼리가 발생한다
- 이러한 문제를 `N + 1` 문제라고 부르며 더 많은 쿼리를 실행하기 때문에 전체 조회 속도가 느려지는 원인이 된다
- 해결 방법의 경우는 데이터 조회를 위한 별도의 DAO를 만들고 해당 메소드에서 조인을 이용해서 한 번의 쿼리로 필요한 데이터를 로딩하면 된다
- 또한 쿼리가 복잡하거나 SQL에 특화된 기능을 사용해야된다면 로우 쿼리를 통해서 조회를 위한 부분만 다른 기술로 구현이 가능하다
- 애그리거트마다 서로 다른 저장소를 사용하면 조인 사용이 불가능한데, 이러한 문제를 해결하기 위해서 캐시를 적용하거나 조회전용 저장소를 따로 만들기도한다
