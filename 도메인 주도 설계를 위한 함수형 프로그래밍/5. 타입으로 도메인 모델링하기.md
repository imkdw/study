## 도메인 모델 속 패턴
### 단순값
- 빌딩 블록으로써 각 값은 문자열, 숫자 등 원시 타입을 갖게됨
- 하지만 도메인 전문가는 int, string이 아닌 OrderId, ProductId 같은 공용어로 생각함

<br>

### 값의 조합
- 밀접하게 연관된 데이터 그룹
- 종이 세계에서는 문서나 이름, 주소, 주문 등 문서 내 하위 요소에 해당함

<br>

### 선택
- 도메인에는 선택하는 것들이 존재함
- 예를 들면 주문 또는 견적, 단위 수량 또는 킬로그램 수량 등이 있음

<br>

### 작업 흐름
- 입/출력을 가지는 비즈니스 프로세스가 있음

<br>

## 단순값 모델링
- 도메인 전문가는 OrderId, ProductId 같은 공용어로 생각하는데 이 때 이 둘은 같은 타입을 가질 수 있음
- 그래서 OrderId, ProductId 2개는 호환되지 않도록 막는게 중요한데 이 때 원시 타입을 감싸는 래퍼 타입을 생성함
- Typescript의 경우는 구조적 호환을 막는 브랜드를 붙여서 래퍼 타입을 만듦

<br>

### 래퍼 타입 만들기
```ts
declare const customerId: unique symbol;
class CustomerId {
  [customerId]!: never;
  constructor(readonly value: string) {}
}

declare const widgetCode: unique symbol;
class WidgetCode {
  [widgetCode]!: never;
  constructor(readonly value: string) {}
}

declare const unitQuantity: unique symbol;
class UnitQuantity {
  [unitQuantity]!: never;
  constructor(readonly value: number) {}
}

declare const kilogramQuantity: unique symbol;
class KilogramQuantity {
  [kilogramQuantity]!: never;
  constructor(readonly value: number) {}
}
```

<br>

### 래퍼 타입 활용하기
- 일반적인 클래스의 인스턴스를 생성하는것과 동일하게 래퍼 타입 활용이 가능함
- 단순 타입을 생성하면 서로 다른 타입을 비교한다고 컴파일러에서 사전에 오류가 발생하므로 좋음
- 타입 안전성을 보장하는 좋은 방법이지만 메모리를 더 사용하고 성능은 낮아짐

```ts
import { CustomerId, OrderId } from "./node.js";

const customerId = new CustomerId("123");
const orderId = new OrderId("456");

// This comparison appears to be unintentional because the types 'CustomerId' and 'OrderId' have no overlap.
console.log(customerId === orderId);
```

<br>

### 단순 타입의 성능 문제 완화하기
- 단순 타입 대신 타입 별칭을 통해서 도메인 문서화가 가능함
- 단 이 방법은 성능은 부담이 없지만 타입 안전성을 포기하게됨
- 만약 타입스크립트로 큰 배열을 다룬다면 단순 타입 배열 대신 원시 타입 배열 잔체를 단일 타입으로 정의가 가능함
- 이러면 원시 데이터를 효율적으로 처리가 가능하고 타입 안전성도 유지가 가능함

```ts
declare const unitQuantities: unique symbol;
export class UnitQuantities {
  [unitQuantities]!: never;
  constructor(readonly value: number[]) {}
}

const unitQuantities = new UnitQuantities([1, 2, 3]);
```

<br>

## 복잡한 데이터 모델링
### 레코드 모델링
- 주문에는 사용자 정보, 배송지, 결제정보 등 다양한 데이터가 AND로 되어있음
- 예를 들어 ShippingAddress, BillingAddress 등 애매할때는 도메인 전문가에게 도움을 요청하는게 좋음
- 전문가들이 청구지 주소랑 배송지 주소를 다르게 취급한다면 구조가 동일해서 이들을 구분하는게 좋음

<br>

### 잘 모르는 타입 모델링
- 디자인 초기 단계에서는 일부 모델링 질문에 명확하게 답하지 못하는 상황이 있을수도있음
- 이런 경우 `Undefined`라는 타입을 정의해서 사용하는데 이는 공집합에 별칭을 붙이는 방법임

```ts
type Undefined = never;

type CustomerInfo = Undefined;
type ShippingAddress = Undefined;
type BillingAddress = Undefined;
type OrderLine = Undefined;
type BillingAmount = Undefined;

class Order {
  constructor(
    private readonly customerInfo: CustomerInfo,
    private readonly shippingAddress: ShippingAddress,
    private readonly billingAddress: BillingAddress,
    private readonly orderLines: OrderLine[],
    private readonly billingAmount: BillingAmount
  );
}
```

<br>

### 선택 타입 모델링
- 도메인에는 또 다양한 선택지가 많이 존재함
- `|` 연산자를 통해서 나타낼 수 있음

```ts
type ProductCode = WidgetCode | GimzoCode;
type OrderQuantity = UnitQuantity | KilogramQuantity;
```

<br>

## 함수로 작업 흐름 모델링하기
- 작업 흐름은 어떻게 처리하는지에 대한 명세임
- 만약 주문 양식을 검증하는 작업 흐름 단계를 가지고 있다면 아래 처럼 문서화가 가능함

```ts
/**
 * 주문 양식 검증
 * @param i 검증할 주문 양식
 * @return 검증된 주문
 */
type ValidateOrder = (i: UnvalidatedOrder) => ValidatedOrder;
```

<br>

### 복잡한 입력 처리하기
- 함수형 프로그래밍에서 함수는 하나의 입력과 하나의 출력만 가질 수 있음
- 하지만 일부 작업 흐름은 여러 입력과 출력을 가질 수 있음
- 만약 흐름의 출력이 outputA, outputB가 있다면 이를 하나의 레코드로 만들 수 있음

```ts
class PlaceOrderEvents {
  constructor(
    private readonly acknowledgmentSend: AcknowledgmentSend,
    orderPlaced: OrderPlaced,
    billableOrderPlaced: BillableOrderPlaced
  ) {}
}

type PlaceOrder = (i: UnvalidatedOrder) => PlaceOrderEvents;
```

```ts
declare const envelopeContents: unique symbol;
class EnvelopeContents {
  [envelopeContents]!: never;
  constructor(readonly value: string) {}
}
type CategorizedMail = QuoteForm | OrderForm;
type CategorizeInboundMail = (i: EnvelopeContents) => CategorizedMail;
```

<br>

### 복잡한 출력 처리하기
- 가장 간단한 방법은 각 입력들을 매개변수로 전달하는 것임
- 또 다른 방법은 여러 입력들을 모두 포함하는 새로운 레코드를 매개변수로 전달하는것임
- 만약 ProductCatalog가 실제 입력이 아닌 의존이라면 별도의 매개변수로 전달하는게 좋음. 이는 함수형 프로그래밍에서 의존 주입과 같은 역할을 하게됨
- 만약 두 입력이 항상 필요하고 서로 밀접하게 관련되어 있다면 레코드로 명확하게 나타내는 것이 좋음

```ts
// 각 입력들을 매개변수로 전달하기
type CalculatePrices = (i: OrderForm) => (j: ProductCatalog) => PricedOrder;

// 여러 입력들을 모두 포함하는 새로운 레코드를 매개변수로 전달하기
class CalculatePricesInput {
  constructor(
    private readonly orderForm: ORderForm,
    private readonly productCatalog: ProductCatalog
  )
}
type CalculatePrices = (i: CalculatePricesInput) => PricedOrder;
```

<br>

### 함수 시그니처에서 효과 문서화하기
- `효과(effect)`는 함수가 기본 출력 외 수행하는 다른 작업을 말함
- fp-ts의 `Either`로 ValidateOrder 함수가 오류 효과가 생길 수 있음을 드러낼 수 있음
- fp-ts의 `Task`로 비동기(Promise) 효과를 나타낼 수 있음

```ts
/**
 * 성공 -> Right(ValidatedOrder)
 * 실패 -> Left(ValidationError[])
 */
type ValidateOrder = (i: UnvalidatedOrder) => Either<ValidationError[], ValidatedOrder>;

/**
 * 비동기 작업이 포함된 함수
 */
type ValidateOrder = (i: UnvalidatedOrder) => Task<Either<ValidationError[], ValidatedOrder>>;
```

<br>

## 정체성에 관하여 : 값 객체
- DDD에선 값이 변해도 정체성을 지속하는 데이터를 `엔티티`라고 부르고, 정체성이 없는 데이터를 `값 객체`라고 부름
- 대부분의 경우 다루는 데이터 객체는 정체성이 없고 서로 교환이 가능함`

```ts
class WidgetCode {
  private readonly __brand!: void;
  constructor(readonly value: string) {}
}

const widgetCode1 = new WidgetCode("WIDGET-1");
const widgetCode2 = new WidgetCode("WIDGET-1");
assert.deepEqual(widgetCode1, widgetCode2);
```

<br>

### 값 객체의 같음
- 코틀린의 경우 `data class`를 사용하면 내부적으로 hashCode, equals 메소드를 자동으로 생성해줌
- 하지만 TS의 경우 이런게 없어서 별도의 추상 클래스를 통해서 구현이 가능함

```ts
interface Equatable {
  equals(obj: unknown): boolean;
}

abstract class ValueObject implements Equatable {
  equals(obj: unknown): boolean {
    try {
      assert.deepStrictEqual(this, obj);
      return true;
    } catch {
      return false;
    }
  }
}

class Class1 extends ValueObject {
  constructor(readonly v1: number, readonly v2: string) {
    super();
  }
}

const obj1 = new Class1(1, "a");
const obj2 = new Class1(1, "a");
console.log(obj1.equals(obj2));
```

<br>

## 정체성에 관하여 : 엔티티
- 고유한 정체성을 지닌 모델링을 종종 모델링하게됨
- 고유한 정체성이란 구성 요소가 변하더라도 동일한 대상으로 인식한다는 뜻임
- 이들은 생애 주기를 가지며 다양한 비즈니스 프로세스에 의해 한 상태에서 다른 상태로 변해감

<br>

### 엔티티의 ID
- DB의 auto_increment, uuid, 현실 세계의 도메인에서 ID 제공 등 다양한 방법으로 사용함

```ts
class ContactId {
  private readonly __brand!: void;
  constructor(readonly value: string) {}
}

class Contact {
  constructor(contactId: ContactId) {}
}
```

<br>

### 데이터 정의에 ID 포함하기
- 선택 타입의 경우에는 각 선택 타입 내부에 아이디를 포함하는게 더 일반적임
- 이런 방식은 패턴 매칭을 하고 나서 ID를 퐇마한 모든 데이터에 접근이 가능하다는 이점이 있음

```ts
class InvoiceId {
  private readonly __brand!: void;
  constructor(readonly value: string) {}
}

class UnpaidInvoice {
  constructor(readonly id: InvoiceId) {}
}

class PaidInvoice {
  constructor(readonly id: InvoiceId) {}
}

const invoice = new PaidInvoice(new InvoiceId("123"));

// paid
match(invoice)
  .with(P.instanceOf(PaidInvoice), () => console.log("paid"))
  .with(P.instanceOf(UnpaidInvoice), () => console.log("unpaid"))
  .exhaustive();
```

<br>

### 엔티티의 같음
- 엔티티가 같은지 확인하기 위해서는 오직 ID만 비교해야함

```ts
interface Equatable {
  equals(obj: unknown): boolean;
}

abstract class ValueObject implements Equatable {
  equals(obj: unknown): boolean {
    try {
      assert.deepStrictEqual(this, obj);
      return true;
    } catch {
      return false;
    }
  }
}

class ContactId extends ValueObject {
  private readonly __brand!: void;
  constructor(readonly value: string) {
    super();
  }

  equals(obj: unknown): boolean {
    return super.equals(obj);
  }
}

type RawId = string | number | bigint;

export abstract class Entity<Id extends RawId | ValueObject> implements Equatable {
  abstract readonly id: Id;
  protected abstract isSameClass<T extends Entity<Id>>(obj: unknown): obj is T;

  equals(obj: unknown): boolean {
    if (!this.isSameClass(obj)) {
      return false;
    }

    const otherId = (obj as Entity<Id>).id;

    return this.id instanceof ValueObject ? this.id.equals(otherId) : this.id === otherId;
  }
}

class Contact extends Entity<ContactId> {
  constructor(
    private readonly contactId: ContactId,
    private readonly phoneNumber: PhoneNumber,
    private readonly emailAddress: EmailAddress
  ) {
    super();
  }

  get id(): ContactId {
    return this.contactId;
  }

  protected isSameClass<T extends Entity<ContactId>>(obj: unknown): obj is T {
    return obj instanceof Contact;
  }
}

const contactId1 = new ContactId("123");
const contactId2 = new ContactId("124");

const contact1 = new Contact(contactId1, new PhoneNumber("123"), new EmailAddress("test123@example.com"));
const contact2 = new Contact(contactId1, new PhoneNumber("123"), new EmailAddress("test@example.com"));
console.log(contact1.equals(contact2)); // true

const contact3 = new Contact(contactId1, new PhoneNumber("123"), new EmailAddress("test@example.com"));
const contact4 = new Contact(contactId2, new PhoneNumber("123"), new EmailAddress("test123@example.com"));
console.log(contact3.equals(contact4)); // false
```

<br>

### 불변성과 정체성
