## PG의 인덱스
- PG는 B*Tree 인덱스 외에도 다양한 인덱스를 제공함
- BRIN, GIN, GiST 등이 존재함

<br>

## 인덱스 생성
> create (unique) index <index_name> on <schema_name>.<table_name> (column_name);
- PG는 B*Tree 인덱스를 3가지 방법으로 생성이 가능함
- `create (unique) index`
  - 기본적인 인덱스 생성 방법
- `create (unique) index ... include(column_name)`
  - 커버링 인덱스를 통해서 테이블 랜덤 엑세스를 제거하기 위해서 사용함
  - include 절에 지정된 컬럼은 인덱스에는 포함되지만, 검색 조건에는 사용되지 않음
- `create (unique) index ... where (condition)`
  - 위 방식으로 생성되는 인덱스를 `partial index`라고 부름
  - 조건에 해당하는 레코드만 인덱스에 포함시킴
  - 데이터 분포도 차이가 큰 컬럼이나 복잡한 조건이 포함된 쿼리의 성능을 개선할 때 사용이 가능함

<br>

## CIC (Create Index Concurrently) 옵션
- DB 운영중에 쿼리 성능 개선을 위해서 인덱스를 생성하는 경우가 많음
- 인덱스 생성시 다른 트랜잭션과 락 충돌때문에 락 대기 현상이 발생함
- 대부분의 DB는 온라인 기능을 제공하는데 이는 트랜잭션 수행과 무관하게 인덱스를 생성할 수 있는 기능임
- PG에서는 `CONCURRENTLY` 옵션을 통해서 온라인 기능을 지원함

<br>

### 단점 1. 일반 인덱스 생성 방식에 비해 속도가 느림
- CIC 옵션을 사용하면 테이블을 두 번 스캔함
- 만약 스캔 중에 트랜잭션이 진행중인 레코드가 있다면 해당 트랜잭션이 종료될 때 까지 작업을 중단했다가 끝나면 다시 재개함
- 그래서 트랜잭션이 빈번하게 발생하는 테이블에 CIC 옵션을 사용하면 일반적인 방식에 비해서 인덱스 생성 속도가 느림
- 하지만 락 경합 문제를 회피할 수 있다는 장점에 비하면 상대적으로 사소한 단점임

<br>

#### 테이블을 두 번 스캔하는 이유
- 첫 스캔에서는 테이블의 레코드를 읽어서 정렬하고 이를 인덱스 트리 구조에 입력함. 이는 CIC 없이해도 동일함
- CIC 옵션은 인덱스 생성 도중에도 다른 트랜잭션을 허용하므로 처음 스캔시 반영되지 않은 레코드가 존재할 수 있음
- 두번째 스캔에서는 반영되지 안ㄹ은 레코드를 인덱스에 반영시킴

<br>

### 단점 2. INVALID 상태의 인덱스가 생성될 수 있음
- CIC 옵션을 사용하면 인덱스 메타 정보가 시스템 카탈로그에 등록되는데 이때 인덱스의 상태는 `INVALID`임
- 인덱스 생성이 완료되면 상태를 `VALID`로 변경하게됨
- 만약 중간에 작업이 종료되거나 유니크 인덱스를 생성할 떄 중복값에 의해서 오류가 발생하면 `INVALID` 상태로 남음
- `INVALID` 상태의 인덱스는 쿼리 수행에 활용되지 못하며 디스크 공간을 차지하고 DML 작업시에도 반영이 안됨
- CIC를 통해서 인덱스를 생성하는 경우 생성 후 꼮 인덱스의 상태 확인이 필요함

<br>

#### 인덱스 생성 도중 취소시 발생하는 문제 재현
```sql
-- 데이터 준비
postgres=# create table svc.t1 (c1 integer, c2 varchar(10));
postgres=# insert into svc.t1 select i, 'N' from generate_series(1, 10000000) i;
postgres=# \dt+ svc.t1
                                   List of relations
 Schema | Name | Type  |  Owner   | Persistence | Access method |  Size  | Description 
--------+------+-------+----------+-------------+---------------+--------+-------------
 svc    | t1   | table | postgres | permanent   | heap          | 346 MB | 
(1 row)


-- 인덱스 생성도중 취소 요청
postgres=# create index concurrently t1_n1 on svc.t1(c1);
^CCancel request sent
ERROR:  canceling statement due to user request


-- 테이블 정보 확인
postgres=# \d+ svc.t1;
 Column |         Type          | Collation | Nullable | Default | Storage  | Compression | Stats target | Description 
--------+-----------------------+-----------+----------+---------+----------+-------------+--------------+-------------
 c1     | integer               |           |          |         | plain    |             |              | 
 c2     | character varying(10) |           |          |         | extended |             |              | 
Indexes:
    "t1_n1" btree (c1) INVALID -- INVALID 상태의 인덱스가 생성된 모습
Access method: heap

-- 인덱스 확인, 42MB의 불필요한 인덱스가 생성된 모습
postgres=# \di+ svc.t1_n1;
 Schema | Name  | Type  |  Owner   | Table | Persistence | Access method | Size  | Description 
--------+-------+-------+----------+-------+-------------+---------------+-------+-------------
 svc    | t1_n1 | index | postgres | t1    | permanent   | btree         | 42 MB | 
(1 row)
```

<br>

#### 유니크 인덱스 생성 중 제약조건이 위배되는 경우 재현
```sql
-- 유니크 인덱스를 생성하는 도중에 새로운 레코드가 추가됨
-- 해당 레코드는 유니크 제약조건을 위배하는 레코드라서 인덱스 생성에 실패함
postgres=# create unique index concurrently t1_uk on svc.t1(c1);
ERROR:  duplicate key value violates unique constraint "t1_uk"
DETAIL:  Key (c1)=(1) already exists.


-- 테이블 정보 확인, INVALID 상태의 인덱스가 생성된 모습
postgres=# \d+ svc.t1;
                                                    Table "svc.t1"
 Column |         Type          | Collation | Nullable | Default | Storage  | Compression | Stats target | Description 
--------+-----------------------+-----------+----------+---------+----------+-------------+--------------+-------------
 c1     | integer               |           |          |         | plain    |             |              | 
 c2     | character varying(10) |           |          |         | extended |             |              | 
Indexes:
    "t1_uk" UNIQUE, btree (c1) INVALID
Access method: heap


-- 인덱스 확인, 214MB의 불필요한 인덱스가 생성된 모습
postgres=# \di+ svc.t1_uk
                                       List of relations
 Schema | Name  | Type  |  Owner   | Table | Persistence | Access method |  Size  | Description 
--------+-------+-------+----------+-------+-------------+---------------+--------+-------------
 svc    | t1_uk | index | postgres | t1    | permanent   | btree         | 214 MB | 
(1 row)
```

<br>

### 단점 3. 인덱스 생성이 지연되는 현상이 발생할 수 있음
- CIC 옵션을 사용하면 테이블 스캔이 2번 발생하는데 만약 두 번쨰 스캔 이전에 실행된 쿼리가 인덱스 생성 완료 시점까지도 수행중이라면 인덱스 생성을 오나료하지 못하고 해당 쿼리의 종료를 대기하게됨
- 해당 쿼리가 인덱스 대상 테이블을 엑세스하지 않더라도 CIC 옵션으로 인덱스를 생성하는 세션은 락 대기를 한다는 점에 유의해야함
- CIC 옵션을 사용할때는 세션 및 인덱스 진행 상황을 모니터링할 필요가 있음
- CIC 옵션을 사용한 인덱스 생성 작업은 테이블 당 한번에 하나만 가능하다

<br>

#### 장시간 실행되는 쿼리로 인한 락 대기 재현
```sql
-- 다른 세션에서 사전에 블록킹 쿼리 실행
postgres=# select pg_sleep(100000000); -- 100000000만큼 계속 실행함..

-- 인덱스 생성
postgres=# create index concurrently t1_n1 on svc.t1(c1); -- 계속 진행중

-- 락 대기 정보 확인
-[ RECORD 1 ]--+-----------------------------------------------
blocked_pid    | 5998
blocked_user   | postgres
blocking_pid   | 6014
blocking_user  | postgres
blocking_query | select pg_sleep(100000000);
blocked_query  | create index concurrently t1_n1 on svc.t1(c1);
```

<br>

## 인덱스 리빌드
- `VACUUM FULL` 명령어를 수행하면 `인덱스 블로팅` 문제도 해결된다
- 하지만 `VACUUM FULL` 명령어는 온라인 기능을 지원하지 않아서 작업을 주기적으로 할 수 없다면 인덱스 리빌드가 필요하다
- 인덱스 리빌드 작업은 조건부로 수행이 가능하며 CONCURRENTLY 옵션을 통해서 온라인으로도 가능하다

<br>

### 리빌드시 CIC에 대한 차이점
- CIC를 사용하면 내부적으로 작업용 인덱스인 `_ccnew`라는 인덱스가 생긴다
- 기존 인덱스는 그대로 유지하고 별도의 작업용 인덱스를 생성하고 리빌드 작업을 수행한다음 완료되면 교체히는 방식이다
- 하지만 CIC를 사용해서 리빌드 도중에 비정상적으로 종료된다면 인덱스가 `INVALID` 상태로 남는다

<br>

### 임시 인덱스인 `_ccnew` 인덱스 확인하기
```sql
-- 인덱스 리빌드 실행
postgres=# reindex index concurrently svc.t1_n1;
REINDEX

-- 테이블 정보 확인, 임시 인덱스인 `_ccnew` 인덱스가 생성된 모습
postgres=# \d svc.t1;
                         Table "svc.t1"
 Column |         Type          | Collation | Nullable | Default 
--------+-----------------------+-----------+----------+---------
 c1     | integer               |           |          | 
 c2     | character varying(10) |           |          | 
Indexes:
    "t1_n1" btree (c1)
    "t1_n1_ccnew" btree (c1) INVALID

postgres=# 
```

<br>

## 인덱스 관리 명령어
### 인덱스 이름 변경
```sql
-- 테이블 정보 확인, 인덱스 이름이 `t1_n1`인 모습
postgres=# \d svc.t1;
                         Table "svc.t1"
 Column |         Type          | Collation | Nullable | Default 
--------+-----------------------+-----------+----------+---------
 c1     | integer               |           |          | 
 c2     | character varying(10) |           |          | 
Indexes:
    "t1_n1" btree (c1)


-- 인덱스 이름 변경
postgres=# alter index svc.t1_n1 rename to t1_idx1;


-- 테이블 정보 확인, 인덱스 이름이 `t1_idx1`로 변경된 모습
postgres=# \d svc.t1;
                         Table "svc.t1"
 Column |         Type          | Collation | Nullable | Default 
--------+-----------------------+-----------+----------+---------
 c1     | integer               |           |          | 
 c2     | character varying(10) |           |          | 
Indexes:
    "t1_idx1" btree (c1)

postgres=# 
```

<br>

### 인덱스 구성 컬럼 변경 후 중복 인덱스 삭제시 주의사항
- 운영 환경에서 인덱스를 삭제하는 경우는 반드시 CIC 옵션을 사용해야함
- 기존 인덱스를 참조 중인 쿼리가 수행되고 있는 경우 인덱스 삭제 명령을 수행한 세션은 락을 대기함
- CIC 옵션을 통해서 인덱스를 제거하고 인덱스 명을 변경하는게 좋음

```sql
-- 테이블 정보 확인, 인덱스 구성 컬럼이 `c1`과 `c2`인 모습
-- 이 때 c1 컬럼의 경우 중복되므로 삭제 대상이 됨
postgres=# \d svc.t1;
                         Table "svc.t1"
 Column |         Type          | Collation | Nullable | Default 
--------+-----------------------+-----------+----------+---------
 c1     | integer               |           |          | 
 c2     | character varying(10) |           |          | 
Indexes:
    "t1_idx1" btree (c1)
    "t1_n1_new" btree (c1, c2)


-- CIC 옵션을 통한 인덱스 삭제
postgres=# drop index concurrently svc.t1_idx1;


-- 인덱스 명 변경
postgres=# alter index svc.t1_n1_new rename to t1_n1;
postgres=# \d svc.t1;
                         Table "svc.t1"
 Column |         Type          | Collation | Nullable | Default 
--------+-----------------------+-----------+----------+---------
 c1     | integer               |           |          | 
 c2     | character varying(10) |           |          | 
Indexes:
    "t1_n1" btree (c1, c2)

postgres=# 
```
