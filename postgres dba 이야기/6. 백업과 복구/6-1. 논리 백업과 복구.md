## 논리 백업과 복구
- 논리 백업은 물리 백업과 달리 완전한 복구 기능을 제공하지 않는다
- 물리 백업의 경우 아카이브 파일을 사용해서 장애 복구 시점까지 복구하지만 논리 백업은 그렇지 않음
- 논리 백업은 백업 시점의 데이터를 복원하는 용도로 사용하며 복구보다는 데이터 보관 및 이행 목적으로 활용됨

<br>

## `pg_dumpall`을 이용한 백업
- 디비 클러스터 내 모든 디비와 관련 정보를 한꺼번에 백업할 수 있는 기능을 제공함
- 다수의 디비가 존재하는경우 편하게 사용이 가능하지만 압축 및 병렬 백업 기능을 제공하지 않는다는 단점이 존재함
- 보통 논리 복제 구성 시 디비 클러스터 내의 모든 형상 정보랑 Role 정보를 백업하는 데 사용함

<br>

### 디비 생성 스크립트 백업 방법
- 오브젝트 생성 스크립트만 백업하는 경우는 -s 옵션을 통해서 처리한다
- 데이터는 백업하지 않고 오직 오브젝트 생성 스크립트만 백업하게된다
- 만약 롤 정보만 별도로 백업시에는 -r 옵션을 사용해서 백업이 가능함

```bash
# 백업하기
postgres@dff5953eda06:~$ pg_dumpall -s -f database_cluter.sql

# 백업된 내용(일부)
postgres@dff5953eda06:~$ cat database_cluter.sql 
--
-- PostgreSQL database cluster dump
--

\restrict 20oNDqKWrhn61x3x1nCkPCObKk4v5UQzkhz8CqPVqdwGcPTtUfLo0gBC6t1aRuI

SET default_transaction_read_only = off;

SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;

--
-- Roles
--

CREATE ROLE postgres;
ALTER ROLE postgres WITH SUPERUSER INHERIT CREATEROLE CREATEDB LOGIN REPLICATION BYPASSRLS PASSWORD 'SCRAM-SHA-256$4096:cO+li3tJ6XS31V/66AKoxA==$Y17MutUr7UT5I3kWenXkTK4GNJhP3AZTt25tSDgroUM=:6tx6NXtNi6FCEkK6vSg/cNoQkQJGpoQ9D3n1ofVgwH4=';
```


<br>

### 디비 클러스터 형상 복원 방법
- 백업 파일을 사용해서 클러스터 전체 형상을 복원할 때는 psql 명령어를 사용함
- 마찬가지로 롤만 백업받은 경우도 psql 통해서 진행한다

```bash
# 복원하기
postgres@dff5953eda06:~$ psql -f database_cluster.sql 
SET
SET
SET
psql:database_cluster.sql:16: ERROR:  role "postgres" already exists
ALTER ROLE
You are now connected to database "template1" as user "postgres".
SET
SET
SET
SET
SET
SET
 set_config 
```

<br>

## pg_dump를 이용한 백업
- 개발 환경의 디비 백업이나 디비 및 스키마 단위의 이행 업무에 자주 사용함
- 사용 범위가 넓고 사용 빈도도 높아서 다양한 실무 상황에 맞춰 활용할 수 있도록 여러 옵션을 제공함
- 압축과 병렬 처리 기능도 제공하므로 대용량 데이터의 백업 작업에 유용하게 활용이 가능함

<br>

### Format 옵션
- `-F` 옵션을 통해서 파일 포맷 지정이 가능하며 기본값은 `p(plain)` 이다
- `p(plain)`, `c(custom)`, `d(directory)`, `t(tar)` 4가지 포맷을 지원한다

<br>

#### p(plain) 옵션
- 압축과 부분 복구 기능을 지원하지 않기 때문에 복구 목적의 백업에는 거의 사용하지 않음
- 대신 디비 또는 스키마 단위의 오브젝트 생성 스크립트를 백업하는 용도로 활용함
- 만약 svcdb 디비의 svc 스키마에 포함된 모든 오브젝트의 생성 스크립트를 백업한다면 아래처럼 쓴다
  - `pg_dump -Fp -d svcdb -n svc -s -f svc_schema.sql`

<br>

#### c(custom), d(directory) 옵션
- 압축과 부분 복구를 모두 지원해서 개발 디비 데이터 백업 용도로 자주 사용함
- `c(custom)`의 경우는 하나의 파일로 백업본이 저장되며, `d(directory)`의 경우 여러 파일로 분할이 가능하다
- 백업 속도가 중요하다면 d 포맷, 관리가 편하고 싶다면 c 포맷을 사용하는게 일반적이다

#### t(tar) 옵션
- 백업 데이터를 TAR 파일로 묶어서 저장한다
- 하지만 압축을 지원하지 않아서 활용도가 낮은편이다

<br>

### 압축 옵션
- `pg_dump`의 경우 `-Z` 옵션을 통해서 압축 방식을 지정하며 `gzip`, `lz4` 2가지를 지원한다
- gzip : 0 ~ 9까지 지원하며 레벨이 높아질수록 백업 파일 크기는 줄어들지만 압축 시간이 오래걸림
- lz4 : 0 ~ 12까지 지원하며 16 버전부터 사용이 가능하다
- 어떻게 사용할지는 시스템 환경과 데이터 특성에 따라서 차이가 있을 수 있으므로 직접 테스트해보고 찾아야한다

<br>

### 병렬 처리 옵션
- 병렬 처리를 위해서는 `-j` 옵션을 사용하는데 이는 `d(directory)` 포맷을 사용할때만 가능하다
- 병렬로 데이터를 백업하는 워커 프로세스의 개수를 지정하는데 CPU 코어 or 디스크 I/O에 따라서 달라질 수 있다
- 이것도 마찬가지로 직접 테스트해보고 적절한 값을 찾는게 좋다

<br>

## `psql`과 `pg_restore`를 이용한 복원
### 스키마 형상을 타 디비에 적용하는 방법
- 개발 단계에서는 테이블 구조가 수시로 바뀌는데 현 시점의 스키마를 다른 디비에 반영할 일이 생긴다
- 다양한 방법이 있지만 아래 방법이 효율이 좋다
- 개발 디비에서 `pg_dump`를 통해서 스키마 형상을 백업함
  - `pg_dump -Fp -n svc -s -f svc_schema.sql`
- 이행 대상 디비에서 기존 스키마 제거
  - `psql -d svcdb_mig`
- 백업한 스키마를 psql을 이용해서 적용
  - `psql -d svcdb_mig -f svc_schema.sql`

<br>

### 스키마 형상 및 데이터를 타 데이터베이스에 적용하는 방법
- 위 절차와 거의 동일하지만 데이터 포함이 필요하므로 `-Fc` 또는 `-Fd`를 사용해서 백업하는게 유리하다
- `-Fc`, `-Z1` 옵션을 통해서 스키마 형상 및 데이터를 함께 백업하게된다
  - `pg_dump -Fc -Z1 -n svc -f svc_schema_data.custom`
- 위랑 기존 스키마를 삭제한다
  - `psql -d svc`
- `-Fc`로 백업한 경우 파일은 바이너리 포맷이므로 복원 시 `pg_restore`를 사용해서 복원해야한다
  - `pg_restore -d svcdb_mig -v svc_schema_data.custom`
- 만약 백업 파일의 크기가 크거나 오브젝트수가 많으면 `-j` 옵션인 병렬처리를 통해서 속도를 높일 수 있다
  - `pg_restore -d svcdb_mig -v -j <worker> svc_schema_data.custom`

<br>

## `pg_restore`를 이용한 복구
### 특정 테이블 복구
- 일 단위로 아래처럼 디비 전체를 custom 포맷으로 백업한다고 가정한다
  - `pg_dump -Fc -Z1 -f svcdb_full_20251104.custom`
- t1 테이블에 대한 복구가 필요한 경우 아래처럼 복구하게된다
  - `pg_restore -d svcdb -v -n svc -t t1 svcdb_full_20251104.custom`
- 이 때 데이터가 잘못된 경우는 전부 날리고 복구하면 되는데 pg_restore의 경우 기본적으로 테이블 생성 -> 데이터 입력 방식으로 동작하므로 이미 테이블이 존재하는 경우 에러가 출력되므로 `-a` 옵션을 활용하면 된다

<br>

### 테이블 복구시 -c 옵션의 위험성
- `pg_restore` 명령에서 `-c` 옵션을 적용하면 기존에 존재하는 테이블을 DROP하고 다시 생성하는 방식으로 동작한다
- 하지만 기존에 설정된 제약조건, 인덱스, PK 등은 복구가 안되므로 테이블 단위의 복구 작업시 -c 옵션 사용에 신중해야한다

<br>

## COPY
- PG는 `COPY` 명령을 통한 테이블 단위 데이터 추출 및 적재 기능을 제공한다
- 이 명령어의 가장 큰 장점은 유연한 데이터 추출이 가능하다는 점에 있다

<br>

### COPY 명령어 종류
- psql을 통해서 DB에 접속한 상태에서 수행하며 `\COPY` or `COPY`를 통해서 명령어 실행이 가능하다
- 일반적으로는 유저가 접근할 수 있는 경로에있는 파일을 읽거나 쓸 수 있고 권한 설정이 불필요한 `\copy`를 사용한다

<br>

### 데이터 추출 및 적재
- 구분자는 한 글자만 지정이 가능하고 덤프 파일의 컬럼 구성을 쉽게 확인할려면 header 옵션을 함께 사용하는게 좋다
- 구분자는 헥사 코드 형태로도 지정이 가능한데 탭 문자의 경우 `E'\x09'` 처럼 표기가 가능하다

```sql
-- 테이블 생성
postgres=# create table svc.t1 ( c1 integer, c2 varchar(10), c3 varchar(10), c4 integer );

-- 데이터 생성, 구분자는 | 다 
postgres=# insert into svc.t1 values (1, 'A|B', 'C|D', 1);
postgres=# select * from svc.t1;
 c1 | c2  | c3  | c4 
----+-----+-----+----
  1 | A|B | C|D |  1

-- \copy를 통해서 t1.csv로 추출한다. 이 때 구분자는 | 이다
postgres=# \copy svc.t1 to 't1.csv' with (format csv, delimiter '|', header);

-- 백업이 된 모습
postgres=# \! cat t1.csv;
c1|c2|c3|c4
1|"A|B"|"C|D"|1

-- csv -> table 복원을 위해 동일한 구조를 가진 테이블 생성
postgres=# create table svc.t1_bak ( c1 integer, c2 varchar(10), c3 varchar(10), c4 integer );

-- t1.csv -> svc.t1_bak 테이블로 복원
postgres=# \copy svc.t1_bak from 't1.csv' with (format csv, delimiter '|', header);

-- 복원된 모습
postgres=# select * from svc.t1_bak;
 c1 | c2  | c3  | c4 
----+-----+-----+----
  1 | A|B | C|D |  1
```

<br>

### 쿼리 결과 추출 기능
- 테이블 전체가 아닌 특정 쿼리 결과를 추출하는 기능도 제공함
- 정제된 데이터를 외부로 내보낼 때 유용하지만 COPY 명령어의 경우 반드시 한 줄로 입력해야 한다는 제약이 있음
- 만약 쿼리문이 긴 경우는 View를 생성하고 해당 뷰를 이용해서 추출 작업을 하는게 효율적임

```sql
-- 2건의 데이터가 존재함
postgres=# select * from svc.t1;
 c1 | c2  | c3  | c4 
----+-----+-----+----
  1 | A|B | C|D |  1
  2 | A|B | C|D |  2

-- 쿼리 결과를 csv로 추출
postgres=# \copy (select * from svc.t1 where c1 = 1) to './query_result.csv' with (format csv, delimiter '|', header);

-- 추출된 모습
postgres=# \! cat query_result.csv
c1|c2|c3|c4
1|"A|B"|"C|D"|1
```

<br>

### 에러 처리 기능
- PG 17 버전부터는 COPY 명령어에 에러 처리 기능이 추가되어서 덤프 파일 내부에 에러를 유발하는 레코드 식별 & 무시가 가능함
- `on_error ignore` 및 `log_verbosity` 옵션을 통해서 문제 해결이가능함
- `on_error ignore` : 오류가 발생한 레코드는 생략한다
- `log_verbosity` : 오류 발생 라인을 로그로 출력한다

```sql
postgres=# \copy svc.t1 from './asis_t1.csv' with (on_error ignore, log_verbosity verbose, format csv, delimiter '|', header);
```
