## 논리 복제
- WAL 파일을 사용한다는 점에서는 물리 복제와 동일함
- 하지만 논리 복제는 WAL 파일 내부 내용을 분석해서 DML 쿼리를 생성해서 전달하는 방식임
- 이 과정을 `Logical Encoding`이라고 부르며 이러한 구조 덕분에 다른 버전에서도 잘 작동함

<br>

## 논리 복제 구성
### 초기 데이터 구성
```sql
postgres=# create schema svc;
postgres=# create table svc.t1 (c1 integer, c2 integer, constraint t1_pk primary key(c1));
postgres=# create table svc.t2 (c1 integer, c2 integer, constraint t2_pk primary key(c1));
postgres=# insert into svc.t1 select i, i from generate_series(1, 10) i;
postgres=# insert into svc.t2 select i, i from generate_series(1, 10) i;
```

<br>

### 발행자 서버 파라미터 설정 변경
- 논리 복제 환경을 구성하기 위해서 제일 먼저 할것들은 파라미터 설정임
- `wal_level`, `max_wal_senders` 등 일부 파라미터 설정 변경이 필요함
- `wal_level` : WAL 파일 내에 Logical Encoding 정보를 포함해야되서 해당 값을 `logical`로 설정

```sql
ALTER SYSTEM SET wal_level = 'logical';
```

<br>

### 발행자(Publication) 생성
- 생성은 슈퍼유저 권한을 가진 `postgres` 유저로 진행함
- DB 내 전체 테이블, 특정 스키마 내 테이블 등 다양한 범위로 발행자 지정이 가능함

```sql
-- 생성
postgres=# create publication pub_svc_tb1 for table svc.t1, svc.t2;

-- 발행자 목록 조회
postgres=# select pubname from pg_publication;

-- 발행자 테이블 목록 조회
postgres=# select * from pg_publication_tables;
   pubname   | schemaname | tablename | attnames | rowfilter 
-------------+------------+-----------+----------+-----------
 pub_svc_tb1 | svc        | t1        | {c1,c2}  | 
 pub_svc_tb1 | svc        | t2        | {c1,c2}  | 
```

<br>

### 발행자 전용 유저 생성
- 슈퍼유저를 사용해도 상관없으나 보안 측면을 고려한다면 전용 유저를 생성하는게 바람직함
- 해당 유저는 복제 작업을 수행하므로 `REPLICATION` 권한 부여가 필요한데 이게 있어야 구독 요청이 왔을때 `walsender` 프로세스 구동이 가능함
- 또한 유저에게는 특정 스키마의 모든 테이블 접근이나 Publication 대상 테이블 접근이 가능한 권한이 필요함

```sql
-- lglrep 유저 생성
postgres=# create user lglrep with password 'reppass' replication;

-- svc_rs 역할을 만들고 svc 스카마에 모든 권한을 부여
postgres=# CREATE ROLE svc_rs NOLOGIN;
postgres=# GRANT ALL PRIVILEGES ON SCHEMA svc TO svc_rs;
postgres=# GRANT SELECT ON svc.t1 TO lglrep;
postgres=# GRANT SELECT ON svc.t2 TO lglrep;

-- 생성한 유저에게 위에서 생성한 권한 부여
postgres=# GRANT svc_rs TO lglrep;
```

<br>

### 구독 서버에 스키마 및 테이블 생성
- 구독 서버의 경우 발행자 서버에서 설정한 대상 테이블과 테이블 이름, 컬럼 구성, 스키마 명이 모두 일치해야한다

```sql
-- 마스터 서버와 동일한 스키마 및 테이블 구조 생성
postgres=# create schema svc;
postgres=# create table svc.t1 (c1 integer, c2 integer, constraint t1_pk primary key(c1));
postgres=# create table svc.t2 (c1 integer, c2 integer, constraint t2_pk primary key(c1));

-- 구독 생성
postgres=# create subscription sub_svc_tb1 connection  'host=192.168.147.4 port=5432 dbname=postgres user=lglrep password=reppass' publication pub_svc_tb1;

-- 구독 목록 조회
postgres=# select subname from pg_subscription;
   subname   
-------------
 sub_svc_tb1
```

<br>

### 데이터가 복제된 모습 확인
```sql
postgres=# select count(*) from svc.t1;
 count 
-------
    10
(1 row)

postgres=# select count(*) from svc.t2;
 count 
-------
    10
(1 row)
```

<br>

### 슬롯 확인
- 논리 복제는 replication 슬롯을 기반으로 동작함
- pg_replication_slots 테이블을 조회해서 발생 서버에 생성된 두 개의 논리 복제용 슬롯 확인이 가능함
```sql
postgres=# select slot_name, slot_type from pg_replication_slots;
  slot_name  | slot_type 
-------------+-----------
 sub_svc_tb1 | logical
(1 row)
```

<br>

## 논리 복제 아키텍처와 동작 순서
- 발행자, 구독자 생성시에 다양한 옵션 지정이 가능한데 이런 옵션을 정확히 이해하고 있어야 제대로 활용이 가능함
- 논리 복제의 경우 물리 복제에 비해서 아키텍처가 더 복잡하고 slot, worker 등 새로운 개념이 포함된다

<br>

### 1단계
- 구독자가 생성되면 그 개수만큼 `apply worker` 프로세스가 기동된다
- 다양한 옵션 설정이 가능한데 `copy_data`의 경우 구독 시작시에 발행자 테이블의 복제 여부를 결정한다
  - 기본값은 true로 처음 구독자가 생성되면 발행자 테이블에 있는 모든 데이터를 초기에 복제하게된다
- 초기 데이터 복제를 담당하는 프로세스는 `tablesync worker`라고 부른다
  - 이는 복제 대상 테이블 수와 관계없이 최대 2개까지 기동되며 복제가 완료되면 자동으로 종료된다
- 리플리카 서버의 `max_sync_workers_per_subscription` 값을 수정해서 초기 데이터 복제를 빠르게 진행이 가능하다

<br>

### 2단계
- 논리 복제 요청을 받은 발행자가 있는 서버의 `logical replication launcher` 프로세스는 두 가지 유형의 walsender 프로세스를 기동한다
- 하나는 지속적인 데이터 변경 사항을 전달하기 위한 `walsender` 이다
- 또 다른 하나는 초기 데이터를 복제하기 위한 `walsender` 이다
- 해당 프로세스는 구독자 서버의 `apply worker` 및 `tablesync worker` 프로세스와 각각 통신하게된다

<br>

### 3단계
- 데이터 복제를 담당하는 `walsender` 프로세스는 발행자 테이블을 읽어서 COPY 방식으로 서버에 전달한다
  - 해당 과정에서 복제 진행 사황을 논리 복제 슬롯에 기록한다
- 일반적인 `walsender` 프로세스는 WAL 파일을 읽어서 논리 디코딩을 수행해서 변경된 내용을 구독 서버에 저장한다
  - 동일하게 진행 상황을 논리 복제 슬롯에 기록한다
- `pg_replication_slots`, `pg_stat_replication`, `pg_stat_activity` 테이블에서 확인이 가능하다

<br>

#### pg_replication_slots
- 현재 생성된 복제 슬롯과 슬롯 타입 확인이 가능함
- 복제 슬롯은 복제 수행 상태 및 진행 정보를 저장하는 메모리 구조체로 이해하면됨
- 구독자 1개당 1개의 슬롯을 생성하고, 초기 데이터를 복제하기 위한 임시 슬롯은 복제가 끝나면 자동으로 삭제됨
```sql
postgres=# select slot_name, slot_type from pg_replication_slots;
  slot_name  | slot_type 
-------------+-----------
 sub_svc_tb1 | logical
(1 row)
```

<br>

#### pg_stat_replication
- 현재 실행중인 walsender 프로세스 정보를 확인할 수 있음
```sql
postgres=# select pid, usename, application_name from pg_stat_replication where usena
me='lglrep' order by 3 desc;
 pid | usename | application_name 
-----+---------+------------------
  33 | lglrep  | sub_svc_tb1
(1 row)
```

<br>

#### pg_stat_activity
- 각 프로세스에서 실행중인 명령어를 보여줌
```sql
postgres=# select  pid, usename, application_name, left(query, 35) as query from pg_stat_activity where usename='lglrep';
 pid | usename | application_name |                query                
-----+---------+------------------+-------------------------------------
  33 | lglrep  | sub_svc_tb1      | START_REPLICATION SLOT "sub_svc_tb1
(1 row)
```

<br>

### 4단계
- 구독 서버의 `apply worker` 프로세스가 발행 서버로부터 전송 받은 논리 디코딩 결과를 디비에 저장함
- `tablesync worker` 프로세스는 COPY 명령어를 수신해서 해당 데이터를 디비에 적재함

<br>

## Publication 생성 옵션 및 설정 변경
### publish 옵션
- 복제 대상이 되는 SQL 명령 유형을 정의함
- 기본은 INSERT, UPDATE, DELETE, TRUNCATE다

<br>

### publish_via_partition_root 옵션
- 파티션 테이블에 대해서 발행자를 생성하면 기본적으로 자식 테이블 각각에 대한 변경 사항이 구독 서버로 전송됨
- 구독 서버에도 동일한 자식 테이블이 존재해야하는데 만약 구독 서버에는 일반 테이블이라면 true로 변경한다

<br>

### 적용 방법
- 발생자 생성 시점에 옵션 적용은 `WITH` 절을 사용, 이후에 바꿀려면 SET을 사용함

<br>

### 발행자 대상 테이블 변경
- `ALTER PUBLICATION` 명령어를 사용하고 추가(ADD), 삭제(DROP), 재설정(SET)이 가능함

<br>

#### 테이블 재설정 주의사항
- 과거에 잠깐 제거했던 svc.t1 테이블을 다시 추가하고 svc.t3 테이블을 제거한다고 가정한다
- 새롭게 발행 목록에 포함되었으므로 구독 서버에는 `REFRESH` 명령어를 수행해야한다
- 하지만 이미 svc.t1 테이블은 복제 이력이 있어서 `copy_data=true`인 경우 에러가 발생할 수 있다
- 이런 경우는 `copy_data=false`로 설정하고 초기 데이터를 복제하지 않고 `REFRESH`를 수행한다
- 하지만 그동안 입력된 데이터가 복제되지 않기때문에 데이터 누락이 발생할 수 있다
- 이런 상황에선 구독 서버 테이블을 초기화(TRUNCATE)하고 `copy_data=true`로 하는게 좋다

<br>

## 구독자 생성 옵션 및 설정 변경
### 적용 방법
- 발행자와 동일하게 생성시에는 `WITH` 절을 사용하고, 생성된 이후에는 `SET`을 사용한다

<br>

### streaming 옵션
- 논리 복제의 기본 동작은 트랜잭션이 완료되고나서 해당 변경 데이터를 논리 디코딩해서 구독 서버로 전달하는 구조다
- 즉 발행자 대상 테이블에 대량의 트랜잭션이 발생하면 복제 지연 시간이 길어질 수 있다. 이를 개선하기 위해 스트리밍 옵션이 있다
- 스트리밍 옵션을 사용하면 복제 지연 시간은 개선되지만 트랜잭션 처리 시간이 지연되는 단점이 존재한다

<br>

#### streaming=off
- 트랜잭션 완료 후에 변경 데이터를 논리 디코딩해서 구독 서버로 전달한다
- 그래서 트랜잭션 처리 과정에서 논리 복제의 영향을 받지 않으므로 트랜잭션 처리 시간이 지연되지 않는다

<br>

#### streaming=on/parallel
- 트랜잭션이 진행되는 중간에 논리 디코딩을 수행하고 그 결과를 구독 서버로 전달한 뒤에야 트랜잭션이 완료된다
- 논리 복제 처리 시간이 트랜잭션 수행 시간에 포함되므로 트랜잭션 성능이 저하될 수 있다
- 복제 지연 시간이 줄어들어 복제 성능에서는 우수하지만 트랜잭션 처리 성능에는 불리하다
- 어떤게 더 중요한지 결정하고 trade-off가 필요하며 일반적으로 운영환경에선 off로 설정한다

<br>

#### streaming=on/parallel 차이점
- on의 경우는 트랜잭션 진행 중에 논리 디코딩한 결과를 구독 서버의 Temp 파일에 저장한다
- 이후에 트랜잭션이 종료되면 구독 서버의 `Apply` 프로세스가 해당 파일을 읽어서 반영한다
- parallel의 경우는 Temp 파일 대신 병렬 프로세스 메모리에 변경 데이터를 저장한다
- 그래서 on 보다는 parallel 방식이 더 복제 성능이 우수하다

<br>

### synchronous_commit 
- 해당 값은 운영 환경이라면 활성화하지 않는 것이 권장된다
- 동기 커밋을 사용하는 경우는 대량 트랜잭션에 의해서 락 대기가 장기간 걸릴수도 있다
- 또한 구독 서버에 장애가 발생하는 경우는 모든 트랜잭션이 행 상태에 빠지는 심각한 문제가 발생한다

<br>

### 구독자 관련 주요 작업
- 주로 구독자 관련 작업으로는 중단, 재개, 에러발생 지점 스킵을 수행하게된다
- 중단의 경우 매우 간단하지만 중단 시점에 복제 지연이 발생하고 있다면 지연중인 레코드는 복제되지 않는 문제가 있다
- 에러 발생지점 스킵의 경우 대표적으로 양쪽에 동일한 키값을 가진 데이터가 존재하는 경우다
- 이러한 오류가 발생하면 `apply worker` 프로세스가 반복적으로 종료 및 재시작되면서 복제 지연이 발생한다
- 에러가 발생하면 LSN 값을 입력해서 해당 위치를 건너뛰면 바로 해결된다

<br>

## 양방향 논리 복제
- PG는 현재까지는 멀티 마스터 기능을 지원하지 않음
- 오라클 RAC 처럼 디스크 공유 방식의 멀티 마스터 구조를 PG의 아키텍처에 적용하는건 매우 어려움

<br>

### 양방향 복제 동작 원리
- 앙방향은 간단하게 구독 서버에서 발생한 변경도 다시 발행 서버로 전송되는 구조다
- 즉 양쪽 서버 모두가 발행자, 구독자를 수행하는 구조다
- 하지만 가장 중요한 점은 무한 루프 복제의 위험을 제거하는것이다
- 각 변경 사항이 실제 트랜잭션에 의한 것인지, 복제를 통해 전달된 것인지를 구분하면 된다

<br>

### 양방향 복제 구성 절차
#### 1번쨰 DB에서 발행자 생성
```sql
postgres=# create publication pub_svc_tbl1 for table svc.t1;
```

#### 2번째 DB에서 발행자 생성
```sql
postgres=# create publication pub_svc_tbl2 for table svc.t1;
```

#### 1번째 DB에서 구독자 생성
```sql
create subscription sub_svc_tbl2 connection 'host=192.168.147.3 port=5432 dbname=postgres user=postgres password=postgres' publication pub_svc_tbl2 with (origi
n='none');
```

#### 2번째 DB에서 구독자 생성
```sql
create subscription sub_svc_tbl2 connection 'host=192.168.147.4 po
rt=5432 dbname=postgres user=lglrep password=reppass' publication pub_svc_tbl
2 with (origin='none');
```
