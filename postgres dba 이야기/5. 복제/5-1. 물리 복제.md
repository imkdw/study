## 물리 복제
- PG는 물리 복제와 논리 복제 기능을 제공함
- 주요 업무 환경은 대부분 물리 복제를 활용해서 읽기 작업을 분산하게된다
- 물리 복제의 주요 목적은 읽기 부하를 분산해서 전체 시스템의 성능을 향상시키는 데 있으며 DR에서도 활용 가능하다
- 하지만 물리 복제만으로는 마스터 서버의 가용성 확보가 불가능하며 디스크 이중화나 SW 방식의 이중화 솔루션이 필요하다

<br>

## 물리 복제 구성하기
### 리플리카 서버 준비
- 마스터 서버와 동일한 스펙의 서버를 준비함
- 마스터 서버 - 리플리카 서버 간 방화벽을 오픈하고 동일한 버전의 PG를 설치한다

<br>

### 복제 전용 유저 생성
- 슈퍼유저(postgres)로 복제도 가능하지만 복제 전용 유저를 별도로 생성하는게 권장사항이다
- 복제 전용 유저에게는 `REPLICATION` 권한을 부여한다

```sql
-- 복제 전용 유저 생성
postgres@localhost:postgres> create user dbarep with password 'reppass' replication;

-- 복제 전용 유저 권한 확인
postgres@localhost:postgres> \du dbarep
+---------+----------+------------+---------------+-------------+-------------+--------------+---------------+----------+----------------+
| rolname | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolconnlimit | rolvaliduntil | memberof | rolreplication |
|---------+----------+------------+---------------+-------------+-------------+--------------+---------------+----------+----------------|
| dbarep  | False    | True       | False         | False       | True        | -1           | <null>        | []       | True           |
+---------+----------+------------+---------------+-------------+-------------+--------------+---------------+----------+----------------+
```

<br>

### 마스터 서버의 pg_hba.conf 파일 설정
- 물리 복제는 DB 클러스터 전체를 복제함. 그래서 `DATABASE` 항목에는 특정 디비가 아닌 replication을 입력함
- `USER`에는 위에서 생성한 복제용 유저를 입력하고, `ADDRESS`에는 리플리카 서버의 IP를 입력함

```bash
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    replication     dbarep          192.168.117.3/32        trust
```

<br>

### pg_basebackup을 이용한 복제
- 리플리카 서버에 postgres 유저로 ㅈ버속해서 pg_basebackup을 통해 디스크 복제를 수행함
- 복제를 수행하기 전에 DB 클러스터, WAL, 테이블스페이스용 디스크 볼륨의 소유자를 postgres 유저로 변경함

```bash
root@7f4ec8b342af:/# pg_basebackup -h 192.168.147.2 -p 5432 -D /data/svc01 -U dbarep -c fast -X stream -v -R -P --waldir=/pg_wal/svc01 -W
Password: 
pg_basebackup: initiating base backup, waiting for checkpoint to complete
pg_basebackup: checkpoint completed
pg_basebackup: write-ahead log start point: 0/2000028 on timeline 1
pg_basebackup: starting background WAL receiver
pg_basebackup: created temporary replication slot "pg_basebackup_80"
23232/23232 kB (100%), 1/1 tablespace                                         
pg_basebackup: write-ahead log end point: 0/2000120
pg_basebackup: waiting for background process to finish streaming ...
pg_basebackup: syncing data to disk ...
pg_basebackup: renaming backup_manifest.tmp to backup_manifest
pg_basebackup: base backup completed
root@7f4ec8b342af:/# 
```

<br>

### 인스턴스 시작
- 데이터 백업이 완료되었다면 리플리카 인스턴스를 재부팅함
- 이후에 `pg_is_in_recovery` 함수를 사용해서 리플리카로 동작중인지 확인이 가능함
```sql
postgres=# select pg_is_in_recovery();
 pg_is_in_recovery 
-------------------
 t
(1 row)
```