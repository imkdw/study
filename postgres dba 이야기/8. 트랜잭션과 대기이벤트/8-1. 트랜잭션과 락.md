## Low-Level Lock
- PG는 개별 레코드 단위로 락을 제어하는 `Low-Level Lock`을 제공한다
- 해당 락은 `Exclusive Mode`와 `Share Mode` 두 가지로 나뉜다

<br>

### Exclusive Mode
- 레코드를 변경하는 명령어는 `Exclusive Mode`로 락을 획득한다
  - 이는 동일 레코드에 대한 동시 접근을 차단한다
  - 대표적으로 INSERT, DELETE, UPDATE, SELECT FOR UPDATE 명령어가 존재한다
  - 이러한 명령어들은 동일 헤코드에 대해서 동시에 수행이 불가능하다

<br>

### Share Mode
- 레코드의 변경을 방지하는 목적으로 사용되는 `SELECT FOR SHARE` 명령어는 `Share Mode`로 락을 획득한다
- 여러 세션에서 동시에 동일 레코드에 대한 락을 설정할 수 있다

<br>

## Table-Level Lock
- 테이블에 대한 명령어를 수행할 때 필요하며 다양한 모드를 제공한다
- 다양한 락 모드를 제공하는 이유는 한 테이블에 여러 명령어가 동시에 수행될 수 있도록 동시성을 최대한 보장하면서도 데이터 무결성을 유지하기 위함이다
- 각 락 모드 간의 호환성 여부에 따라서 명령어들이 동시에 수행 가능한지 여부가 결정된다

<br>

### Access Share
- `SELECT` 명령 수행시 필요한 락 모드
- `DROP TABLE` 수행시 필요한 Access Exclusive 모드랑 호환이 안된다
- 테이블 조회중에 DROP 명령어를 사용하게 된다면 락 대기가 발생한다

<br>

### Row Share
- `SELECT FOR UPDATE`, `SELECT FOR SHARE` 명령어 수행시 필요한 락 모드
- 대부분의 락 모드와 호환되며 예를 들면 위 명령어 수행중에 인덱스 생성이 가능함

<br>

### Row Exclusive
- `INSERT`, `DELETE`, `UPDATE` 수행 시 필요한 락 모드
- Share Mode 이상의 모드와는 호환이 안된다
- DML 수행 중에 인덱스 생성을 시도하면 인덱스 생성을 수행한 세션은 락 대기를 하게됨

<br>

### Share Update Exclusive
- `CREATE INDEX CONCURRENTLY`, `VACUUM`, `ANALYZE` 명령어 수행시 필요한 락 모드
- Row Exclusive 모드와 락 경합이 없어서 실무에서 자주 활용됨
- Share Update Exclusive 모드랑은 락 충돌이 발생함

<br>

### Share
- 인덱스 생성시 필요한 락 모드로 Row Exclusive 모드와 호환이 불가능함
- 인덱스 생성 중에 DML을 수행한 세션은 락 대기를 하게됰ㅁ
- Share 모드간에는 락 호환성이 있어서 테이블에 여러개의 인덱스를 동시에 생성이 가능함

<br>

### Access Exclusive
- `TRUNCATE`, `DROP`, `VACUUM FULL` 등과 같은 명령어 수행시 필요함
- 가장 강력한 락 모드며 `SELECT` 수행시 필요한 Access Share랑도 호환이 불가능함

<br>

## 데드락
- 두 개 이상의 세션이 서로가 보유한 락을 필요로 하면서 상대방의 락 해제를 기다리는 상태를 의미함
- 각 세션이 상대 세션의 종료를 기다리게 되므로 `교착 상태`에 빠지게됨
- 데드락을 감지한 세션이 트랜잭션을 강제로 롤백하고 세션을 종료해야 문제가 해소됨
- 데드락은 잘못된 앱 트랜잭션 처리 로직으로 인해서 발생하므로 미연에 방지하려면 일관된 트랜잭션 처리 순서와 락 최소화 설계가 중요함

<br>

### 데드락 감지 주기 파라미터
- `deadlock_timeout` 파라미터로 제어가 가능하고 기본값은 1초다
```sql
postgres=# \dconfig deadlock_timeout;
List of configuration parameters
    Parameter     | Value 
------------------+-------
 deadlock_timeout | 1s
```

<br>

### 테스트용 데이터 생성
```sql
postgres=# create table ltest (c1 integer, c2 integer);
postgres=# insert into ltest values(1, 1), (2, 2), (3, 3);
```

<br>

### 두 세션간 데드락 상황
- PG는 일정 시간(deadlock_timeout) 동안 락을 대기한 후 데드락 체인을 감지함
- 감지되는 트랜잭션은 자동으로 종료시키고 교착 상태를 해소함

```sql
-- 세션#1) 트랜잭션 시작
postgres=# begin;

-- 세션#1) c1 = 1 레코드 수정
postgres=*# update ltest set c2 = c2 + 1 where c1 = 1;

-- 세션#2) 트랜잭션 시작
postgres=# begin;

-- 세션#2) c1 = 2 레코드 수정
postgres=*# update ltest set c2 = c2 + 1 where c1 = 2;

-- 세션#1) c1 = 2 레코드 수정, 기존 세션#2에서 수정한 레코드
postgres=*# update ltest set c2 = c2 + 1 where c1 = 2;

-- 세션#2) c1 = 1 레코드 수정, 기존 세션#1에서 수정한 레코드
postgres=*# update ltest set c2 = c2 + 1 where c1 = 1;

-- 데드락 발생 감지
ERROR:  deadlock detected
DETAIL:  Process 2508 waits for ShareLock on transaction 93372; blocked by process 794.
Process 794 waits for ShareLock on transaction 93393; blocked by process 2508.
HINT:  See server log for query details.
CONTEXT:  while updating tuple (0,1) in relation "ltest"
```

<br>

### 세 세션간 데드락 상황
- 세 개의 세션이 서로 순환적으로 락을 대기하는 구조에서도 데드락이 발생할 수 있음
- 동일ㅇ하게 데드락을 감지한 세션이 자신의 트랜잭션을 롤백하고 자동으로 종료하게된다
- 단 데드락 상황이 아닌 락 대기 세션은 여전히 락을 대기한다

```sql
-- 세션#1) 트랜잭션 시작
postgres@localhost:postgres> begin;

-- 세션#1) c1 = 1 레코드 수정
postgres=*# update ltest set c2 = c2 + 1 where c1 = 1;

-- 세션#2) 트랜잭션 시작
postgres=# begin;

-- 세션#2) c1 = 2 레코드 수정
postgres=*# update ltest set c2 = c2 + 1 where c1 = 2;

-- 세션#3) 트랜잭션 시작
postgres@localhost:postgres> begin;

-- 세션#3) c1 = 3 레코드 수정
postgres=*# update ltest set c2 = c2 + 1 where c1 = 3;

-- 세션#1) c1 = 2 레코드 수정, 가존 세션#2에서 수정한 레코드
postgres=*# update ltest set c2 = c2 + 1 where c1 = 2;

-- 세션#2) c1 = 3 레코드 수정, 기존 세션#3에서 수정한 레코드
postgres=*# update ltest set c2 = c2 + 1 where c1 = 3;

-- 세션#3) c1 = 1 레코드 수정, 기존 세션#1에서 수정한 레코드
postgres=*# update ltest set c2 = c2 + 1 where c1 = 1;

-- 데드락 감지
deadlock detected
DETAIL:  Process 2742 waits for ShareLock on transaction 93761; blocked by process 2726.
Process 2726 waits for ShareLock on transaction 93774; blocked by process 2734.
Process 2734 waits for ShareLock on transaction 93788; blocked by process 2742.
HINT:  See server log for query details.
CONTEXT:  while updating tuple (0,1) in relation "ltest"
```

<br>

## Multi Transaction
- 하나의 레코드에 동시에 여러 개의 트랜잭션이 수행되는 것을 의미함
- `INSERT`, `UPDATE` 등 명령어는 로우 레벨 락을 Exclusive 모드로 흭득해서 동일 레코드에 대해 멀티 트랜잭션 처리가 불가능함
- `SELECT FOR SHARE`의 경우는 Share 모드의 로우 레벨 락을 획득하므로 여러 트랜잭션이 하나의 레코드에 대한 멀티 트랜잭션 처리가 가능함
- PG는 멀티 트랜잭션 정보를 `$PGDATA/pg_multixact` 하위의 `members`, `offsets` 서브 디렉토리에 저장함
- 하지만 트랜잭션 정보를 디스크에 저장하면 디스크 I/O 증가 및 성능 저하가 발생할 수 있음
- 그래서 PG는 해당 정보를 Shared Memory에 적재해서 관리하는 방식을 채택하고 있음

<br>

### FK와 멀티 트랜잭션
- FK를 사용한다면 내부적으로 다수의 멀티 트랜잭션이 발생할 수 있다는 점을 반드시 인지해야함
- `SELECT FOR KEY SHARE` 모드는 PK의 변경을 방지하는 용도로 사용함
- `마스터 - 디테일` 관계에서 디테일에 트랜잭션 발생시 마스터의 PK가 변경되지 않도록 `KEY SHARE` 락을 설정함
- 디테일 테이블에 다수의 트랜잭션이 수행되는 경우 마스터 테이블 레코드에 대한 멀티 트랜잭션 상황이 발생할 수 있음
- FK 제약 조건이 많다면 `pg_stat_slru` 뷰를 통해서 관련된 부하 모니터링이 필요함

<br>

#### 마스터 & 디테일 테이블 생성
```sql
-- 마스터 테이블 생성
postgres@localhost:postgres> create table t_master (
 master_id integer not null,
 master_name varchar(20) not null
 );
postgres@localhost:postgres> alter table t_master add constraint t_master_pk primary key (master_id);
postgres@localhost:postgres> insert into t_master values(1, 'master_1');

-- 디테일 테이블 생성
postgres@localhost:postgres> create table t_detail (
 detail_id integer not null,
 master_id integer not null,
 order_date timestamp not null,
 order_amount integer not null
 );
postgres@localhost:postgres> alter table t_detail add constraint t_detail_pk primary key (detail_id);
postgres@localhost:postgres> alter table t_detail add constraint t_detail_fk foreign key (master_id) references t_master (master_id) on delete cascad
 e;
postgres@localhost:postgres> create sequence t_detail_sq;
```

<br>

#### 다수의 트랜잭션 실행시키기
- `pgbench`를 활용해서 테스트를 진행함
- `-n` 옵션을 통해서 pgbench 기본 테이블을 초기화하고 바큠을 스킵함. custom sql 실행시 필요
- `-c`으로 동시에 10개의 커넥션을 연결하고, `-j`로 10개의 워커 스레드를 지정함
- `-T` 옵션으로 600초를 지정해서 10분동안 트랜잭션이 발생하게 시도

```bash
root@b20fa9478609:/# cat t_insert.sql 
insert into t_detail values (nextval('t_detail_sq'), 1, now(), 10);

root@b20fa9478609:/# pgbench -U postgres -d postgres -n -f t_insert.sql -c 10 -j 10 -T 600
pgbench (17.6 (Debian 17.6-2.pgdg13+1))
transaction type: t_insert.sql
scaling factor: 1
query mode: simple
number of clients: 10
number of threads: 10
maximum number of tries: 1
duration: 600 s
number of transactions actually processed: 4652633
number of failed transactions: 0 (0.000%)
latency average = 1.290 ms
initial connection time = 2.595 ms
tps = 7754.216022 (without initial connection time)
```

<br>

#### SLRU 활동 내역 모니터링하기
```sql
postgres=# select name, blks_hit, blks_read, blks_written from pg_stat_slru;
       name       | blks_hit | blks_read | blks_written 
------------------+----------+-----------+--------------
 commit_timestamp |        0 |         0 |            0
 multixact_member |  9598429 |         0 |        24763
 multixact_offset |  9554072 |         7 |         2271
 notify           |        0 |         0 |            0
 serializable     |        0 |         0 |            0
 subtransaction   |        0 |         0 |         2246
 transaction      |  9677500 |         7 |          440
 other            |        0 |         0 |            0
```

<br>

#### 디스크에 저장된 멀티 트랜잭션 정보
```bash
root@b20fa9478609:/var/lib/postgresql/data/pg_multixact# ls -Rl
.:
total 8
drwx------ 1 postgres postgres 6224 Nov  8 09:20 members
drwx------ 1 postgres postgres  584 Nov  8 09:15 offsets

./members:
total 199096
-rw------- 1 postgres postgres 262144 Nov  8 09:05 0000
-rw------- 1 postgres postgres 262144 Nov  8 09:05 0001
-rw------- 1 postgres postgres 262144 Nov  8 09:05 0002
-rw------- 1 postgres postgres 262144 Nov  8 09:05 0003
-rw------- 1 postgres postgres 262144 Nov  8 09:05 0004
```

<br>

## `pg_locks` 뷰
- 현재 디비에서 활성화된 락 정보를 제공하는 시스템 뷰
- PG의 모든 명령어는 해당 명령어에 필요한 락 모드를 획득한 후 실행된다
- 디비 전반의 락 현황 모니터링을 위해서는 pg_locks 뷰가 매우 유용하다

<br>

### pg_locks 뷰 조회 예시
#### 세션 1
- `DELETE` 명령어 수행으로 인해서 얻은 락들 (locktype 컬럼)
  - Row Exclusive 모드의 테이블 락(relation)
  - Exclusive 모드의 로우 레벨 락(trasactionid)

#### 세션 2
- `SELECT` 명령어 수행으로 Access Share 모드의 테이블 락을 획득함 (locktype 컬럼)
- `SELECT` 명령어의 경우 로우 레벨 락을 획득하지 않음


```sql
-- 세션#1) 트랜잭션 시작
postgres=# begin;

-- 세션#1) c1 = 1레코드 제거
postgres=*# delete from ltest where c1 = 1;

-- 세션#2) 트랜잭션 시작
postgres=# begin;

-- 세션#2) c1 = 2 레코드 조회
postgres=*# select * from ltest where c1 = 2;
```

```sql
-- pg_locks 뷰 조회
postgres=# select
	locktype,
	relation::regclass,
	virtualxid,
	transactionid,
	virtualtransaction,
	pid,
	mode,
	granted
from pg_locks
order by pid, locktype

-- 결과
   locktype    | relation | virtualxid | transactionid | virtualtransaction | pid  |       mode       | granted 
---------------+----------+------------+---------------+--------------------+------+------------------+---------
 relation      | ltest    |            |               | 52/2               | 3950 | RowExclusiveLock | t
 transactionid |          |            |       4854210 | 52/2               | 3950 | ExclusiveLock    | t
 virtualxid    |          | 52/2       |               | 52/2               | 3950 | ExclusiveLock    | t
 relation      | ltest    |            |               | 53/4               | 3967 | AccessShareLock  | t
 virtualxid    |          | 53/4       |               | 53/4               | 3967 | ExclusiveLock    | t
 relation      | pg_locks |            |               | 54/3               | 3997 | AccessShareLock  | t
 virtualxid    |          | 54/3       |               | 54/3               | 3997 | ExclusiveLock    | t
(7 rows)
```

<br>

### 동일 레코드 락 경합 모니터링 시의 주의점
- 로우 레벨 락 대기가 발생하면 PG는 아래 같은 특징이 존재함
  - 첫 번째 대기 세션은 transactionid 락을 Share 모드로 요청하면서 대기
  - 이후 대기 세션은 tuple 락을 Exclusive 모드로 요청하면서 대기
- PG의 경우 동일 레코드에 대해 로우 레벨 락 경합이 여러 세션에서 발생하면 아래처럼 동작함
  - 첫 번째 대기 세션은 transactionid 락을 요청함
  - 이후에는 tuple 락을 요청함

```sql
-- 세션#1) 트랜잭션 시작
postgres=# begin;

-- 세션#1) c1 = 1 레코드 수정
postgres=*# update ltest set c2 = c2 + 1 where c1 = 1;

-- 세션#2) 트랜잭션 시작
postgres=# begin;

-- 세션#2) c1 = 1 레코드 수정
postgres=*# update ltest set c2 = c2 + 1 where c1 = 1;

-- 현재 락 상태, Share 모드로 요청하면서 대기중
   locktype    | relation | virtualxid | transactionid | virtualtransaction | pid  |       mode       | granted 
---------------+----------+------------+---------------+--------------------+------+------------------+---------
 transactionid |          |            |       4854633 | 53/5               | 3967 | ShareLock        | f

-- 세션#3) 트랜잭션 시작
postgres=# begin;

-- 세션#3) c1 = 1 레코드 수정
postgres=*# update ltest set c2 = c2 + 1 where c1 = 1;

-- 현재 락 상태, 대기 세션은 tuple 락을 Exclusive 모드로 요청하면서 대기중임
   locktype    | relation | virtualxid | transactionid | virtualtransaction | pid  |     mode      | granted 
---------------+----------+------------+---------------+--------------------+------+---------------+---------
 transactionid |          |            |       4854633 | 53/5               | 3967 | ShareLock     | f
 tuple         | ltest    |            |               | 54/5               | 3997 | ExclusiveLock | f
```

<br>

## Virtual XID
- Virtual XID는 세션별 트랜잭션을 관리하기 위해서 사용되는 내부 구조다
- `ProcNumber`: 백엔드 프로세스 시작시 내부적으로 할당되는 값. 실제 공유 메모리 내부 프로세스를 관리하는 배열의 인덱스
- `LocalTransactionId` : 해당 세션 내에서 트랜잭션이 발생할 때 마다 1씩 증가함
- 이러한 락 경합은 CIC 옵션을 사용해서 인덱스를 생성하거나 삭제할 때 흔히 관찰됨

```sql
-- 세션#1) 트랜잭션 시작
postgres=# begin;

-- 세션#1) c1 = 1 레코드 조회
postgres=*# select * from ltest where c1 = 1;
 c1 | c2 
----+----
  1 |  1
(1 row)

-- 세션#2) 트랜잭션 시작
postgres=# begin;

-- 세션#2) c1 = 2 레코드 수정
postgres=*# update ltest set c2 = c2 + 1 where c1 = 2;

-- 세션#3) 인덱스 생성
postgres=# create index concurrently ltest_n1 on ltest(c1);

-- 현재 락 상태
virtualxid		54/7		54/7	3997	ExclusiveLock	true -- 세션#2
virtualxid		53/7		54/7	3997	ShareLock	false -- 세션#3 대기
```

<br>

## fastpath
- `fastpath`는 락을 빠르게 획득하기 위한 경량화된 방법이다
- PG는 인스턴스가 생성되는 시점에 각 프로세스마다 일정 개수의 슬롯을 공유 메모리 할당한다
- 할당된 슬롯을 통해서 `relation` 유형의 락을 관리하게된다
- 슬롯의 개수는 17버전 기준 16개 이며 조절이 불가능하다

<br>

### slowpath
- 슬롯의 개수가 17개 부터는 다른 방법으로 처리하는데 이는 `slowpath`라고 불리지만 공식 용어는 아니다
- 모든 세션이 공유하는 전역 락 테이블을 통해서 락을 관리하는 방식이다
- 해당 구조체에는 다수의 프로세스가 동시에 접근하기 때문에 락 관리 구조 자체에 경합이 발생할 수 있다
- 그래서 fastpath에 비해서 성능이 떨어질 수 있다

<br>

### fastpath 동작 방식
- PG는 트랜잭션 수행 시 테이블뿐 아니라 해당 테이블에 생성된 모든 인덱스에 대해서도 relation 락을 획득한다
- 트랜잭션 내에서 엑세스하는 테이블이 많거나 인덱스가 많은 테이블에 접근시에도 fastpath 슬롯 초과로 인해서 slowpath로 전환될 가능성이 높아진다
- 슬롯 부족으로 인해 전환되면 락 테이블 접근으로 인한 경합 발생이 가능해진다
- 다수의 테이블을 엑세스하는 트랜잭션이 동시에 수행될 경우는 slowpath 전환으로 인한 성능 저하 가능성을 염두해야한다

<br>

### 테스트#1: 테이블 엑세스 시 인덱스에도 relation 락 획득여부
- 테이블을 엑세스하면 실행 계확과는 무관하게 테이블에 생성된 모든 인덱스에 대해서 `relation` 락을 획득한다
- 아래 트랜잭션에서 엑세스한 relation은 3개 이므로 이들 모두 `fastpath` 방식으로 relation 락을 획득한다

```sql
-- 인덱스 생성
postgres=# create index ltest_n1 on ltest(c1);
postgres=# create index ltest_n2 on ltest(c2);

-- 테이블 조회
-- 인덱스를 사용하지 않고 테이블 전체를 스캔하는 방식으로 수행됨
postgres=# explain select * from ltest where c1 = 1;
                     QUERY PLAN                      
-----------------------------------------------------
 Seq Scan on ltest  (cost=0.00..1.04 rows=1 width=8)
   Filter: (c1 = 1)

-- 실제 테이블을 조회하기
postgres=*# select * from ltest where c1 = 1;
 c1 | c2 
----+----
  1 |  1

-- 현재 락 상태
postgres=# select 
        locktype,
        relation::regclass,
        pid,
        mode,
        fastpath
from pg_locks 
order by pid, locktype;
  locktype  | relation | pid  |      mode       | fastpath 
------------+----------+------+-----------------+----------
 relation   | ltest_n2 | 3950 | AccessShareLock | t
 relation   | ltest_n1 | 3950 | AccessShareLock | t
 relation   | ltest    | 3950 | AccessShareLock | t
```

<br>

### 테스트#2: 슬롯 초과시 slowpath 전환 여부
```sql
-- 기존 ltest랑 동일한 구조로 테이블 복제하기
postgres=# CREATE TABLE ltest1 (LIKE ltest INCLUDING INDEXES);
postgres=# CREATE TABLE ltest2 (LIKE ltest INCLUDING INDEXES);
postgres=# CREATE TABLE ltest3 (LIKE ltest INCLUDING INDEXES);
postgres=# CREATE TABLE ltest4 (LIKE ltest INCLUDING INDEXES);
postgres=# CREATE TABLE ltest5 (LIKE ltest INCLUDING INDEXES);
postgres=# CREATE TABLE ltest6 (LIKE ltest INCLUDING INDEXES);

-- 슬롯 사용하기
-- 테이블 5개 * 락 3개(테이블 1개, 인덱스 2개) -> 15개
postgres=*# select * from ltest1 a, ltest2 b, ltest3 c, ltest4 d, ltest5 e where a.c1 = b.c1 and a.c1 = c.c1 and a.c1 = d.c1 and a.c1 = e.c1;
 c1 | c2 | c1 | c2 | c1 | c2 | c1 | c2 | c1 | c2 
----+----+----+----+----+----+----+----+----+----

-- 슬롯 추가로 사용하기
postgres=*# select * from ltest6 where c1 = 1;
 c1 | c2 
----+----

-- slowpath 전환 확인하기
postgres=# select 
        locktype,
        relation::regclass,
        pid,
        mode,
        fastpath
from pg_locks 
order by pid, locktype;
  locktype  |   relation    | pid  |      mode       | fastpath 
------------+---------------+------+-----------------+----------
 relation   | ltest6_c1_idx | 3950 | AccessShareLock | f -- 부터 slowpath로 전환됨
 relation   | ltest5_c2_idx | 3950 | AccessShareLock | t
 relation   | ltest5_c1_idx | 3950 | AccessShareLock | t
 relation   | ltest4_c2_idx | 3950 | AccessShareLock | t
 relation   | ltest4_c1_idx | 3950 | AccessShareLock | t
```