## 대기 이벤트
- 트랜잭션 성능 분석을 위해서는 어디에서 지연이 발생했는지, 얼마나 지연됬는지 측정하는게 핵심이다
- PG는 9.6 버전부터 대기 이벤트 정보를 제공하기 시작했으며 현재까지 약 200개가 존재한다

<br>

## 대기 이벤트 유형
- `pg_wait_events` 뷰를 활용해서 시스템에 정의된 모든 대기이벤트의 목록 및 유형 확인이 가능하다
- 17 버전을 기준으로 9가지 유형이 존재한다

<br>

## 대기이벤트 모니터링 방법
- `pg_stat_activity` 뷰의 `wait_event_type`, `wait_event` 컬럼을 통해서 모니터링이 가능함
- 해당 컬럼에 대기이벤트가 표시되어 있다면 현재 세션이 대기중인것이며, NULL인 경우 작업 수행 중인 상태로 해석함
- PG 버전업이 계속해서 되면서 제공되는 대기이벤트 수는 점점 증가하고있지만 이를 모니터링하고 분석할 수 있는 수단은 여전히 `pg_stat_activity` 뷰를 통해서만 가능하다
- PG는 대기이벤트 발생여부만 알 수 있고 이벤트의 세부 정보나 대기 시간은 파악이 불가능한 한계가 존재함

<br>

## DataFileRead 대기 이벤트
- 디스크 I/O가 발생할 때 관찰된다
- 백엔드 프로세스가 쿼리 수행 과정에서 읽어야 할 블록이 공유 버퍼에 없으면 디스크에 저장된걸 읽어서 버퍼에 로딩함
- 해당 과정에서 대기 이벤트가 발생한다
- 자주 발생한다면 인덱스 부재나 결합 인덱스의 비효율성으로 인한 디스크 I/O 증가가 원인일 가능성이 높음

<br>

### 발생하는 주요 원인
- 인덱스 부재로 인해서 테이블 스캔
- 비효율적으로 과도한 인덱스 스캔
- 너무나 작은 공유 버퍼

<br>

## WAL Insert 대기 이벤트
- 백엔드 프로세스는 트랜잭션 수행 시에 생성된 변경 정보를 WAL 버퍼에 복사하기 위해서 WAL 버퍼 내부에 공간을 할당하고 그 공간에 데이터를 복사하는 작업을 수행함
- WAL 버퍼 접근을 위해서는 `LWLock`을 획득해야 하는데 만약 획득하지 못하면 `WALInsert` 대기 이벤트를 대기함
- 해당 작업에 사용하는 LWLock은 총 8개로 고정되어 있는데 즉 최대 8개의 백엔드 프로세스가 동시에 WAL 버퍼에 트랜잭션 정보를 복사할 수 있는 구조다
- 대부분은 매우 빠르게 처리되므로 관찰이 안되는데 자주 발생한다면 WAL 버퍼에 대한 메모리 복사 작업의 속도가 느리거나 전체 트랜잭션 처리량에 비해서 WAL 버퍼 공간이 작다는 신호일 수 있음

<br>

## WALWrite & WALSync 대기이벤트
- 위 2개는 항상 함께 관찰되는 대기이벤트로 백엔드 프로세스가 WAL 버퍼에 기록된 트랜잭션 정보를 WAL 파일에 기록할 떄 발생함

### WALWrite
- 트랜잭션 정보를 디스크에 안전하게 기록하기 위해서는 아래 절차가 필요함
  - 프로세스 메모리 내에 트랜잭션 정보를 기록
  - WAL 버퍼에 메모리 공간을 할당하고 트랜잭션 정보를 복사
  - WAL 버퍼에 복사된 트랜잭션 정보를 WAL 파일에 기록
    - 해당 단게에서 WALWrite용 `LWLock` 획득이 필요한데 획득하지 못한 프로세스는 WALWrite 대기이벤트를 대기함
- `LWLock`은 단 1개만 존재하므로 동시에 여러 세션이 트랜잭션을 커밋하려는 상황에서 단 1개의 세션만 WAL 파일에 쓰기 작업이 가능하고 나머지 세션은 전부 대기함

<br>

### WALSync
- WAL 파일의 내용을 디스크에 flush할 때 발생함
- 성능 향상을 위해서 WAL 정보를 디스크에 직접 쓰지 않고 OS 버퍼 캐시에 먼저 저장하고 `fsync()`를 통해서 디스크에 최종 반영함
- `fsync()` 역시 `WALWrite LWLock`이 필요하므로 대기이벤트 모니터링시 WalSync 이벤트를 대기하는 세션은 항상 1개임

<br>

### 병목 지점
- WALWrite, WALSync 대기이벤트는 디스크 I/O 성능의 영향을 직접적으로 받는 병복 지점이다
- 두 대기이벤트를 최소화하려면 WAL 파일을 저장하는 디스크의 쓰기 성능을 개선하는것이 가장 효과적이다
- WAL 파일은 순차적으로 기록되는 특성이 있으므로 WAL 전용 디스크는 `순차쓰기` 성능이 매우 중요하다

<br>

### 오라클 및 PG의 커밋 처리 방식 차이점
- 오라클은 로그 버퍼의 내용을 로그 파일에 기록하는 역할을 오직 `LGWR 백그라운드 프로세스`만이 처리한다
  - 때문에 동시 커밋이 많은 환경에서는 다수의 세션이 `log file sync` 대기이벤트를 대기하게 되는 병목이 자주 발생함
- PG는 `walwriter` 외에도 백엔드 프로세스가 WAL 버퍼에 기록된 트랜잭션 정보를 WAL 파일에 직접 저장한다
  - 일부 병목 구간은 분산될 수 있지만 WALWrite, WALSync 이벤트는 여전히 발생할 수 있다
  - 이 경우는 디스크 쓰기 성능이 시스템 전반의 트랜잭션 처리 속에 직접적인 영향을 주게됨

<br>

## BufferMapping 대기이벤트
- 공유 버퍼에 접근할 때 `BufferMapping LWLock`을 획득하지 못하면 이벤트를 대기하게됨
- 공유 버퍼에는 아래 구성요소가 있음
  - 해시 테이블
  - 해시 테이블에 연결된 해시 엘리먼트 및 키
  - 버퍼 상태를 관리하는 버퍼 디스크립터
  - 실제 블록을 저장하는 버퍼 풀
- PG는 백엔드 프로세스가 필요한 블록을 공유 버퍼 내부에서 탐색시 빠르게 가능하도록 설계되어있음
- 블록을 읽기 위해서 해시 함수를 적용하고 결과에 따라서 체인을 탐색하는데 여기서 BufferMapping Lock을 공유 모드로 획득함
  - 공유 모드간에는 락 호환성이 존재해서 여러개의 세션이 동시에 해시 체인 탐색이 가능함
- 만약 공유 버퍼에 원하는게 없으면 해당 블록을 디스크에서 읽고 공유 버퍼에 적재해야함
  - 해당 과정에서는 해시 체인을 수정해야 하므로 BufferMapping Lock을 베타 모드로 획득함
  - 또한 다른 세션에서 해당 락을 이미 가지고있다면 BufferMapping 대기이벤트를 대기함
- BufferMapping LWLock의 경우 9.6 버전부터 128개로 증가했고 현재까지 유지중이다
  - 다만 해당 내용은 물리적인 사양이 업그레이드되면서 공유 버퍼를 수백 GB로 설정하는 경우도 생기면서 한계가 있다는 지적도 있다

<br>

### BufferMapping 대기이벤트 모니터링 시 주의 사항
- BufferMapping 대기이벤트는 디스크 I/O가 발생하는 상황에서만 관찰된다는 점에 주의해야함
- 단순 메모리에서 접근하는 비효율적인 쿼리가 많이 발생해도 해당 대기이벤트는 발생하지 않음
- 즉 디스크 I/O가 거의 발생하지 않는 환경에서는 해당 대기이벤트만으로 비효율적인 메모리 I/O를 유발하는 쿼리를 정확히 식별하기 어렵다

<br>

## transactionid 대기이벤트
- 다른 세션에서 트랜잭션이 아직 종료되지 않은 상태에서 해당 세션이 변경 중인 레코드에 접근하려고 할 때 발생함
- - 동일 레코드에 대한 락 경합을 의미하므로 앱 로직에 대한 점검이 필요함

```sql
-- 세션#1) 트랜잭션 시작
postgres=# begin;

-- 세션#1) c1 = 1, 2 레코드 수정
postgres=*# update ltest set c2=c2 where c1 in (1,2);

-- 세션#2) 트랜잭션 시작
postgres=# begin;

-- 세션#2) c1 = 1 레코드 수정
postgres=*# update ltest set c2=c2 where c1 = 1;

-- 현재 락 상태
postgres=# SELECT pid, state, wait_event_type || ':' || wait_event AS wait_info, query 
FROM pg_stat_activity 
WHERE pid = 3967;
 pid  | state  |     wait_info      |               query                
------+--------+--------------------+------------------------------------
 3967 | active | Lock:transactionid | update ltest set c2=c2 where c1=1;
```

<br>

## tuple 대기이벤트
- trsactionid 락을 대기하던 세션이 아직 완료되지 않은 상태에서 또 다른 세션이 동일한 레코드를 변경하려고 시도할 때 발생
- 동일 레코드에 대한 락 경합을 의미하므로 앱 로직에 대한 점검이 필요함

```sql
-- 세션#1) 트랜잭션 시작
postgres=# begin;

-- 세션#1) c1 = 1, 2 레코드 수정
postgres=*# update ltest set c2=c2 where c1 in (1,2);

-- 세션#2) 트랜잭션 시작
postgres=# begin;

-- 세션#2) c1 = 1 레코드 수정
postgres=*# update ltest set c2=c2 where c1 = 1;

-- 세션#3) c1 = 1 레코드 수정
postgres=# update ltest set c2 = c2 where c1 = 1;

-- 현재 락 상태postgres=# SELECT pid, state, wait_event_type || ':' || wait_event AS wait_info, query 
FROM pg_stat_activity 
where pid = 4584;
 pid  | state  | wait_info  |                 query                  
------+--------+------------+----------------------------------------
 4584 | active | Lock:tuple | update ltest set c2 = c2 where c1 = 1;
```

<br>

## virtualxid 대기이벤트
- CIC 옵션을 사용하는 작업 수행 시 락을 대기할 때 발생함
- CIC 작업시 idle in transaction 상태의 비정상 세션이 원인인 경우 많으며 불필요한 세션 정리시 해결된다

```sql
-- 세션#1) 트랜잭션 시작
postgres=# begin;

-- 세션#1) c1 = 1, 2 레코드 수정
postgres=*# update ltest set c2=c2 where c1 in (1,2);

-- 세션#2) 트랜잭션 시작
postgres=# begin;

-- 세션#2) c1 = 1 레코드 수정
postgres=*# update ltest set c2=c2 where c1 = 1;

-- 세션#3) CIC 옵션으로 인덱스 생성
postgres=# create index concurrently ltest_n4 on ltest(c1, c2);

-- 락 상태
postgres=# SELECT pid, state, wait_event_type || ':' || wait_event AS wait_info, query 
FROM pg_stat_activity
where pid = 4584;
 pid  | state  |    wait_info    |                        query                         
------+--------+-----------------+------------------------------------------------------
 4584 | active | Lock:virtualxid | create index concurrently ltest_n4 on ltest(c1, c2);
```

<br>

## relation 대기이벤트
- 락 호환성이 없는 작업을 수행하려고 할 때 발생함
- DDL이나 Vacuum FULL 같은 작업이 원인이므로 적절한 시간대에 작업하는게 좋다

```sql
-- 세션#1) 트랜잭션 시작
postgres=# begin;

-- 세션#1) c1 = 1, 2 레코드 수정
postgres=*# update ltest set c2=c2 where c1 in (1,2);

-- 세션#2) 트랜잭션 시작
postgres=# begin;

-- 세션#2) c1 = 1 레코드 수정
postgres=*# update ltest set c2=c2 where c1 = 1;

-- 세션#3) 풀 바큠 수행
postgres=# vacuum full ltest;

-- 락 상태
postgres=# SELECT pid, state, wait_event_type || ':' || wait_event AS wait_info, query 
FROM pg_stat_activity
where pid = 4584;
 pid  | state  |   wait_info   |       query        
------+--------+---------------+--------------------
 4584 | active | Lock:relation | vacuum full ltest;
```
