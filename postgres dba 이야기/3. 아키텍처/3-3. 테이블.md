## 테이블
- PG는 3가지 유형의 테이블을 제공한다
- 테이블(Heap), Unlogeed, Temp 3가지다

<br>

## 테이블 (Heap 테이블)
- 기존적으로 업무 데이터를 저장하기 위해서 생성하는 테이블을 뜻한다
- 테이블은 3가지 유형의 파일로 구성된다
  - OID : 데이터 파일로 파일명은 `<OID>` 이다
  - FSM : 여유 공간 관리용 파일로 파일 명은 `<OID>_fsm`이다
  - VM : 블록의 `Visibility`, `Freezing` 정보 관리용 파일로 파일 명은 `<OID>_vm`이다

<br>

### 물리적으로 저장되는 파일 확인하기
```sql
-- 테이블 만들기
postgres@localhost:postgres> create table svc.t1_heap (c1 integer);

-- svc.t1_heap 테이블 저장 경로 조회
postgres@localhost:postgres> select pg_relation_filepath('svc.t1_heap')
+----------------------+
| pg_relation_filepath |
| -------------------- |
| base/5/16529         |
+----------------------+
```


<br>

#### 최초 상태
- 맨 처음에는 단순 테이블 파일 하나만 생긴다
```
root@68212c6c65f5:/var/lib/postgresql/data/base/5# ls -al | grep 16529
-rw------- 1 postgres postgres         0 Nov  2 08:14 16529
root@68212c6c65f5:/var/lib/postgresql/data/base/5# 
```

<br>

#### 테이블의 크기가 2블록 이상이 되면 FSM 파일이 생성됨
- PG의 기본값으로 1블록 = 8KB 이므로 테이블이 16KB 이상이 된다면 그 떄 생성됨
- 블록의 크기는 컴파일 타임에 변경이 가능하며 클러스터가 생성된 이후에는 변경이 불가능함
```
root@68212c6c65f5:/var/lib/postgresql/data/base/5# ls -al | grep 16529
-rw------- 1 postgres postgres     16384 Nov  2 08:16 16529
-rw------- 1 postgres postgres     24576 Nov  2 08:16 16529_fsm
root@68212c6c65f5:/var/lib/postgresql/data/base/5# 
```

<br>

#### 첫번째 바큠이 수행되면 VM 파일이 생성됨
```
root@68212c6c65f5:/var/lib/postgresql/data/base/5# ls -al | grep 16529
-rw------- 1 postgres postgres     16384 Nov  2 08:16 16529
-rw------- 1 postgres postgres     24576 Nov  2 08:16 16529_fsm
-rw------- 1 postgres postgres      8192 Nov  2 08:16 16529_vm
root@68212c6c65f5:/var/lib/postgresql/data/base/5# 
```

<br>

## Unlogged 테이블
- WAL이 발생하지 않는다는 특징이 있는데 이를 활용하면 배치/이행 작업 등에서 중간 결과를 임시 저장할 용도로 활용이 가능함
- WAL을 생성하지 않으므로 물리적인 복제 환경에서는 조회가 불가능하고 논리적인 복제도 불가능함
- 세션간 데이터 공유가 가능하고 재시작 후에도 데이터가 유지되긴 하지만 비정상 종료시에는 모두 삭제됨
- 임시 데이터 저장처럼 매우 제한적인 범위 내에서만 사용하는게 좋음

<br>

### 관련된 명령어들
```sql
-- Unlogged 테이블 생성
postgres@localhost:postgres> create unlogged table u1 (c1 integer);


-- Unlogged 테이블 목록 조회
postgres@localhost:postgres> select relname from pg_class where relpersistence='u';
+---------+
| relname |
| ------- |
| u1      |
+---------+
```

<br>

## Temp 테이블
- 세션이나 트랜잭션이 종료되면 자동으로 삭제되는 기능을 가짐
- Unlogged 처럼 WAL이 발생하지 않아서 임시 데이터를 저장할 떄 적절하게 활용이 가능함
- 생성시 `pg_temp_{N}` 형식의 스키마에 생성되는데 N은 임의의 숫자임
- 기존 테이블명과 중복된 이름으로 생성이 가능한데 `SELECT`로 조회시 Temp 테이블이 먼저 조회된다
- `CREATE` 권한이 없는 유저도 테이블 생성이 가능한데 기본으로 Temp 테이블 생성 권한을 `PUBLIC`에게 부여하기 때문임
  - 만약 권한을 회수하고 싶다면 `PUBLIC`으로 부터 권한을 회수하면 된다

<br>

### 세션 종료시까지 유지되는 테이블
```sql
-- Temp 테이블 생성
postgres@localhost:postgres> create temp table t1 (c1 varchar(10));

-- 테이블 목록 조회시 Temp 테이블이 보이는걸 확인할 수 있음
postgres@localhost:postgres> \dt
+------------+------+-------+----------+
| Schema     | Name | Type  | Owner    |
|------------+------+-------+----------|
| pg_temp_66 | t1   | table | postgres |
| public     | u1   | table | postgres |
+------------+------+-------+----------+

-- psql 세션 종료
postgres@localhost:postgres> \q

-- 세션 재시작
imkdw@imkdwui-MacBookPro  ~  pgcli -h localhost -U postgres -p 5442

-- 세션 재시작 후 테이블 목록 조회시 Temp 테이블이 보이지 않는걸 확인할 수 있음
postgres@localhost:postgres> \dt
+--------+------+-------+----------+
| Schema | Name | Type  | Owner    |
|--------+------+-------+----------|
| public | u1   | table | postgres |
+--------+------+-------+----------+
```

<br>

### 트랜잭션 종료시 삭제되는 템프 테이블 만들기
```sql
-- 트랜잭션 시작
postgres@localhost:postgres> begin;

-- Temp 테이블 생성 (트랜잭션 종료시 자동으로 삭제됨)
postgres@localhost:postgres> create temp table t2 (c1 varchar(100)) on commit drop;

-- 테이블 목록 조회시 Temp 테이블이 보이는걸 확인할 수 있음
postgres@localhost:postgres> \d
+------------+------+-------+----------+
| Schema     | Name | Type  | Owner    |
|------------+------+-------+----------|
| pg_temp_78 | t2   | table | postgres |
| public     | u1   | table | postgres |
+------------+------+-------+----------+

-- 트랜잭션 종료
postgres@localhost:postgres> commit;

-- 테이블 목록 조회시 Temp 테이블이 보이지 않는걸 확인할 수 있음
postgres@localhost:postgres> \d
+--------+------+-------+----------+
| Schema | Name | Type  | Owner    |
|--------+------+-------+----------|
| public | u1   | table | postgres |
+--------+------+-------+----------+
```

<br>

## TOAST(The Oversized-Attribute Storage Technique)
- PG는 레코드를 여러개의 블록에 걸쳐 저장하는 기능을 지원하지 않음
- 길이가 긴 레코드를 저장할 때에는 TOAST 기법을 사용해서 저장하게됨
- 만약 하나의 레코드 길이가 2KB를 초과하면 컬럼 단위로 압축을 시도하게됨
- 압축 이후에도 2KB를 초과한다면 가장 길이가 긴 컬럼 순으로 테이블 외부 스토리지에 저장하게됨

<br>

### 스토리지 유형
- TOAST 기능은 컬럼 타입별로 지정된 스토리지 유형에 따라서 동작 방식이 달라짐
- Extended, Plain, Main 3가지 유형이 존재함

<br>

### 압축 여부 확인법
- AAAA...의 경우 사이즈가 1004 바이트이며 압축을 진행하지 않았다
- BBBB...의 경우 사이즈가 44 바이트이며 pglz 압축을 진행했다
```sql
-- 테이블 생성 & 데이터 삽입
postgres@localhost:postgres> create table t1(c1 varchar(3000));
postgres@localhost:postgres> insert into t1 values (lpad('A', 1000, 'A'));
postgres@localhost:postgres> insert into t1 values (lpad('B', 3000, 'B'));

-- 압축 여부 확인
postgres@localhost:postgres> select c1, pg_column_compression(c1), pg_column_size(c1) from t1;
+------------------------------------------------------------------------------------------------------------------------------+-----------------------+----------------+
| c1                                                                                                                                                                                                                        | pg_column_compression | pg_column_size |
|-------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------+----------------|
| AAAA... | <null>                | 1004           |
| BBBBB... | pglz                  | 44             |
+------------------------------------------------------------------------------------------------------------------------------+-----------------------+----------------+
SELECT 2
```

<br>

### TOAST 테이블 확인 방법
- TOAST 대상 컬럼의 실제 데이터는 pg_toast 스키마 내의 TOAST 테이블에 저장됨
- 테이블 이름은 `pg_toast_<원본 OID>` 형식이며 테이블 조회를 통해서 확인이 가능하다
- 거의 직접 조회할 일은 드물지만 디스크 사용량 분석 작업시 확인이 필요할 수 있음

```sql
postgres@localhost:postgres> select a.relname, b.relname, b.relnamespace::regnamespace
 from pg_class a, pg_class b
 where a.relname='t1'
 and a.reltoastrelid=b.oid;
+---------+----------------+--------------+
| relname | relname        | relnamespace |
|---------+----------------+--------------|
| t1      | pg_toast_16545 | pg_toast     |
+---------+----------------+--------------+
```