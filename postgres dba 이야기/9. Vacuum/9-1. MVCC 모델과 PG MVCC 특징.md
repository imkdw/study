## MVCC의 이해
- 디비의 경우 다수의 사용자가 동시에 데이터를 읽고 쓰는 환경에서 동작한다
- 만약 읽기, 쓰기가 서로 블록킹 한다면 동시성은 매우 떨어지는데 이런 문제 해결을 위해 MVCC 기법을 적용한다
- MVCC는 쿼리가 수행된 시점에 맞는 데이터 버전을 읽을 수 있게 해준다
- 이러한 `수행 시점`은 트랜잭션 ID를 통해서 식별하는데 트랜잭션 아이디는 매 트랜잭션마다 1씩 증가한다
- 쿼리는 결국 시작 시점의 트랜잭션 ID와 같거나 더 작은 버전을 읽게된다

<br>

## Postgresql의 MVCC 특징
- MVCC 구현을 위해서는 `이전 버전의 데이터`를 일정 시간동안 보관해야한다
- PG는 테이블 내부에 이전 버전 데이터를 함께 저장하는 방식으로 동작한다
- 현재 레코드는 `라이브 튜플`이라고 부르며 이전 데이터는 `데드 튜플`이라고 부른다

<br>

### 특징 1. 데드 튜플을 테이블 내부에 저장한다
- PG는 데드 튜플을 테이블 내부에 보관하기 위해서 수정 연산이 발생하면 `DELETE + INSERT` 방식으로 동작한다
- 이 때 만약 데드 튜플이 누적될수록 테이블 크기가 커지는데 이러한 현상을 `블로팅(Bloating) 현상`이라고 부른다
- 블로팅 현상을 줄이기 위해서는 데드 튜플에 대해 지속적인 삭제가 필요한데 이런 작업이 바로 `Vacuum` 작업이다
- 수동으로 수행도 가능하며 `Autovacuum` 프로세스를 이용해서 자동으로 삭제도 가능하다
- 정상적으로 수행만된다면 큰 문제가 없어보이지만 슬로우 쿼리 등 외부 요인으로 바큠 작업이 방해를 받을 수 있다

<br>

### 특징 2. 레코드 별로 트랜잭션 아이디를 관리
- 쿼리 수행 시점의 정합성에 맞는 정확한 레코드를 읽기 위해서는 각 레코드별로 트랜잭션 아이디 관리가 필요함
- PG는 이를 위해서 2개의 시스템 컬럼을 활용함
  - XMIN : 해당 레코드를 생성한 시점의 트랜잭선 아이디를 저장
  - XMAX : 해당 레코드가 삭제되거나 변경된 시점의 트랜잭선 아이디를 저장
- 레코드가 변경되면 새로운 라이브 튜플이 만들어지고 데드 튜플의 XMAX와 새로운 라이브 튜플의 XMIN은 같은 값으로 설정됨
  - XMAX 값이 0인 경우 해당 튜플은 라이브 튜플로 간주함
- 하지만 레코드마다 2개의 시스템 컬럼을 가지는건 비효율적인데 PG는 오버헤드를 줄이기 위해서 4바이트 정수형으로 저장함
  - 즉 XMIN, XMAX 값은 32비트 트랜잭션 아이디를 사용해서 관리함

<br>

#### 4바이트 정수형 트랜잭션 아이디의 문제점
- 32비트로 표현 가능한 값의 범위는 약 43억개에 불과한데 TPS가 1000개인 경우 50일이면 모두 고갈된다
- 만약 43억개의 트랜잭션 아이디를 모두 사용하면 다시 처음부터 순환해서 번호 부여가 필요하다
- 이런 현상을 `Wraparound` 라고 부른다

<br>

#### Wraparound를 방지하기 위한 방법
- PG는 이러한 현상이 발생하기 이전에 바큠 작업을 수행한다
- 이런 작업은 `Anti-Wraparound Vacuum`이라고 부르며 일반적인 데드 ㅊ튜플 정리 목적의 바큠 작업보다 훨씬 복잡하다
- 64비트 방식으로 바꾸거나 특정값 조합으로도 해결이 가능하지만 PG는 공간 오버헤드 문제로 이러한 방식 도입을 안하고있다
- 기존에는 약 레코드당 20바이트의 공간을 메타데이터 관리를 위해서 사용하는데 64비트를 도입하면 30바이트에 달하는 오버헤드가 발생한다

<br>

## 32비트 XID 문제 해결을 위한 2가지 기법
- 만약 43억개의 XID를 모두 소진하고 다시 3부터 시작하는 경우 `43억 + 3` 아이디를 가지게된다
- 그래서 위 값을 모든 XID보다 큰 수로 인식할 수 있도록 만드는 방법이 필요하다
  - 한 바퀴를 돌기 전에 오래된 레코드를 `Frozen` 상태로 만들어서 이를 지원한다
  - 43억개의 50%인 21.5억 만큼은 항상 읽을 수 있는 상태로 간주한다

<br>

### Frozen 이란?
- 데이터를 얼려서 XID와 무관하게 항상 읽을 수 있는 상태로 만드는걸 의미한다
- Frozen 상태가 되면 해당 레코드의 XMIN 값은 2로 설정되는데 일반 XID는 3부터 시작하므로 항상 과거에 존재하게된다
- XID의 구분은 아래처럼 동작한다
  - 1 : Bootstrap XID로 `initdb()` 수행시 사용된다
  - 2 : Anti-wraparound Vacuum 작업을 통해서 적용된다
  - 3 : 일반 트랜잭션에서 사용된다
- 하지만 Frozen 작업에는 시간이 필요한데 PG는 일정 범위내의 레코드는 Frozen 상태가 아니여도 항상 읽을 수 있도록 설계되어 있음
  - 이를 위해 PG는 현재 XID 기준으로 21.5억 이전까지의 레코드는 항상 읽을 수 있는 것으로 간주하는것임

<br>

### signed int를 사용하는 변수
- 예를 들어서 3 - 43억의 경우 음수로 결과가 나오게 된다
- 하지만 signed int를 통해서 오버플로우가 발생되어 양수로 해석된다
- 이러면 PG는 해당 레코드는 `과거의 것`으로 인식하고 정상적으로 읽을 수 있다
- 그래서 반대로 21.5억 이후의 XID에 대해서는 모두 Frozen 상태가 되어야만 읽을 수 있다
- 현재 XID가 3인데 10이 Frozen되지 않았다면 `3 - 10`은 signed int로 변환해도 여전히 음수다
- PG는 만약 Frozen 처리가 일정 속도로 따라가지 못하면 에러를 출력하면서 트랜잭션 처리를 중단시킨다

```
ERROR: database is not accepting commands to avoid wraparound data...
HINT: Stop the postmaster and use a standalone backend to VACUUM that database
```