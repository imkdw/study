## Vacuum 수행 방법과 옵션
- `VACUUM` 명령어를 통해서 수행하며 테이블이나 디비 단위로 수행이 가능함
- 일반적으로 테이블 단위로 작업을 수행하며 스키마나 인덱스 단위 작업은 제공하지 않음

<br>

### 테스트 환경 구성
```sql
-- 테이블 페이지 상태 관찰을 위한 익스텐션
postgres=# create extension pageinspect;

-- 테이블 생성 & 인덱스 추가 & 데이터 삽입
postgres=# create table vt1 (c1 integer, c2 integer);
postgres=# create index vt1_n1 on vt1 (c1);
postgres=# insert into vt1 select i, i from generate_series(1, 2) i;
```


<br>

### FULL 옵션
- 일반적인 바큠 작업과 달리 테이블을 재구성하는 작업임
- 해당 옵션은 바큠 명령어의 하위 옵션보다는 별도의 명령어로 이해하는게 바람직함
- `pg_relation_filepath()` 함수를 통해서 `VACUUM FULL` 이후에 테이블, 인덱스가 재생성되는걸 볼 수 있음

```sql
-- 수행 전
postgres=# select pg_relation_filepath('vt1'); -- base/5/16464
postgres=# select pg_relation_filepath('vt1_n1'); -- base/5/16467

-- VACUUM FULL 수행
postgres=# vacuum full vt1;

-- 수행 후
postgres=# select pg_relation_filepath('vt1'); -- base/5/16513
postgres=# select pg_relation_filepath('vt1_n1'); -- base/5/16516
```

<br>

### FREEZE
- 레코드에 대한 Frozen 작업을 매우 공격적으로 수행하는 옵션임
- 기본적으로 VACUUM 명령어를 실행하면 설정된 파라미터값에 의해서 일부 레코드만 Frozen 처리가 수행됨
- 하지만 FREEZE 옵션을 사용하면 테이블 내 모든 레코드를 대상으로 Frozen 처리가 수행됨
- 추가로 `VACUUM FULL`의 경우 내부적으로 FREEZE 옵션이 자동으로 동작함

```sql
postgres=# vacuum (freeze, verbose) vt1;
INFO:  aggressively vacuuming "postgres.public.vt1"
INFO:  finished vacuuming "postgres.public.vt1": index scans: 0
pages: 0 removed, 1 remain, 1 scanned (100.00% of total)
tuples: 0 removed, 4 remain, 2 are dead but not yet removable
removable cutoff: 4860456, which was 5670 XIDs old when operation ended
frozen: 0 pages from table (0.00% of total) had 0 tuples frozen
index scan not needed: 0 pages from table (0.00% of total) had 0 dead item identifiers removed
avg read rate: 0.000 MB/s, avg write rate: 0.000 MB/s
buffer usage: 14 hits, 0 misses, 0 dirtied
WAL usage: 0 records, 0 full page images, 0 bytes
system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s
```

<br>

### ANALYZE
- 바큠 작업 이후에 쿼리 옵티마이저의 비용 계산에 필요한 통계 정보까지 함께 생성하는 옵션임
- 바큠 -> 갱신 작업을 하나로 뭉친 옵션으로 동시에 2개다 수행이 가능함

```sql
postgres=# vacuum (verbose, analyze) vt1;
INFO:  vacuuming "postgres.public.vt1"
INFO:  finished vacuuming "postgres.public.vt1": index scans: 0
pages: 0 removed, 1 remain, 1 scanned (100.00% of total)
tuples: 0 removed, 4 remain, 2 are dead but not yet removable
removable cutoff: 4860456, which was 5782 XIDs old when operation ended
frozen: 0 pages from table (0.00% of total) had 0 tuples frozen
index scan not needed: 0 pages from table (0.00% of total) had 0 dead item identifiers removed
avg read rate: 0.000 MB/s, avg write rate: 0.000 MB/s
buffer usage: 12 hits, 0 misses, 0 dirtied
WAL usage: 0 records, 0 full page images, 0 bytes
system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s
INFO:  analyzing "public.vt1"
INFO:  "vt1": scanned 1 of 1 pages, containing 2 live rows and 2 dead rows; 2 rows in sample, 2 estimated total rows
VACUUM
```

<br>

### SKIP_LOCKED
- 바큠의 경우 `Shared Update Exclusive` 모드의 테이블 락이 필요한데 이는 `Share` 모드 이상과 호환이 안됨
- 바큠 작업으로 인한 락 충돌 상황에서 락을 대기하지 않고 바큠 작업을 건너뛰는 옵션임
- 특히 여러 개의 테이블에 대해서 바큠 작업을 순차적으로 처리할 떄 유용하게 사용이 가능함
- 진행 가능한 테이블만 우선 처리하고, 스킵한 테이블은 별도로 다시 처리하는 유연한 운영이 가능해짐

```sql
-- 세션#1) 트랜잭션 시작
postgres=# begin;

-- 세션#1) 인덱스 생성
postgres=*# create index vt1_n2 on vt1(c2);

-- 세션#2) 바큠 수행 + 락 대기로 인해서 명령어 중단요청
postgres=# vacuum (verbose) vt1;
^CCancel request sent
ERROR:  canceling statement due to user request

-- 세션#2) SKIP_LOCKED 옵션을 사용해서 바큠 수행
postgres=# vacuum (verbose, skip_locked) vt1;
WARNING:  skipping vacuum of "vt1" --- lock not available
```

<br>

### INDEX_CLEANUP
- 바큠을 수행하면 기본적으로 테이블과 해당 테이블에 존재하는 모든 인덱스에 작업이 수행됨
- 위 옵션은 인덱스에 대한 바큠 작업 수행 여부를 결정하는 옵션으로 기본값은 `AUTO` 이다
- `AUTO` 값의 경우 데드 튜플의 개수를 기준으로 인덱스 바큠 작업 수행 여부를 PG가 알아서 판단한다
- 만약 `OFF`인 경우 인덱스에 대해서 바큠 작업은 수행하지 않는다
- 인덱스 바큠은 테이블 바큠보다 매우 오랜 시간이 소요되는 작업으로 대용량 테이블의 데드 튜플 정리와 Frozen 작업만 빠르게 처리하고자 할 때 인덱스 바큠 작업을 생략하는것도 고려가 가능하다

```sql
ROLLBACK
postgres=# vacuum (verbose, index_cleanup off) vt1;
INFO:  vacuuming "postgres.public.vt1"
INFO:  finished vacuuming "postgres.public.vt1": index scans: 0
pages: 0 removed, 1 remain, 1 scanned (100.00% of total)
tuples: 0 removed, 4 remain, 2 are dead but not yet removable
removable cutoff: 4860456, which was 6031 XIDs old when operation ended
frozen: 0 pages from table (0.00% of total) had 0 tuples frozen
index scan bypassed: 0 pages from table (0.00% of total) have 0 dead item identifiers
avg read rate: 0.000 MB/s, avg write rate: 0.000 MB/s
buffer usage: 14 hits, 0 misses, 0 dirtied
WAL usage: 0 records, 0 full page images, 0 bytes
system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s
```

<br>

#### 파라미터 따로 설정하기
- INDEX_CLEANUP의 경우 테이블 단위로 설정이 가능한 스토리지 파라미터다
- 설정값은 수동 및 자동 바큠 모두 적용되며 오토바큠이 인덱스 바큠 작업을 장시간 수행한다면 꺼놓고 나중에 수동으로 처리도 가능하다

```sql
-- index_cleanup 비활성화
postgres=# alter table vt1 set (vacuum_index_cleanup=off);

-- pg_class 카탈로그 테이블에서 설정된 값 확인
postgres=# select reloptions from pg_class where relname='vt1';
         reloptions         
----------------------------
 {vacuum_index_cleanup=off}
```

<br>

### TRUNCATE
- 테이블 맨 뒤부터 일정 크기 이상의 공간이 모두 빈 공간으로 정리되었을때 해당 공간을 OS에 반납할지 결정하는 옵션
- 기본값은 ON이며 빈 공간은 OS에 자동으로 반환함
  - 정리된 페이지 수가 1000개 이상이거나 테이블 전체 크기의 6.25% 이상이면 반납함
- 빈 공간을 OS에 반납하면 테이블의 물리적 파일 크기가 줄어들어서 디스크 사용량 절감 효과가 있음
- 하지만 만약 `INDEX_CLEANUP` 옵션이 꺼져있다면 `TRUNCATE`는 동작하지 않으므로 확인해봐야한다
- 바큠 풀과 마찬가지로 `Access Exclusive` 락을 요청하지만 5초간 최대 100회까지 재시도하고 해당 단계를 스킵함
- 이러한 작업으로 인해서 백엔드 프로세스와 락 경합 이슈는 크게 발생하지 않음

```sql
-- index_cleanup 설정 초기화, 기본값인 AUTO으로 바뀜
postgres=# alter table vt1 reset (vacuum_index_cleanup);

-- 기존에 테이블에 있던 데이터 삭제
postgres=# truncate table vt1;

-- 테스트용 데이터 삽입
postgres=# insert into vt1 select i, i from generate_series(1, 1000000) i;

-- vt1 테이블 용량 확인, 35MB인 모습
postgres=# \dt+ vt1;
                                  List of relations
 Schema | Name | Type  |  Owner   | Persistence | Access method | Size  | Description 
--------+------+-------+----------+-------------+---------------+-------+-------------
 public | vt1  | table | postgres | permanent   | heap          | 35 MB | 
```

```sql
-- 일부 데이터 제거
postgres=# delete from vt1 where c1 > 50000;

-- 바큠 수행
postgres=# vacuum (verbose) vt1;
INFO:  vacuuming "postgres.public.vt1"
INFO:  finished vacuuming "postgres.public.vt1": index scans: 0
pages: 0 removed, 222 remain, 1 scanned (0.45% of total)
tuples: 0 removed, 50000 remain, 0 are dead but not yet removable
removable cutoff: 4866952, which was 0 XIDs old when operation ended
frozen: 0 pages from table (0.00% of total) had 0 tuples frozen
index scan not needed: 0 pages from table (0.00% of total) had 0 dead item identifiers removed
index "vt1_n1": pages: 2745 in total, 0 newly deleted, 2602 currently deleted, 2602 reusable
avg read rate: 0.000 MB/s, avg write rate: 4.452 MB/s
buffer usage: 5378 hits, 0 misses, 3 dirtied
WAL usage: 1 records, 0 full page images, 72 bytes
system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s

-- 바큠 수행 후 vt1 테이블 용량 확인, 1808kB인 모습
postgres=# \dt+ vt1;
                                   List of relations
 Schema | Name | Type  |  Owner   | Persistence | Access method |  Size   | Description 
--------+------+-------+----------+-------------+---------------+---------+-------------
 public | vt1  | table | postgres | permanent   | heap          | 1808 kB | 
```

<br>

#### 자동 재시도하고 스킵하는 모습
```sql
-- 세션#1) 트랜잭션 시간
postgres=# begin;

-- 세션#1) 데이터 조회
postgres=*# select * from vt1 where c1 = 1;
 c1 | c2 
----+----
  1 |  1

-- 세션#2) 데이터 삭제
postgres=# delete from vt1 where c1 > 50000;

-- 세션#2) 바큠 수행, 이 때 TRUNCATE 작업이 동작함
postgres=# vacuum (verbose) vt1;
INFO:  vacuuming "postgres.public.vt1"
INFO:  "vt1": stopping truncate due to conflicting lock request -- 락 경합으로 인해서 TRUNCATE가 생략된 모습
-- ...
```

<br>

### PARALLEL
- 인덱스에 대한 바큠 작업을 병렬로 수행하도록 설정하는 옵션
- 해당 기능은 수동 바큠시에만 적용되고 오토바큠에는 적용되지 않음
- 일반적으로 바큠 단계중에서 제일 오래 걸리는건 인덱스 정리 작업임
- 만약 테이블에 인덱스가 2개 이상이고 각 인덱스의 크기가 일정 수준 이상이면 백엔드 프로세스와 병렬 프로세스가 함께 인덱스 바큠 작업을 수행하게됨
- 인덱스 개수가 많은 대용량 테이블에 대한 바큠 작업 성능을 개선할 때 매우 유용함

<br>

#### 관련 파라미터
- max_parallel_maintenance_workers
  - 바큠 등 유지보수 작업에서 사용할 수 있는 전체 병렬 프로세스 수의 최대값
- max_parallel_workers_per_gather
  - 하나의 백엔드 프로세스가 사용할 수 있는 병렬 프로세스 수의 최대값

<br>

#### 인덱스 생성하고 데드 튜플 만들기
```sql
-- 새로운 컬럼 추가
postgres=# alter table vt1 add column c3 integer;

-- 새로운 인덱스 추가
postgres=# create index vt1_n2 on vt1(c2);
postgres=# create index vt1_n3 on vt1(c3);
postgres=# create index vt1_n4 on vt1(c1, c2);
postgres=# create index vt1_n5 on vt1(c1, c3);
postgres=# create index vt1_n6 on vt1(c1, c2, c3);
postgres=# create index vt1_n6 on vt1(c1^Cc2, c3);

-- 데이터 10만건 추가
postgres=# insert into vt1 select i, i from generate_series(1, 100000) i;

-- 일부 데이터 삭제, 해당 과정에서 데드 튜플이 생성됨
postgres=# delete from vt1 where c1 > 50000;
```

<br>

#### 기본값(2개)으로 바큠 실행
```sql
postgres=# vacuum (verbose, parallel 6) vt1;
INFO:  vacuuming "postgres.public.vt1"
INFO:  launched 2 parallel vacuum workers for index cleanup (planned: 2) -- 2개의 병렬 워커
INFO:  finished vacuuming "postgres.public.vt1": index scans: 0
pages: 0 removed, 222 remain, 1 scanned (0.45% of total)
tuples: 0 removed, 50000 remain, 0 are dead but not yet removable
removable cutoff: 4866972, which was 0 XIDs old when operation ended
frozen: 0 pages from table (0.00% of total) had 0 tuples frozen
index scan not needed: 0 pages from table (0.00% of total) had 0 dead item identifiers removed
index "vt1_n1": pages: 276 in total, 0 newly deleted, 136 currently deleted, 136 reusable
index "vt1_n2": pages: 276 in total, 0 newly deleted, 136 currently deleted, 136 reusable
index "vt1_n3": pages: 81 in total, 0 newly deleted, 38 currently deleted, 38 reusable
index "vt1_n4": pages: 276 in total, 0 newly deleted, 136 currently deleted, 136 reusable
index "vt1_n5": pages: 386 in total, 0 newly deleted, 191 currently deleted, 191 reusable
index "vt1_n6": pages: 386 in total, 0 newly deleted, 191 currently deleted, 191 reusable
avg read rate: 0.000 MB/s, avg write rate: 10.192 MB/s
buffer usage: 2583 hits, 0 misses, 18 dirtied
WAL usage: 6 records, 0 full page images, 432 bytes
system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.01 s
```

<br>

#### 워커 수 조정 후 다시 바큠 실행
```sql
-- 파라미터 조정 & 설정 리로딩
postgres=# alter system set max_parallel_maintenance_workers=8;
postgres=# alter system set max_parallel_workers_per_gather=8;
postgres=# select pg_reload_conf();

-- 데드 튜플 재생성
postgres=# truncate vt1;
postgres=# insert into vt1 select i, i from generate_series(1, 100000) i;
postgres=# delete from vt1 where c1 > 50000;

-- 워커 6개로 바큠 실행
postgres=# vacuum (verbose, parallel 6) vt1;
INFO:  vacuuming "postgres.public.vt1"
INFO:  launched 5 parallel vacuum workers for index cleanup (planned: 5) -- 5개의 병렬 워커
INFO:  finished vacuuming "postgres.public.vt1": index scans: 0
pages: 0 removed, 222 remain, 1 scanned (0.45% of total)
tuples: 0 removed, 50000 remain, 0 are dead but not yet removable
removable cutoff: 4866977, which was 0 XIDs old when operation ended
frozen: 0 pages from table (0.00% of total) had 0 tuples frozen
index scan not needed: 0 pages from table (0.00% of total) had 0 dead item identifiers removed
index "vt1_n1": pages: 276 in total, 0 newly deleted, 136 currently deleted, 136 reusable
index "vt1_n2": pages: 276 in total, 0 newly deleted, 136 currently deleted, 136 reusable
index "vt1_n3": pages: 81 in total, 0 newly deleted, 38 currently deleted, 38 reusable
index "vt1_n4": pages: 276 in total, 0 newly deleted, 136 currently deleted, 136 reusable
index "vt1_n5": pages: 386 in total, 0 newly deleted, 191 currently deleted, 191 reusable
index "vt1_n6": pages: 386 in total, 0 newly deleted, 191 currently deleted, 191 reusable
avg read rate: 0.000 MB/s, avg write rate: 11.393 MB/s
buffer usage: 2587 hits, 0 misses, 18 dirtied
WAL usage: 6 records, 0 full page images, 432 bytes
system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.01 s
```

<br>

## 바큠 유형별 WAL 발생량
### 테스트 환경 만들기
```sql
-- vt1, vt2 테이블에 대해서 10만건 데이터 삽입
postgres=# insert into vt1 select i, i from generate_series(1, 100000) i;
postgres=# insert into vt2 select i, i from generate_series(1, 100000) i;

-- 테이블 크기 확인
-- 두 테이블 모두 3568kb인 상태
postgres=# \dt+ vt*
                                   List of relations
 Schema | Name | Type  |  Owner   | Persistence | Access method |  Size   | Description 
--------+------+-------+----------+-------------+---------------+---------+-------------
 public | vt1  | table | postgres | permanent   | heap          | 3568 kB | 
 public | vt2  | table | postgres | permanent   | heap          | 3568 kB | 
```

<br>

### 데드 튜플 만들기
```sql
postgres=# update vt1 set c2 = c2 + 1;
UPDATE 100000
postgres=# update vt2 set c2 = c2 + 1;
UPDATE 100000
postgres=# 
postgres=# \dt+ vt*
                                   List of relations
 Schema | Name | Type  |  Owner   | Persistence | Access method |  Size   | Description 
--------+------+-------+----------+-------------+---------------+---------+-------------
 public | vt1  | table | postgres | permanent   | heap          | 7112 kB | 
 public | vt2  | table | postgres | permanent   | heap          | 7112 kB | 
```

<br>

### 일반 바큠 수행시 WAL 발생량 측정
- 일반 바큠의 경우 `t_infomask` 컬럼의 9번쨰 비트를 수정함
- VM 및 FSM 파일을 갱신함
- 변경량이 매우 작아서 WAL 발생량도 매우 적음
```sql
-- 바큠 수행 전 LSN 확인
postgres=# select pg_current_wal_lsn(); -- 0/B4220F78

-- 바큠 수행
postgres=# vacuum vt1;

-- 바큠 수행 후 LSN 확인
postgres=# select pg_current_wal_lsn(); -- 0/B4220FC0

-- LSN 차이 계산
postgres=# select pg_size_pretty(pg_wal_lsn_diff('0/B4220FC0', '0/B4220F78')); -- 72 bytes
```

<br>

### VACUUM FULL 수행시 WAL 발생량 측정
- 새로운 테이블을 생성하고 데이터를 다시 입력하는 작업을 숳랭함
- 그래서 테이블 크기에 상응하는 많은 양의 WAL이 발생한다

```sql
-- 데드 튜플 발생시키기
postgres=# update vt1 set c2 = c2 + 1;

-- 바큠 풀 수행 전 LSN 확인
postgres=# select pg_current_wal_lsn(); -- 0/BC454A88

-- 바큠 풀 수행
postgres=# VACUUM FULL vt1;

-- 바큠 풀 수행 후 LSN 확인
postgres=# select pg_current_wal_lsn(); -- 0/BD3BB148

-- 바큠 풀 수행 후 LSN 차이 계산
postgres=# select pg_size_pretty(pg_wal_lsn_diff('0/BD3BB148', '0/BC454A88')); -- 15 MB
```

<br>

### FREEZE 옵션 수행 시 WAL 발생량 측정
- 모든 레코드를 Frozen 상태로 변경하고 `t_infomask` 컬럼의 9, 10번째 비트를 모두 1로 변경함
- 하지만 변경되는 정보량은 여전히 적어서 WAL 발생량도 크진 않음

```sql
-- 데드 튜플 발생시키기
postgres=# update vt1 set c2 = c2 + 1;

-- 바큠 풀 수행 전 LSN 확인
postgres=# select pg_current_wal_lsn(); -- 0/C10E8A38

-- 바큠 풀 수행
postgres=# VACUUM (freeze) vt1;

-- 바큠 풀 수행 후 LSN 확인
postgres=# select pg_current_wal_lsn(); -- 0/C13983E0

-- LSN 차이 계산
postgres=# select pg_size_pretty(pg_wal_lsn_diff('0/C13983E0', '0/C10E8A38')); -- 2750 kB
```

<br>

### 체크포인트 이후 FREEZE 수행 시 WAL 증가
- Frozen 작업은 MVCC 정합성과 밀접한 관련이 있음
- 그래서 체크포인트 이후에는 `FPW(Full Page Write)` 방식으로 처리므로 WAL 발생량도 증가하게됨

```sql
-- 데드 튜플 발생시키기
postgres=# update vt1 set c2 = c2 + 1;

-- 체크포인트 수행
postgres=# checkpoint;

-- 체크포인트 이후 LSN 확인
postgres=# select pg_current_wal_lsn(); -- 0/C498C810

-- 바큠 풀 수행
postgres=# vacuum (freeze) vt1;

-- 바큠 풀 수행 후 LSN 확인
postgres=# select pg_current_wal_lsn(); -- 0/C59E0B80

-- LSN 차이 계산
postgres=# select pg_size_pretty(pg_wal_lsn_diff('0/C59E0B80', '0/C498C810')); -- 16 MB
```


<br>

## 바큠 작업 수행 시 페이지 내의 변경 사항
### 오토 바큠 비활성화 및 테스트 환경 구성
```sql
-- 오토 바큠 비활성화
postgres=# alter system set autovacuum=off;

-- 설정 리로딩
postgres=# select pg_reload_conf();

-- 기존 테이블 삭제
postgres=# drop table vt1;

-- 새로운 테이블 생성
postgres=# create table vt1 (c1 integer, c2 integer);

-- 현재 트랜잭션 아이디 확인
postgres=# select pg_current_xact_id(); -- 4867005
```

<br>

### 레코드 추가 및 페이지 상태 확인
- t_xmin 컬럼에는 현재 트랜잭션의 아이디가 기록됨
- t_xmax 컬럼은 0으로 되어있는데 이는 해당 레코드가 라이브 튜플임을 나타냄

```sql
-- 2건 삽입
postgres=# insert into vt1 select i, i from generate_series(1, 2) i;

-- 현재 시점에서 테이블 블록 확인
postgres=# select lp, t_xmin, t_xmax from heap_page_items(get_raw_page('vt1', 0));
  lp | t_xmin  | t_xmax 
----+---------+--------
  1 | 4867006 |      0
  2 | 4867006 |      0
```

<br>

### 데드 튜플 생성
- `UPDATE` 작업 수행을 통해서 2개의 데드 튜플을 만듦
- 이후에 `pg_stat_all_tables` 뷰를 조회하면 데드 튜플이 2건 존재하는걸 확인할 수 있음

```sql
-- 데드 튜플 2개 만들기
postgres=# update vt1 set c2 = c2 + 1;

-- 데드 튜플 확인
postgres=# select relname, n_tup_ins, n_tup_upd, n_dead_tup, last_vacuum from pg_stat_all_tables where relname in ('vt1');
 relname | n_tup_ins | n_tup_upd | n_dead_tup | last_vacuum 
---------+-----------+-----------+------------+-------------
 vt1     |         2 |         2 |          2 | 

-- 현재 시점에서 테이블 블록 확인
postgres=# select lp, t_xmin, t_xmax from heap_page_items(get_raw_page('vt1', 0));
 lp | t_xmin  | t_xmax  
----+---------+---------
  1 | 4867006 | 4867007 -- 데드 튜플
  2 | 4867006 | 4867007 -- 데드 튜플
  3 | 4867007 |       0 -- 라이브 튜플
  4 | 4867007 |       0 -- 라이브 튜플
(4 rows)
```

<br>

### 반복 업데이트로 데드 튜플 증가시키기
- 또 업데이트를 진행하면 데드 튜플이 증가하게됨
- 하지만 다행히 `싱글 페이지 클린업` 기능을 통해서 이러한 데드 튜플은 주기적으로 정리되서 계속 무한히 증가하진 않음
  - 싱글 페이지 클린업 : 데이터 블록을 엑세스한 백엔드 프로세스가 해당 블록의 데드 튜플을 정리하는 작업

```sql
postgres=# update vt1 set c2 = c2 + 1;
postgres=# select lp, t_xmin, t_xmax from heap_page_items(get_raw_page('vt1', 0));
 lp | t_xmin  | t_xmax  
----+---------+---------
  1 | 4867006 | 4867007
  2 | 4867006 | 4867007
  3 | 4867007 | 4867008
  4 | 4867007 | 4867008
  5 | 4867008 |       0
  6 | 4867008 |       0
```

<br>

### 바큠 수행 후 페이지 상태
- 이전에 발생했던 데드 튜플을 바큠 수행을 통해서 정리한다
- 기존 데드 튜플이 차지하던 공간이 정리되어서 재사용 가능한 상태로 변경된다

```sql
postgres=# vacuum vt1;
postgres=# select lp, t_xmin, t_xmax from heap_page_items(get_raw_page('vt1', 0));
 lp | t_xmin  | t_xmax 
----+---------+--------
  1 |         |       
  2 |         |       
  3 |         |       
  4 |         |       
  5 | 4867008 |      0
  6 | 4867008 |      0
```

<br>

## vacuumlo를 이용한 Orphan LOB 정리방법
- PG는 `BYTEA`, `TEXT`, `OID` 3가지 타입의 LOB(Large Object)를 지원함
- OID 타입의 경우 LOB를 `pg_largeobject` 시스템 테이블에 저장하는데 이 때 `Orphan LOB` 문제가 발생할 수 있음

<br>

### Orphan LOB 문제
- OID 타입을 사용하면 바큠이 수행되어도 `pg_largeobject`에 남아있는 LOB 데이터가 정리되지 않는 문제가 있음
- 원본 데이터가 삭제된 후에 남아있는 LOB를 `Orphan LOB`라고 부름

<br>

#### 테이블 생성 및 데이터 추가
```sql
-- 테이블 생성
create table file_refs (
	id serial primary key,
	filename text,
	lo_oid oid
);

-- 데이터 삽입
do $$
declare
    i integer;
    lo_oid oid;
    data bytea := e'\\x41';
begin
    for i in 1..100000 loop
        lo_oid := lo_from_bytea(0, data);
        insert into file_refs (filename, lo_oid) values ('file_' || i || '.bin', lo_oid);

        if i % 10000 = 0 then
            raise notice '% lobs created with data', i;
        end if;
    end loop;
end $$;
```

<br>

#### 바큠 수행하기
```sql
-- 데이터가 삽입된 모습
postgres=# select count(*) from pg_largeobject;
 count  
--------
 100000
 
-- file_refs 테이블 바큠 수행
postgres=# vacuum (verbose) file_refs;
INFO:  vacuuming "postgres.public.file_refs"
INFO:  table "file_refs": truncated 637 to 0 pages
INFO:  finished vacuuming "postgres.public.file_refs": index scans: 1
pages: 637 removed, 0 remain, 637 scanned (100.00% of total)
tuples: 100000 removed, 0 remain, 0 are dead but not yet removable
removable cutoff: 4867012, which was 1 XIDs old when operation ended
new relfrozenxid: 4867012, which is 3 XIDs ahead of previous value
frozen: 0 pages from table (0.00% of total) had 0 tuples frozen
index scan needed: 637 pages from table (100.00% of total) had 100000 dead item identifiers removed
index "file_refs_pkey": pages: 276 in total, 273 newly deleted, 273 currently deleted, 0 reusable
avg read rate: 0.000 MB/s, avg write rate: 1.194 MB/s
buffer usage: 4203 hits, 0 misses, 4 dirtied
WAL usage: 2736 records, 2 full page images, 776813 bytes
system usage: CPU: user: 0.01 s, system: 0.00 s, elapsed: 0.02 s
INFO:  vacuuming "postgres.pg_toast.pg_toast_16577"
INFO:  finished vacuuming "postgres.pg_toast.pg_toast_16577": index scans: 0
pages: 0 removed, 0 remain, 0 scanned (100.00% of total)
tuples: 0 removed, 0 remain, 0 are dead but not yet removable
removable cutoff: 4867013, which was 0 XIDs old when operation ended
new relfrozenxid: 4867013, which is 4 XIDs ahead of previous value
frozen: 0 pages from table (100.00% of total) had 0 tuples frozen
index scan not needed: 0 pages from table (100.00% of total) had 0 dead item identifiers removed
avg read rate: 57.026 MB/s, avg write rate: 0.000 MB/s
buffer usage: 21 hits, 1 misses, 0 dirtied
WAL usage: 1 records, 0 full page images, 188 bytes
system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s

-- pg_largeobject 테이블 바큠 수행
postgres=# vacuum (verbose) pg_largeobject;
INFO:  vacuuming "postgres.pg_catalog.pg_largeobject"
INFO:  finished vacuuming "postgres.pg_catalog.pg_largeobject": index scans: 0
pages: 0 removed, 541 remain, 541 scanned (100.00% of total)
tuples: 0 removed, 100000 remain, 0 are dead but not yet removable
removable cutoff: 88659, which was 4778354 XIDs old when operation ended
new relfrozenxid: 88659, which is 87928 XIDs ahead of previous value
new relminmxid: 4758329, which is 4758328 MXIDs ahead of previous value
frozen: 0 pages from table (0.00% of total) had 0 tuples frozen
index scan not needed: 0 pages from table (0.00% of total) had 0 dead item identifiers removed
avg read rate: 0.000 MB/s, avg write rate: 4.703 MB/s
buffer usage: 1093 hits, 0 misses, 4 dirtied
WAL usage: 1 records, 1 full page images, 8097 bytes
system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s

-- 여전히 남아있는 10만건의 Orphan LOB
postgres=# select count(*) from pg_largeobject;
 count  
--------
 100000
```

<br>

### vacuumlo 명령어를 이용한 정리
- Orphan LOB는 `vacuumlo` 유틸리티를 통해서 정리가 가능함

```bash
root@b20fa9478609:/# vacuumlo -v postgres -U postgres
Connected to database "postgres"
Checking lo_oid in public.file_refs
Successfully removed 100000 large objects from database "postgres".
```

<br>

#### 테이블 크기도 정리하기
- vacuumlo를 통해서 Orphan LOB를 정리해도 테이블 파일 크기는 줄어들지 않음
- 테이블 파일 크기를 줄이기 위해서는 VACUUM FULL 작업 수행이 필요함

<br>

### 올바른 LOB 삭제 방식
- Orphan LOB는 앱의 LOB 삭제 로직 문제로 발생한다
- OID 타입의 LOB는 삭제 전에 반드시 `io_unlink()` 함수를 통해서 원본 테이블과 LOB간 연결 해제가 필요하다

```sql
-- 원본 테이블과 LOB간 연결 해제
postgres=# select lo_unlink(lo_oid) from file_refs;
 lo_unlink 
-----------
         1
         1
         1
         1
         1
         1
         1
         1
         1
         1

-- 원본 테이블 데이터 삭제
postgres=# delete from file_refs;
DELETE 10

-- 남아있는 Orphan LOB 확인
postgres=# select count(*) from pg_largeobject;
 count 
-------
     0
``` 

<br>

### 운영 시 고려사항
- 한번 커진 pg_largeobject 테이블 크기는 자동으로 줄어들지 않음
- 만약 해당 테이블을 사용한다면 모니터링하면서 주기적으로 `VACUUM FULL` 작업을 수행해야함
- OID 기반의 LOB를 잘못 사용하면 저장공간이 낭비될 수 있으므로 올바른 방식으로 삭제 처리 로직 구성이 필요함

<br>

## AGE
- AGE는 말 그대로 나이를 의미하며 일상적으로 얘기하는 나이 개념과 유사하다
- 테이블 생성된 시점이 생일이고 트랜잭션이 발생할 떄 마다 1살찍 나이를 먹는다고 생각하면된다
- 중요한 점은 해당 테이블에 트랜잭션이 직접 발생하지 않더라도 전체 시스템의 트랜잭션이 증가하면 테이블의 나이도 증가한다
- 즉 테이블은 생성 시점을 기준으로 나이가 계산된다

<br>

### PG에서 AGE를 관리하는 이유
- PG는 Frozen 처리를 위해서 현재 XID와 비교할 기준 값이 필요한데 이 값이 relfrozenxid이다
- 현재 XID와의 차이(age())가 바로 나이 이다
- 그래서 frozen 작업을 수행하면 AGE는 다시 0부터 시작하게된다

<br>

### 테이블 생성하고 나이 확인하기
```sql
-- at1 테이블 생성
postgres=# create table at1 (c1 integer);

-- at2 테이블 생성
postgres=# create table at2 (c1 integer);

-- at1 테이블 생성 당시에 나이는 1
-- at2 테이블이 생성되면서 at1은 1살을 더 먹음
postgres=# select relname, relfrozenxid, age(relfrozenxid) from pg_class where relname in ('at1', 'at2');
 relname | relfrozenxid | age 
---------+--------------+-----
 at1     |      4867127 |   2
 at2     |      4867128 |   1
```

<br>

### 레코드 입력 후 나이 변화
- 레코드의 나이는 `레코드 입력 시점의 XMIN`이랑 현재 XID의 차이로 계산함
- 레코드도 테이블과 동일하게 DB 내에 트랜잭션이 발생하면 나이가 증가함

```sql
-- 레코드 1개 추가
postgres=# insert into at1 values(1);

-- 테이블과 레코드 나이 출력
postgres=# select relname, relfrozenxid, age(relfrozenxid) from pg_class where relname in ('at1', 'at2') union all select '(at1)' || c1::text, xmin, age(xmin) from at1;
 relname | relfrozenxid | age 
---------+--------------+-----
 at1     |      4867127 |   3 -- 새로운 레코드가 추가되면서 2 -> 3
 at2     |      4867128 |   2 -- 새로운 레코드가 추가되면서 1 -> 2
 (at1)1  |      4867129 |   1 -- 새로운 레코드 추가
(3 rows)

```

<br>

### INSERT 1회 추가 후 나이 변화
```sql
postgres=# insert into at1 values(2);

postgres=# select relname, relfrozenxid, age(relfrozenxid) from pg_class where relname in ('at1', 'at2') union all select '(at1)' || c1::text, xmin, age(xmin) from at1;
 relname | relfrozenxid | age 
---------+--------------+-----
 at1     |      4867127 |   4
 at2     |      4867128 |   3
 (at1)1  |      4867129 |   2
 (at1)2  |      4867130 |   1
```

<br>

## Visibility Map
- PG의 MVCC 특성으로 인해서 필요한 오브젝트다
- 각 테이블 블록당 2bit로 구성되며 각 비트는 해당 블록 내 레코드의 가시성 및 Frozen 상태를 나타냄

<br>

### ALL_VISIBLE 비트
- 모든 레코드가 모든 트랜잭션에게 가시적인 상태일 경우 1로 설정됨
- 하나라도 가시성이 보장되지 않으면 0으로 유지됨
- VACUUM 명령어가 수행된 직후에는 모든 블록의 ALL_VISIBLE 비트가 1로 설정됨
- 다시 하나라도 변경되면 0으로 설정됨
- ALL_VISIBLE = 1인 블록만 `Index Only Scan` 방식으로 수행이 가능함

<br>

### ALL_FROZEN 비트
- 블록 내의 모든 레코드가 Frozen 상태인 경우 이 비트는 1로 설정됨
- 그렇지 않다면 0으로 설정되며 향후 Frozen 작업 대상으로 간주됨

<br>

### VACUUM FULL 작업 직후에 VACUUM 작업의 필요성
- VACUUM FULL 내부에는 FREEZE 작업도 포함되므로 9, 10번째 비트가 모두 1로 설정됨
- 하지만 VACUUM FULL 이후에는 자동으로 VM 파일이 만들어지지 않아서 VM 파일이 갖는 장점 활용이 불가능함
- 그래서 VACUUM FULL 이후에는 단스이 `VACUUM` or `VACUUM (FREEZE)`을 통해서 VM을 생성해야한다