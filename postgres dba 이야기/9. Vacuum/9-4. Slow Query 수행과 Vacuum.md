## Slow Query 수행과 Vacuum
- 슬로우 쿼리가 존재할 때 바큠 작업이 데드 튜플을 정상적으로 정리하지 못하는 현상이 존재한다
- 하지만 대부분의 시스템에선 문제가 안되ㅑ는데 블록 IO 관점에서 보면 실제로 읽어야 할 블록 수가 크게 증가하지 않는다
- 하지만 동일 레코드에 대해서 반복적으로 변경이 수행되면 문제가 될 수 있는데 이는 데드 튜플 정리가 지연되면서 불필요한 저장공간 낭비가 발생하고 성능저하로 이어질 수 있기 때문임

<br>

## 데드 튜플 삭제 기준 (Cutoff) 정책
- DBMS는 다수의 유저가 동시에 데이터를 조회하고 변경하는 시스템임
- 언제나 수많은 쿼리가 동시에 실행되고 이 과정에서 데드 튜플이 지속적으로 발생하게됨
- 데드 튜플의 경우 MVCC 읽기 일관성 보장을 위해서 반드시 필요한 정보임
- 만약 바큠이 실행될 때 마다 모든 데드 튜플을 제거한다면 과거 시점의 데이터를 참조중인 쿼리에서는 `Snapshot Too Old` 에러가 발생함

<br>

### 삭제 기준 : PostgreSQL의 Cutoff 정책
- PG는 이런 문제 해결을 위해서 데드 튜플을 안전하게 삭제할 수 있는 기준점을 설정함
- 해당 기준점은 현재 수행 중인 쿼리들 중에서 가장 오래전에 시작된 쿼리의 XID를 기준으로 삼음
- 즉 바큠 작업은 가장 오래된 쿼리의 시작 시점보다 더 과거에 생성된 데드 튜플만 삭제가 가능함
- 이러한 값은 `pg_stat_activity.backend_xmin` 컬럼에서 확인이 가능함

<br>

### 중요한 특징
- Cutoff 기준점은 테이블 단위가 아닌 디비 전체에서 단 하나만 설정됨 
- 특정 테이블을 조회하는 슬로우 쿼리가 수행중인 경우 이 기준은 디비 전체에 공통으로 적용된다
- 그래서 슬로우 쿼리로 인한 나머지 다른 모든 테이블의 바큠 작업에 영항을 미치게된다
  
<br>

### 슬로우 쿼리가 없는 경우 바큠 결과
- 슬로우 쿼리가 없는 경우 바큠 작업은 데드 튜플을 정상적으로 정리할 수 있음
```sql
-- 신규 테이블 생성 & 레코드 추가
postgres=# create table vt1 (c1 integer, c2 integer);
postgres=# insert into vt1 values(1, 1);

-- 데드 튜플 만들기
postgres=# update vt1 set c2 = c2 + 1;

-- 바큠 실행 전 블록 상태
postgres=# select lp, t_xmin, t_xmax, t_data from heap_page_items(get_raw_page('vt1', 0));
 lp | t_xmin  | t_xmax  |       t_data       
----+---------+---------+--------------------
  1 | 4867133 | 4867134 | \x0100000001000000
  2 | 4867134 |       0 | \x0100000002000000

-- 바큠 수행
postgres=# vacuum vt1;

-- 바큠 수행 이후 블록 상태
postgres=# select lp, t_xmin, t_xmax, t_data from heap_page_items(get_raw_page('vt1', 0));
 lp | t_xmin  | t_xmax |       t_data       
----+---------+--------+--------------------
  1 |         |        | 
  2 | 4867134 |      0 | \x0100000002000000
```

<br>

### 슬로우 쿼리가 있는 경우 바큠 결과
```sql
-- 데드 튜플 생성
postgres=# update vt1 set c2 = c2 + 1;

-- 바큠 실행 전 블록 상태, 데드 튜플이 1개 존재함
postgres=# select lp, t_xmin, t_xmax, t_data from heap_page_items(get_raw_page('vt1', 0));
 lp | t_xmin  | t_xmax  |       t_data       
----+---------+---------+--------------------
  1 | 4867133 | 4867134 | \x0100000001000000
  2 | 4867134 |       0 | \x0100000002000000

-- 바큠 수행
postgres=# vacuum vt1;

-- 바큠 수행 후 데드 튜플이 제거된 모습
postgres=# select lp, t_xmin, t_xmax, t_data from heap_page_items(get_raw_page('vt1', 0));
 lp | t_xmin  | t_xmax |       t_data       
----+---------+--------+--------------------
  1 |         |        | 
  2 | 4867134 |      0 | \x0100000002000000

-- 데드 튜플 여러개 더 생성
postgres=# update vt1 set c2 = c2 + 1;
postgres=# update vt1 set c2 = c2 + 1;
postgres=# update vt1 set c2 = c2 + 1;

-- 여러개 생성한 직후 블록 모습
postgres=# select lp, t_xmin, t_xmax, t_data from heap_page_items(get_raw_page('vt1', 0));
 lp | t_xmin  | t_xmax  |       t_data       
----+---------+---------+--------------------
  1 |         |         | 
  2 | 4867134 | 4867135 | \x0100000002000000
  3 | 4867135 | 4867136 | \x0100000003000000
  4 | 4867136 | 4867137 | \x0100000004000000
  5 | 4867137 |       0 | \x0100000005000000


-- 다른 세션에서 슬로우쿼리 실행
postgres=# select pg_sleep(10000);

-- 바큠 수행
postgres=# vacuum vt1;

-- 바큠을 수행해도 데드 튜플이 삭제되지 않고 존재하는 모습
postgres=# select lp, t_xmin, t_xmax, t_data from heap_page_items(get_raw_page('vt1', 0));
 lp | t_xmin  | t_xmax  |       t_data       
----+---------+---------+--------------------
  1 |         |         | 
  2 |         |         | 
  3 | 4867135 | 4867136 | \x0100000003000000
  4 | 4867136 | 4867137 | \x0100000004000000
  5 | 4867137 |       0 | \x0100000005000000

-- t_xmax 부분에 슬로우 쿼리의 XID가 기록된 모습, 해당 시점 이후로는 데드 튜플이 제거되지 않음
postgres=# select backend_xmin, query from pg_stat_activity order by backend_xmin::text::bigint limit 1;
 backend_xmin |          query          
--------------+-------------------------
      4867136 | select pg_sleep(10000);
```

<br>

### 요약
- 결국 슬로우 쿼리의 수행 시간이 길어질수록 바큠 작업이 데드 튜플을 정리하지 못하고 계속 쌓이게됨
- 장시간 수행되는 쿼리에 대한 모니터링과 반복적으로 동일 헤코드를 변경하는 패턴에 대한 개선이 필요함
- 하지만 일반적인 환경에서는 이로 인한 성능 저하가 거의 발생하지 않음

<br>

## 테스트를 통한 동일 레코드 반복 업데이트시 문제점 확인
- 일반적인 경우는 아니지만 짧은 시간 동안 동일 레코드를 반복적으로 업데이트하는 업무가 존재하긴함
- 예를 들면 쇼핑몰에서 세일 이벤트 클릭 수 집계를 위해서 사용자가 이벤트를 클릭할 때 마다 레코드를 업데이트하는 경우임

<br>

### 테스트 환경 구성
```sql
postgres=# create table sale_event (event_id integer, click_count integer);
postgres=# alter table sale_event add constraint sale_event_pk primary key (event_id);
postgres=# insert into sale_event values (1, 0);
```

<br>

### 슬로우 쿼리 미 수행시 : 부하 테스트
- 약 4만번의 동일 레코드 수정이 발생했으나 테이블은 2블록(8192 바이트)으로 크기가 딱히 증가하지 않았음
- 그 이유는 백엔드 프로세스에서 처리하는 `싱글 페이지 클린업`으로 인해서 데드 튜플이 제거되고 있기 때문임
```bash
root@b20fa9478609:/# cat event_update.sql 
update sale_event set click_count = click_count + 1 where event_id = 1;
root@b20fa9478609:/# pgbench -U postgres -d postgres -n -f event_update.sql -c 1 -j 1 -T 7200
```
```sql
postgres=# select * from sale_event where event_id = 1;
-- 39153번 동일 레코드가 수정됨
 event_id | click_count 
----------+-------------
        1 |       39153

-- 실행계획 확인
-- 조회 시의 일량은 2블록으로 매우 정상적
postgres=# explain (analyze, buffers, costs off) select * from sale_event where event_id = 1;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Index Scan using sale_event_pk on sale_event (actual time=0.050..0.052 rows=1 loops=1)
   Index Cond: (event_id = 1)
   Buffers: shared hit=2
 Planning Time: 0.151 ms
 Execution Time: 0.081 ms
(5 rows)

-- 테이블 크기 확인, 8192 바이트
postgres=# \dt+ sale_event;
                                        List of relations
 Schema |    Name    | Type  |  Owner   | Persistence | Access method |    Size    | Description 
--------+------------+-------+----------+-------------+---------------+------------+-------------
 public | sale_event | table | postgres | permanent   | heap          | 8192 bytes | 
```

```sql
postgres=# select lp, t_xmin, t_xmax, t_data from heap_page_items(get_raw_page('sale_event', 0));
173 | 4906289 | 4906290 | \x01000000ed980000
174 | 4906290 | 4906291 | \x01000000ee980000
175 | 4906291 | 4906292 | \x01000000ef980000
176 | 4906292 | 4906293 | \x01000000f0980000
177 | 4906293 |       0 | \x01000000f1980000
178 |         |         | 
179 |         |         | 
-- ...
180 |         |         | 
203 |         |         | 
204 | 4906117 | 4906118 | \x0100000041980000
```

<br>

### 슬로우 쿼리 수행 시 : 부하 테스트
```sql
-- 테이블, 제약조건, 데이터 재생성
postgres=# create table sale_event (event_id integer, click_count integer);
postgres=# alter table sale_event add constraint sale_event_pk primary key (event_id);
postgres=# insert into sale_event values (1, 0);

-- 슬로우 쿼리 실행
postgres=# select pg_sleep(10000);
```

```bash
# 부하테스트 실행
root@b20fa9478609:/# pgbench -U postgres -d postgres -n -f event_update.sql -c 1 -j 1 -T 7200
pgbench (17.6 (Debian 17.6-2.pgdg13+1))
```

```sql
-- 블록이 100배 이상 증가했음
postgres=# explain (analyze, buffers, costs off) select * from sale_event where event_id = 1;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Index Scan using sale_event_pk on sale_event (actual time=0.499..0.506 rows=1 loops=1)
   Index Cond: (event_id = 1)
   Buffers: shared hit=244 dirtied=1
 Planning:
   Buffers: shared hit=3
 Planning Time: 1.962 ms
 Execution Time: 0.553 ms
(7 rows)

-- 테이블 크기 확인, 1960 kB로 증가함
postgres=# \dt+ sale_event;
                                      List of relations
 Schema |    Name    | Type  |  Owner   | Persistence | Access method |  Size   | Description 
--------+------------+-------+----------+-------------+---------------+---------+-------------
 public | sale_event | table | postgres | permanent   | heap          | 1960 kB | 
```

<br>

### 바큠 테스트
```sql
postgres=# vacuum (verbose) sale_event;
INFO:  vacuuming "postgres.public.sale_event"
INFO:  finished vacuuming "postgres.public.sale_event": index scans: 1
pages: 0 removed, 242 remain, 242 scanned (100.00% of total)
tuples: 0 removed, 1 remain, 0 are dead but not yet removable
removable cutoff: 4960976, which was 0 XIDs old when operation ended
new relfrozenxid: 4960975, which is 54680 XIDs ahead of previous value
frozen: 0 pages from table (0.00% of total) had 0 tuples frozen
index scan needed: 241 pages from table (99.59% of total) had 241 dead item identifiers removed
index "sale_event_pk": pages: 2 in total, 0 newly deleted, 0 currently deleted, 0 reusable
avg read rate: 0.000 MB/s, avg write rate: 23.848 MB/s
buffer usage: 739 hits, 0 misses, 5 dirtied
WAL usage: 486 records, 2 full page images, 40772 bytes
system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s
VACUUM

postgres=# select backend_xmin, query from pg_stat_activity order by backend_xmin::text::bigint limit 1;
 backend_xmin |                                             query                                             
--------------+-----------------------------------------------------------------------------------------------
      4960976 | select backend_xmin, query from pg_stat_activity order by backend_xmin::text::bigint limit 1;
```

<br>

### XID Gap 모니터링을 통한 대응 방법
- 동일 레코드에 대한 반복적인 변경이 발생할 수 있는 이벤트 구간에서는 세션을 집중적으로 모니터링해서 슬로우 쿼리의 유무를 확인하는 것이 가장 일반적인 대응 방법임
- `Current XID`와 `pg_stat_activity.backend_xmin` 컬럼을 통해서 현재 수행중인 쿼리의 XID와 가장 오래된 쿼리의 XID를 비교해서 XID Gap을 확인할 수 있음
- Gap이 일정 수준 이상으로 계속 커진다면 동일 레코드 반복변경으로 인한 성능 저하가 발생하고 있는 상황으로 판단이 가능함

```sql
postgres=# select pg_current_xact_id()::text::bigint - min(backend_xmin::text::bigint) from pg_stat_activity;
```