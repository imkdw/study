## SQL 모니터링
- 디비 성능을 개선하는 활동은 매우 다양한데 OS레벨, 디비 인스턴스 레벨 등이 있다
- 하지만 가장 직접적인 효과를 줄 수 있는 것은 SQL 튜닝이다
- 1회 수행 시 응답 시간이 느린 쿼리, 반복 수행으로 시스템 자원을 과도하게 사용하는 쿼리 등 이 존재한다

<br>

## 1회 수행 시 응답시간이 느린 쿼리 모니터링
- `log_min_duration_statement`의 값보다 오래 실행된 쿼리는 자동으로 로그 파일에 기록된다
- 만약 1000으로 설정하면 1초 이상 수행된 쿼리는 로그 파일에 기록된다
- 바인드 방식으로 실행된 쿼리의 경우는 바인드 변수에 입력된 실제 값도 함께 기록된다
- 주의점은 정상적으로 처리된 쿼리만 로그에 기록된다는 점이다

<br>

### 슬로우 쿼리 확인 방법
- MySQL 처럼 별도의 파일을 제공하지 않기때문에 일반 로그 파일에서 duration 키워드로 검색이 필요하다

```sql
-- 1초 이상 걸린 쿼리를 로그 파일에 기록
postgres=# SET log_min_duration_statement = 1000;

-- 5초 동안 대기
postgres=# SELECT pg_sleep(5);
```
```bash
root@dff5953eda06:/var/lib/postgresql/data/log# cat postgresql-2025-11-07_143835.log 
# ...
2025-11-07 14:39:03.759 UTC [41] STATEMENT:  select sleep(5);
2025-11-07 14:39:11.640 UTC [41] LOG:  duration: 5006.742 ms  statement: select pg_sleep(5);
root@dff5953eda06:/var/lib/postgresql/data/log# `
```

<br>

## 런타임 실행계획 확인 : auto_explain 활용
- `explain (analyze, buffers)` 명령어를 이용해서 쿼리 실행 시의 실행 계확과 일량을 직접 분석 가능함
- 쿼리를 다시 실행하는 경우는 매우 빠르게 수행될 수 있는데 이런 경우는 로그에 기록된 시점의 실행 계확과 현재 실행 계확을 비교해서 으답 시간 차이가 실행 계획 변경 때문인지 디스크 I/O 때문인지 파악이 필요함
- `auto_explain` 확장은 일정 시간 이상 수행된 쿼리에 대해서 실제 실행계획이 로그에 자동으로 기록됨

<br>

### auto_explain 설정
- 배치 환경에서는 60초, 온라인 환경에서는 10초 정도로 설정하고 점차 시간을 조정하면됨

```bash
shared_preload_libraries = 'pg_stat_statements, auto_explain'
auto_explain.log_min_duration = 1s # 테스트를 위해서 1초로 설정
auto_explain.log_analyze = on
auto_explain.log_buffers = on
```

<br>

### 테스트하기
```sql
-- 1000만 건 데이터 삽입
postgres=# INSERT INTO svc.t1 (c1, c2, c3, c4)
SELECT 
    i,
    CASE WHEN i % 5 = 0 THEN 'A|B' 
         WHEN i % 5 = 1 THEN 'X|Y'
         WHEN i % 5 = 2 THEN 'P|Q'
         WHEN i % 5 = 3 THEN 'M|N'
         ELSE 'E|F' END,
    CASE WHEN i % 4 = 0 THEN 'C|D'
         WHEN i % 4 = 1 THEN 'G|H'
         WHEN i % 4 = 2 THEN 'K|L'
         ELSE 'R|S' END,
    (i % 100) + 1
FROM generate_series(3, 10000000) AS i;

-- 조회
postgres=# SELECT * FROM svc.t1 WHERE c2 = 'A|B' AND c3 = 'C|D';
```
```bash
2025-11-07 14:45:55.296 UTC [41] LOG:  duration: 8468.651 ms  plan:
        Query Text: INSERT INTO svc.t1 (c1, c2, c3, c4)
        SELECT 
            i,
            CASE WHEN i % 5 = 0 THEN 'A|B' 
                 WHEN i % 5 = 1 THEN 'X|Y'
                 WHEN i % 5 = 2 THEN 'P|Q'
                 WHEN i % 5 = 3 THEN 'M|N'
                 ELSE 'E|F' END,
            CASE WHEN i % 4 = 0 THEN 'C|D'
                 WHEN i % 4 = 1 THEN 'G|H'
                 WHEN i % 4 = 2 THEN 'K|L'
                 ELSE 'R|S' END,
            (i % 100) + 1
        FROM generate_series(3, 10000000) AS i;
        Insert on t1  (cost=0.00..549999.89 rows=0 width=0) (actual time=8468.606..8468.618 rows=0 loops=1)
          Buffers: shared hit=10108092 dirtied=54055 written=89226, temp read=17090 written=17090
          ->  Function Scan on generate_series i  (cost=0.00..549999.89 rows=9999998 width=84) (actual time=554.658..1887.623 rows=9999998 loops=1)
                Buffers: temp read=17090 written=17090
        JIT:
          Functions: 4
          Options: Inlining true, Optimization true, Expressions true, Deforming true
          Timing: Generation 0.384 ms (Deform 0.038 ms), Inlining 69.920 ms, Optimization 15.425 ms, Emission 16.581 ms, Total 102.310 ms
2025-11-07 14:45:55.308 UTC [41] LOG:  duration: 8822.697 ms  statement: INSERT INTO svc.t1 (c1, c2, c3, c4)
        SELECT 
            i,
            CASE WHEN i % 5 = 0 THEN 'A|B' 
                 WHEN i % 5 = 1 THEN 'X|Y'
                 WHEN i % 5 = 2 THEN 'P|Q'
                 WHEN i % 5 = 3 THEN 'M|N'
                 ELSE 'E|F' END,
            CASE WHEN i % 4 = 0 THEN 'C|D'
                 WHEN i % 4 = 1 THEN 'G|H'
                 WHEN i % 4 = 2 THEN 'K|L'
                 ELSE 'R|S' END,
            (i % 100) + 1
        FROM generate_series(3, 10000000) AS i;
```

<br>

## 반복 수행으로 과부하를 주는 쿼리 모니터링
- 일반적으로 성능을 튜닝할때는 슬로우 쿼리를 유발하는 쿼리를 우선으로 튜닝한다
- 하지만 으답 속도는 빠르지만 매우 자주 수행되는 쿼리들이 오히려 더 큰 부하를 유발하는 경우가 많다
- 예를 들어서 0.1초가 걸리지만 풀 스캔 쿼리는 인덱스를 생성하면 0.0001초 이내로 성능 개선이 가능하다
- 실제로 디스크 I/O 사용률 개선을 위해서는 개별 슬로우 쿼리보다는 빈번하게 수행되는 쿼리 최적화가 더 효과적인 경우가 많다

<br>

### pg_stat_statements 설정하기
```bash
pg_stat_statements.max = 10000
pg_stat_statements.track = all
track_activity_query_size = 64kb
```

<br>

### pg_stat_statements 쿼리 기본 정보 컬럼
- userid : 쿼리를 실행한 유저
- dbid : 쿼리가 실행된 디비 ID
- queryid :정규화된 쿼리의 해시값
- query : 정규화된 SQL 문장, 입력값은 변수로 치환됨

```sql
-- 기존 정보 초기화
postgres=# select pg_stat_statements_reset();

-- 쿼리 실행
postgres=# select pg_sleep(1) from generate_series(1, 1) i;

-- 쿼리 실행
postgres=# select pg_sleep(2) from generate-series(2, 2) i;

-- 쿼리 실행 후 정보 조회
postgres=# select userid, dbid, queryid, query from pg_stat_statements order by stats_since limit 3;
 userid | dbid |       queryid       |                       query                        
--------+------+---------------------+----------------------------------------------------
     10 |    5 | 5226144649890563814 | select pg_stat_statements_reset()
     10 |    5 | 9077879155684233118 | select pg_sleep($1) from generate_series($2, $3) i
     10 |    5 | 4463986769292944571 | select * from pg_stat_statements
```

<br>

### 파싱 수행 정보 컬럼
- `pg_stat_statements.track_planning` 파라미터를 활성화하면 파싱 관련 정보 확인이 가능함
- 일반적으로 OLTP 서비스의 경우 비활성화된 상태로 운영해도 큰 문제가 없음
- 하지만 SQL이 길고 복잡한 경우 파싱 정보를 수집해서 분석하는것도 좋음

<br>

### 응답 시간 정보 컬럼
- 쿼리의 응답 시간 정보를 제공함
- `total_exec_time` 컬럼을 통해서 디비 내에서 전체 실행 시간 비중이 높은 Top 쿼리를 쉽게 식별할 수 있음

```sql
postgres=# select dbid, queryid, query, total_exec_time from pg_stat_statements order by total_exec_time desc limit 1;
 dbid |       queryid       |                       query                        | total_exec_time 
------+---------------------+----------------------------------------------------+-----------------
    5 | 9077879155684233118 | select pg_sleep($1) from generate_series($2, $3) i |     3010.985278
```

<br>

### IO 정보 컬럼
- 쿼리 수행 시 발생하는 I/O 관련 통계 정보를 제공함
- 공유 버퍼 관련, Temporary 테이블 관련, 로컬 메모리 부족으로 인한 Temp 파일에 대한 I/O 확인이 가능하다

#### 공유 버퍼 관련
- 공유 버퍼 관련 I/O 정보는 `shared_`로 시작하는 컬럼에서 확인 가능하다
- 공유 버퍼에서 대량의 메모리 읽기를 수행하는 쿼리는 CPU 리소스를 많이 사용함
- CPU 사용률을 낮추기 위해서는 `shared_blks_hit` 값이 높은 쿼리부터 튜닝하는게 효과적이다

<br>

#### 디스크 I/O 관련
- 인덱스가 없거나 비효율적인 인덱스를 사용하는 경우가 많다
- shared_blks_read 값을 기준으로 쉽게 추출이 가능하고, 인덱스 추가나 쿼리 튜닝을 통해서 성능 개선이 가능하다

<br>

#### Temporary 테이블 관련
- `local_`로 시작하는 컬럼에서 확인이 가능하다
- local은 Temporary 테이블에 대한 작업 시발생하는 I/O를 의미하는 점에 유의한다

<br>

#### work_mem 부족으로 인해 생성되는 Temp 파일 I/O
- `temp_`로 시작하는 컬럼에서 확인 가능하다
- 일반적으로 work_mem 파라미터 값이 작아서 정렬이나 해시 작업 중 메모리가 부족할 떄 발생한다