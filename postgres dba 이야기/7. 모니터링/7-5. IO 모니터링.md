## I/O 모니터링
- I/O 모니터링은 성능을 개선하거나 성능 저하가 발생한 시점을 분석하기 위한 필수적인 작업임
- PG 16 버전부터 `pg_stat_io`뷰를 제공하는데 이를 통해서 시스템 레벨에서 I/O 성능을 모니터링할 수 있는 환경을 지원함

<br>

### 버퍼 엑세스 전략과 링 버퍼
#### 버퍼 엑세스 전략
- I/O 유형에 따라서 서로 다른 방식으로 버퍼를 엑세스하는 방법을 말함
- 전략을 구분해서 버퍼를 엑세스하는 이유는 대용량 테이블을 읽거나 쓸 때 공유 버퍼 영역을 보호하기 위해서임
- 공유 버퍼 크기가 10GB인 환경에서 10GB 크기의 테이블을 풀스캔한다면 바로 바닥난다

<br>

### 버퍼 엑세스 전략 유형
- `BAS_NORMAL` : 일반적인 버퍼 I/O시 사용함
- `BAS_BULKREAD` : 대용량 테이블에 대한 일긱 작업 시 사용함
- `BAS_BULKWRITE` : 대용량 파일에 대한 COPY 및 CTAS 작업시 사용함
- `BAS_VACUUM` : VACUUM 작업시 사용함
- NORMAL을 제외하고는 모두 `Ring Buffer`를 사용

<br>

### 대용량 테이블 판단 기준
- 테이블의 블록 수가 전체 공유 버퍼 크기의 1/4을 초과하는 경우는 대용량 테이블로 인식하고 `BULKREAD` 전략을 적용함
- 반대로 공유 버퍼의 1/4 이내의 테이블은 Seq Scan을 수행해도 전체 테이블을 공유 버퍼에 적재가 가능하다

<br>

### 링 버퍼란
- 원형 형태로 동작하는 버퍼 배열
- 일정 크기의 버퍼 영역을 순환 방식으로 사용하면서 대용량 스캔으로 인해 전체 공유 버퍼가 밀려나는 현상을 방지해줌

<br>

### 링 버퍼의 크기
- 링 버퍼는 테이블 단위로 하나씩 할당되는게 아닌 스캔 시점마다 32 블록 크기의 링 버퍼가 하나씩 할당됨
- `BULKREAD` : 256 KB (32 블록)
- `BULKWRITE` : 16 MB (2048 블록)
- `VACUUM` : 2 MB (256 블록)

<br>

## pg_stat_io 뷰를 이용한 시스템 레벨의 I/O 성능 분석
- 해당 뷰를 통해서 시스템 레벨에서 I/O 성능을 체계적으로 모니터링하고 병목 지점을 효과적으로 분석이 가능함
- 프로세스를 10가지 유형으로 분류한 뒤 각 프로세스 유형별로 오브젝트 유형 및 버퍼 엑세스 전략에 따른 다양한 성능 지표를 제공해준다

<br>

### pg_stat_io 뷰
- relation 및 temp relation 2가지 유형의 오브젝트를 제공해준다
  - relation : 테이블 및 인덱스를 의미한다
  - temp relation : Temporary 테이블 및 인덱스를 의미한다
- context 유형은 4가지를 제공하는데 버퍼 엑세스 전략과 동일한 normal, bulkread 등 이다
- `_time` 으로 끝나는 컬럼의 경우 `track_io_timing`이 on으로 설정되어있어야 가능하다
- 모든 시간 단위는 1/1000초 기준이다

<br>

### 시간 정보 활성화 시 고려사항
- I/O 성능 분석을 정확하게 하기 위해서는 I/O 처리 시간 정보가 반드시 필요하다
- 만약 시스템 상황에 따라서 처리 시간이 달라지는 경우 실행계획 변경 등 보다는 시스템 레벨에서 발생한 다른 영향을 의심해야한다
- 처리 시간 정보는 병목 분석에 매우 유용한 단서로 `track_io_timing`이 on으로 설정되어있어야 한다
- 하지만 오버헤드를 유발할 수 있으므로 pg_test_timing 유틸리티로 사전에 테스트가 필요하다

<br>

### client backend 유형의 normal I/O 비중이 높은 경우
- 원인은 버퍼 캐시 크기의 25% 보다 작은 테이블에 대한 반복적인 Seq Scan 때문일 가능성이 높다
- 이런 테이블은 블록 전체를 공유 버퍼에 적재할 수 있기 떄문에 링 버퍼를 사용하지 않는다
- 만약 동일 테이블에 대한 반복적인 Seq Scan이 확인된다면 적절한 인덱스 생성이 필요하다

<br>

### client backend 유형의 bulkread 비중이 높은 경우
- 버퍼 캐시의 25% 보다 큰 대용량 테이블에 대해 반복적인 Seq Scan 때문일 가능성이 높다
- 이런 경우 자동으로 bulkread 전략을 적용하고 링 버퍼를 사용하게된다
- 불필요한 Seq Scan 여부를 판단하고 인덱스를 생성하거나 쿼리 튜닝이 필요하다

<br>

### client backend 유형의 bulkwrite 비중이 높은 경우
- 대용량 파일에 대한 COPY 및 CTAS 작업시 발생하는 I/O 비중이 높은 경우
- 일반적으로 디비 이행 및 적재 과정에서 수행되는 작업이라 별도의 조치는 필요하지 않음
- 하지만 작업 스케줄이 서비스 시간과 겹치지 않도록 조정되었는지 여부만 확인하면됨

<br>

### client backend 유형의 temp relation IO 비중이 높은 경우
- `temp_buffer` 파라미터로 설정된 메모리(로컬 메모리)공간이 부족하기 때문임
- 필요 이상으로 많은 데이터를 Temp 테이블로 처리하는지 점검함
- 만약 실제로 필요하다면 `temp_buffer` 파라미터 값을 증가시키면됨

<br>

### background worker 유형의 bulkread 비중이 높은 경우
- 일정 크기 이상의 테이블에 대해 병렬 프로세스가 Seq Scan을 수행했기 떄문임
- PG는 테이블 크기에 따라서 자동으로 병렬 쿼리를 실행하는데 이 때 background worker가 작동함

<br>

### autovacuum worker 유형의 vacuum 비중이 높은 경우
- 바큠 대상 테이블이 많거나 동시에 수행되는 프로세스가 많은 경우 발생한다
- 만약 중요한 시간대에 Autovacuum 프로세스의 I/O 활동으로 인해 서비스 응답 시간에 영향을 준다고 판단되면 일시적으로 관련 파라미터를 OFF로 설정하고 프로세스를 정리한다

<br>

## pg_stat_all_tables, pg_statio_all_tables 뷰를 이용한 테이블 I/O 분석
### pg_stat_all_tables
- 엑세스 패턴 별 수행 횟수, 명령어 별 수행 건수 등 다양한 정보를 제공함

<br>


### pg_statio_all_tables
- 테이블 및 인덱스에 대한 I/O 블록 수를 제공해줌

<br>

### Seq Scan 방식으로 빈번하게 엑세스하는 테이블 추출 방법
- 테이블별 Seq Scan의 영향도 파악을 위해서는 수행 횟수뿐만 아니라 레코드 수 등 여러 지표를 같이 참고해야함

<br>

## pg_stat_wal 뷰를 이용한 WAL I/O 모니터링
- 성능 모니터링시 WAL I/O 모니터링은 매우 중요함
- WAL 파일은 별도의 볼륨으로 구성하기 때문에 OS 모니터링을 통해서도 현황 조회가 가능하긴하다
- 하지만 성능 분석을 위해서는 초당 발생하는 WAL 크기, Full Page Write 발생 횟수 정보가 필요하다

<br>

### pg_stat_wal 뷰
- WAL 관련 내부 처리 현황을 상세하게 모니터링할 수 있는 뷰다
- `_time`으로 끝나는 컬럼은 `track_wal_io_timing`이 on으로 설정되어있어야 가능하다

<br>

### WAL 파일 덤프 예제
```sql
root@b20fa9478609:~# pg_waldump 000000010000000000000005
rmgr: ReplicationOrigin len (rec/tot):     42/    42, tx:      89217, lsn: 0/059AF6C0, prev 0/059AF680, desc: SET set 3; lsn 0/404F740; force: 1
rmgr: Heap2       len (rec/tot):    269/   269, tx:      89217, lsn: 0/059AF6F0, prev 0/059AF6C0, desc: MULTI_INSERT ntuples: 12, flags: 0x0A, offsets: [37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48], blkref #0: rel 1663/5/16389 blk 1
rmgr: Transaction len (rec/tot):     57/    57, tx:      89217, lsn: 0/059AF800, prev 0/059AF6F0, desc: ABORT 2025-11-08 07:11:01.270996 UTC; origin: node 3, lsn 0/0, at 2025-11-08 07:11:01.234018 UTC
pg_waldump: error: error in WAL record at 0/59AF800: invalid record length at 0/59AF840: expected at least 24, got 0
```